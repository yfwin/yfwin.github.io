<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
    <url>/posts/23046aa4.html</url>
    <content><![CDATA[<p>聊聊 MySQL 的基础架构。<br>我们经常说，看一个事儿千万不要直接陷入细节里，你应该先鸟瞰其全貌，这样能够帮助你从高维度理解问题。<br>同样，对于 MySQL 的学习也是这样。<br>这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p>
<span id="more"></span>

<p>平时我们使用数据库，看到的通常都是一个整体。<br>比如，你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure>

<p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p>
<p>所以我们把 MySQL 拆解一下，看看里面都有哪些“零件”，通过拆解过程，达到对 MySQL 的更深入理解。</p>
<p>下面是 MySQ L的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。<br><img src="https://flzc.gitee.io/mynote/blog/0d2070e8f84c4801adbfa03bda1f98d9.webp.jpg" alt="MySQL的逻辑架构图"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: ## 999;padding: 2px;">
        <b>MySQL 的逻辑架构图</b>
    </div>
    <br>
</center>


<p>大体来说，MySQL可以分为 <code>Server 层</code> 和 <code>存储引擎层</code> 两部分。</p>
<p><code>Server 层</code>： 包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p><code>存储引擎层</code>： 负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。<strong>现在最常用的存储引擎是 InnoDB</strong> ，它从 MySQL 5.5.5版本开始成为了默认存储引擎。</p>
<p>也就是说，执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。<br>我们也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine&#x3D;memory, 来指定使用内存引擎创建表。<br>不同存储引擎的表数据存取方式不同，支持的功能也不同。</p>
<p>从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。<br>接下来我们结合开头提到的那条 SQL 语句，走一遍整个执行流程，依次看下每个组件的作用。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>连接命令一般是这么写的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql <span class="literal">-h</span><span class="variable">$ip</span> <span class="literal">-P</span><span class="variable">$port</span> <span class="literal">-u</span><span class="variable">$user</span> <span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<p>输完命令之后，你就需要在交互对话里面输入密码。<br>虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。<br>如果你连的是生产服务器，强烈建议你不要这么做。</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。<br>在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<p>如果用户名或密码不对，你就会收到一个 <code>Access denied for user</code> 的错误，然后客户端程序结束执行。<br>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。<br>之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。<br>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。<br>修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。<br>下图是 show processlist 的执行结果，其中的 Command 列显示为“ Sleep ”的这一行，就表示现在系统里面有一个空闲连接。<br><img src="https://flzc.gitee.io/mynote/blog/f2da4aa3a672d48ec05df97b9f992fed.webp.jpg"></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>数据库里面，<code>长连接</code> 是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<code>短连接</code> 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（ <code>OOM</code> ），从现象看就是MySQL异常重启了。</p>
<blockquote>
<p>OOM：内存溢出(Out Of Memory) <a href="https://blog.csdn.net/liang_0609/article/details/93730301">参考文章</a></p>
</blockquote>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<ul>
<li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>
</li>
<li><p>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
</li>
</ul>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> SQL_CACHE * from T <span class="built_in">where</span> ID=<span class="number">10</span>；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; elect * from t <span class="built_in">where</span> ID=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">&#x27;elect * from t where ID=1&#x27;</span> at line <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> * from t1 join t2 using(ID)  <span class="built_in">where</span> t1.c=<span class="number">10</span> and t2.d=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。<br>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。<br>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> * from T <span class="built_in">where</span> ID=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="built_in">SELECT</span> command denied to user <span class="string">&#x27;b&#x27;</span><span class="string">@&#x27;localhost&#x27; for table &#x27;T&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<p>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</p>
<p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
<p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我给你介绍了MySQL的逻辑架构，希望你对一个SQL语句完整执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p>
<p>我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句 <code>select * from T where k=1</code> , 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
<h2 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h2><p>命令 <code>mysql -h$ip -P$port -u$user -p</code>， 为什么在 -p 后跟密码可能会导致密码泄露？</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>02 | 日志系统：一条SQL更新语句是如何执行的？</title>
    <url>/posts/859aa137.html</url>
    <content><![CDATA[<p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p>
<p>那么，一条更新语句的执行流程又是怎样的呢？</p>
<span id="more"></span>

<p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？</p>
<p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/0d2070e8f84c4801adbfa03bda1f98d9.webp%20(1).jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>MySQL的逻辑架构图</b>
    </div>
    <br>
</center>

<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p>
<h1 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h1><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li>
</ul>
<p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p>
<p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p>
<p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p>
<p>与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/16a7950217b3f0f4ed02db5db59562a7.webp.jpg"></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p>
<p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h1 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h1><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p>
<p>我想你肯定会问，为什么会有两份日志呢？</p>
<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID&#x3D;2这一行的c字段加1 ”。</p>
</li>
<li><p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li><p>执行器先找引擎取ID&#x3D;2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID&#x3D;2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/2e5bff4910ec189fe1ee6e2ecc7b4bbe.webp.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>update语句执行流程</b>
    </div>
    <br>
</center>

<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>
<h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？</p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
<ol>
<li><p>先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</p>
</li>
<li><p>先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</p>
</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p>
<p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p>
<p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p>
<p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p>
<p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p>
<p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p>
<p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的答案。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>03 | 事务隔离：为什么你改了我还看不见？</title>
    <url>/posts/56fc687d.html</url>
    <content><![CDATA[<p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转100块钱，而此时你的银行卡只有100块钱。</p>
<span id="more"></span>

<p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这100块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p>
<p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。你现在知道，MySQL是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。</p>
<p>今天的文章里，我将会以InnoDB为例，剖析MySQL在事务支持方面的特定实现，并基于原理给出相应的实践建议，希望这些案例能加深你对MySQL事务原理的理解。</p>
<h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><p>提到事务，你肯定会想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中I，也就是“隔离性”。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p>
<ul>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>其中“读提交”和“可重复读”比较难理解，所以我用一个例子说明这几种隔离级别。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://flzc.gitee.io/mynote/blog/7dea45932a6b722eb069d2264d0066f8.webp"></p>
<p>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。</li>
<li>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。</li>
<li>若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li>若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。</p>
<p>配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line">+<span class="literal">-----------------------</span>+<span class="literal">----------------</span>+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="literal">-----------------------</span>+<span class="literal">----------------</span>+</span><br><span class="line">| transaction_isolation | <span class="built_in">READ-COMMITTED</span> |</span><br><span class="line">+<span class="literal">-----------------------</span>+<span class="literal">----------------</span>+</span><br></pre></td></tr></table></figure>
<p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。我想你可能会问那什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。</p>
<p>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p>
<p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p>
<h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/d9c313809e5ac148fc39feff532f0fee.webp"><br>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。</p>
<p>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。</p>
<p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。</p>
<p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h1 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h1><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：</p>
<ol>
<li><p>显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</p>
</li>
<li><p>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</p>
</li>
</ol>
<p>有些客户端连接框架会默认连接成功后先执行一个set autocommit&#x3D;0的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p>
<p>因此，我会建议你总是使用set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p>
<p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用commit work and chain语法。</p>
<p>在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章里面，我介绍了MySQL的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。希望我举的例子能够帮助你理解事务，并更好地使用MySQL的事务特性。</p>
<p>我给你留一个问题吧。你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>在上期文章的最后，我给你留下的问题是一天一备跟一周一备的对比。</p>
<p>好处是“最长恢复时间”更短。</p>
<p>在一天一备的模式里，最坏情况下需要应用一天的binlog。比如，你每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份。</p>
<p>一周一备最坏情况就要应用一周的binlog了。</p>
<p>系统的对应指标就是RTO（恢复目标时间）。</p>
<p>当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个RTO是成本换来的，就需要你根据业务重要性来评估了。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>04 | 深入浅出索引（上）</title>
    <url>/posts/d89ca279.html</url>
    <content><![CDATA[<p>提到数据库索引，我想你并不陌生，在日常工作中会经常接触到。比如某一个SQL查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。但到底什么是索引，索引又是如何工作的呢？今天就让我们一起来聊聊这个话题吧。</p>
<span id="more"></span>

<p>数据库索引的内容比较多，我分成了上下两篇文章。索引是数据库系统里面最重要的概念之一，所以我希望你能够耐心看完。在后面的实战文章中，我也会经常引用这两篇文章中提到的知识点，加深你对数据库索引的理解。</p>
<p>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
<h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p>
<p>下面我主要从使用的角度，为你简单分析一下这三种模型的区别。</p>
<p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p>
<p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<p><img src="https://flzc.gitee.io/mynote/blog/0c62b601afda86fe5d0fe57346ace957.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 哈希表示意图</b>
    </div>
    <br>
</center>

<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p>
<p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p>
<p>所以，哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。</p>
<p>而有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="https://flzc.gitee.io/mynote/blog/bfc907a92f99cadf5493cf0afac9ca49.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 有序数组示意图</b>
    </div>
    <br>
</center>

<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p>
<p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<p>所以，有序数组索引只适用于静态存储引擎，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p>
<p><img src="https://flzc.gitee.io/mynote/blog/04fb9d24065635a6a637c25ba9ddde68.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 二叉搜索树示意图</b>
    </div>
    <br>
</center>

<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p>
<p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p>
<p>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p>
<p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p>
<p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
<p>截止到这里，我用了半篇文章的篇幅和你介绍了不同的数据结构，以及它们的适用场景，你可能会觉得有些枯燥。但是，我建议你还是要多花一些时间来理解这部分内容，毕竟这是数据库处理数据的核心概念之一，在分析问题的时候会经常用到。当你理解了索引的模型后，就会发现在分析问题的时候会有一个更清晰的视角，体会到引擎设计的精妙之处。</p>
<p>现在，我们一起进入相对偏实战的内容吧。</p>
<p>在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面我就以InnoDB为例，和你分析一下其中的索引模型。</p>
<h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p>
<p>每一个索引在InnoDB里面对应一棵B+树。</p>
<p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p>
<p>这个表的建表语句是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(<span class="number">16</span>),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>
<p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/dcda101051f28502bd5c4402b292e38d.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 InnoDB的索引组织结构</b>
    </div>
    <br>
</center>

<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p>
<p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<ul>
<li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<blockquote>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
</blockquote>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li><p>只有一个索引；</p>
</li>
<li><p>该索引必须是唯一索引。</p>
</li>
</ol>
<p>你一定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我跟你分析了数据库引擎可用的数据结构，介绍了InnoDB采用的B+树结构，以及为什么InnoDB要这么选择。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p>
<p>由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。</p>
<p>最后，我给你留下一个问题吧。对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个SQL语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> index k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> index(k);</span><br></pre></td></tr></table></figure>
<p>如果你要重建主键索引，也可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure>
<p>我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章末尾给你留下的问题是：如何避免长事务对业务的影响？</p>
<p>这个问题，我们可以从应用开发端和数据库端来看。</p>
<p>首先，从应用开发端来看：</p>
<ol>
<li><p>确认是否使用了set autocommit&#x3D;0。这个确认工作可以在测试环境中开展，把MySQL的general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成1。</p>
</li>
<li><p>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin&#x2F;commit框起来。我见过有些是业务并没有这个需要，但是也把好几个select语句放到了事务中。这种只读事务可以去掉。</p>
</li>
<li><p>业务连接数据库的时候，根据业务本身的预估，通过SET MAX_EXECUTION_TIME命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）</p>
</li>
</ol>
<p>其次，从数据库端来看：</p>
<ol>
<li><p>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警&#x2F;或者kill；</p>
</li>
<li><p>Percona的pt-kill这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；</p>
</li>
<li><p>如果使用的是MySQL 5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>
</li>
</ol>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</title>
    <url>/posts/24d654e1.html</url>
    <content><![CDATA[<p>今天我要跟你聊聊MySQL的锁。数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
<span id="more"></span>

<p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。今天这篇文章，我会和你分享全局锁和表级锁。而关于行锁的内容，我会留着在下一篇文章中再和你详细介绍。</p>
<p>这里需要说明的是，锁的设计比较复杂，这两篇文章不会涉及锁的具体实现细节，主要介绍的是碰到锁时的现象和其背后的原理。</p>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>也就是把整库每个表都select出来存成文本。</p>
<p>以前有一种做法，是通过FTWRL确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。</p>
<p>但是让整库都只读，听上去就很危险：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<p>看来加全局锁不太好。但是细想一下，备份为什么要加锁呢？我们来看一下不加锁会有什么问题。</p>
<p>假设你现在要维护“极客时间”的购买系统，关注的是用户账户余额表和用户课程表。</p>
<p>现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。</p>
<p>如果时间顺序上是先备份账户余额表(u_account)，然后用户购买，然后备份用户课程表(u_course)，会怎么样呢？你可以看一下这个图：</p>
<p><img src="https://flzc.gitee.io/mynote/blog/cbfd4a0bbb1210792064bcea4e49b0cd.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 业务和备份状态图</b>
    </div>
    <br>
</center>



<p>可以看到，这个备份结果里，用户A的数据状态是“账户余额没扣，但是用户课程表里面已经多了一门课”。如果后面用这个备份来恢复数据的话，用户A就发现，自己赚了。</p>
<p>作为用户可别觉得这样可真好啊，你可以试想一下：如果备份表的顺序反过来，先备份用户课程表再备份账户余额表，又可能会出现什么结果？</p>
<p>也就是说，不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p>
<p>说到视图你肯定想起来了，我们在前面讲事务隔离的时候，其实是有一个方法能够拿到一致性视图的，对吧？</p>
<p>是的，就是在可重复读隔离级别下开启一个事务。</p>
<blockquote>
<p>备注：如果你对事务隔离级别的概念不是很清晰的话，可以再回顾一下第3篇文章<a href="./56fc687d.html">《事务隔离：为什么你改了我还看不见？》</a>中的相关内容。</p>
</blockquote>
<p>官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p>
<p>你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong>比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。</p>
<p>所以，<strong>single-transaction方法只适用于所有的表使用事务引擎的库。</strong>如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一。</p>
<p>你也许会问，既然要全库只读，为什么不使用set global readonly&#x3D;true的方式呢？确实readonly方式也可以让全库进入只读状态，但我还是会建议你用FTWRL方式，主要有两个原因：</p>
<ul>
<li>一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。</li>
<li>二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p>
<p>但是，即使没有被全局锁住，加字段也不是就能一帆风顺的，因为你还会碰到接下来我们要介绍的表级锁。</p>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁的语法是 lock tables … read&#x2F;write。</strong>与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<p><strong>另一类表级的锁是MDL（metadata lock)。</strong>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p>
</li>
<li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
</li>
</ul>
<p>虽然MDL锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p>
<p>你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表t是一个小表。</p>
<blockquote>
<p>备注：这里的实验环境是MySQL 5.6。</p>
</blockquote>
<p><img src="https://flzc.gitee.io/mynote/blog/7cf6a3bf90d72d1f0fc156ececdfb0ce.webp"></p>
<p>我们可以看到session A先启动，这时候会对表t加一个MDL读锁。由于session B需要的也是MDL读锁，因此可以正常执行。</p>
<p>之后session C会被blocked，是因为session A的MDL读锁还没有释放，而session C需要MDL写锁，因此只能被阻塞。</p>
<p>如果只有session C自己被阻塞还没什么关系，但是之后所有要在表t上新申请MDL读锁的请求也会被session C阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p>
<p>你现在应该知道了，事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p>基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？</p>
<p>首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。</p>
<p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p>
<p>这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</p>
<p>MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT&#x2F;WAIT n这个语法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ... </span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我跟你介绍了MySQL的全局锁和表级锁。</p>
<p>全局锁主要用在逻辑备份过程中。对于全部是InnoDB引擎的库，我建议你选择使用–single-transaction参数，对应用会更友好。</p>
<p>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有lock tables这样的语句，你需要追查一下，比较可能的情况是：</p>
<ul>
<li>要么是你的系统现在还在用MyISAM这类不支持事务的引擎，那要安排升级换引擎；</li>
<li>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li>
</ul>
<p>MDL会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</p>
<p>最后，我给你留一个问题吧。备份一般都会在备库上执行，你在用–single-transaction方法做逻辑备份的过程中，如果主库上的一个小表做了一个DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<p>说明：这篇文章没有介绍到物理备份，物理备份会有一篇单独的文章。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是关于对联合主键索引和InnoDB索引组织表的理解。</p>
<p>我直接贴@老杨同志 的回复略作修改如下（我修改的部分用橙色标出）：</p>
<p>表记录<br>–a–|–b–|–c–|–d–<br>1 2 3 d<br>1 3 2 d<br>1 4 3 d<br>2 1 3 d<br>2 2 2 d<br>2 3 4 d<br>主键 a，b的聚簇索引组织顺序相当于 order by a,b ，也就是先按a排序，再按b排序，c无序。</p>
<p>索引 ca 的组织是先按c排序，再按a排序，同时记录主键<br>–c–|–a–|–主键部分b– （注意，这里不是ab，而是只有b）<br>2 1 3<br>2 2 2<br>3 1 2<br>3 1 4<br>3 2 1<br>4 2 3<br>这个跟索引c的数据是一模一样的。</p>
<p>索引 cb 的组织是先按c排序，在按b排序，同时记录主键<br>–c–|–b–|–主键部分a– （同上）<br>2 2 2<br>2 3 1<br>3 1 2<br>3 2 1<br>3 4 1<br>4 3 2</p>
<p>所以，结论是ca可以去掉，cb需要保留。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>05 | 深入浅出索引（下）</title>
    <url>/posts/6ec72dcd.html</url>
    <content><![CDATA[<p>在上一篇文章中，我和你介绍了InnoDB索引的数据结构模型，今天我们再继续聊聊跟MySQL索引有关的概念。</p>
<span id="more"></span>

<p>在开始这篇文章之前，我们先来看一下这个问题：</p>
<p>在下面这个表T中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这个表的初始化语句。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT <span class="number">0</span>, </span><br><span class="line">s varchar(<span class="number">16</span>) NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://flzc.gitee.io/mynote/blog/dcda101051f28502bd5c4402b292e38d.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 InnoDB的索引组织结构</b>
    </div>
    <br>
</center>

<p>现在，我们一起来看看这条SQL查询语句的执行流程：</p>
<ol>
<li><p>在k索引树上找到k&#x3D;3的记录，取得 ID &#x3D; 300；</p>
</li>
<li><p>再到ID索引树查到ID&#x3D;300对应的R3；</p>
</li>
<li><p>在k索引树取下一个值k&#x3D;5，取得ID&#x3D;500；</p>
</li>
<li><p>再回到ID索引树查到ID&#x3D;500对应的R4；</p>
</li>
<li><p>在k索引树取下一个值k&#x3D;6，不满足条件，循环结束。</p>
</li>
</ol>
<p>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p>
<blockquote>
<p>备注：关于如何查看扫描行数的问题，我将会在第16文章《如何正确地显示随机消息？》中，和你详细讨论。</p>
</blockquote>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</p>
<p>假设这个市民表的定义是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tuser` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `id_card` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。</p>
<h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p>
<p>这里，我先和你说结论吧。B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
<p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/89f74c631110cfbc83298ef27dcd6370.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 （name，age）索引示意图</b>
    </div>
    <br>
</center>

<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是”where name like ‘张%’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。</p>
<p>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p>
<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> * from tuser <span class="built_in">where</span> name like <span class="string">&#x27;张%&#x27;</span> and age=<span class="number">10</span> and ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图3和图4，是这两个过程的执行流程图。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/b32aa8b1f75611e0759e52f5915539ac.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 无索引下推执行流程</b>
    </div>
    <br>
</center>

<p><img src="https://flzc.gitee.io/mynote/blog/76e385f3df5a694cc4238c7b65acfe1b.webp"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 索引下推执行流程</b>
    </div>
    <br>
</center>

<p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p>
<p>图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你继续讨论了数据库索引的概念，包括了覆盖索引、前缀索引、索引下推。你可以看到，在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我们在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。</p>
<p>接下来我给你留下一个问题吧。</p>
<p>实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `geek` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`,`b`),</span><br><span class="line">  KEY `c` (`c`),</span><br><span class="line">  KEY `ca` (`c`,`a`),</span><br><span class="line">  KEY `cb` (`c`,`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。</p>
<p>但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</p>
<p>同事告诉他，是因为他们的业务里面有这样的两种语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> geek <span class="keyword">where</span> c<span class="operator">=</span>N <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> geek <span class="keyword">where</span> c<span class="operator">=</span>N <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，通过两个alter 语句重建索引k，以及通过两个alter语句重建主键索引是否合理。</p>
<p>在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p>
<p>这道题目，我给你的“参考答案”是：</p>
<p>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine&#x3D;InnoDB。在专栏的第12篇文章《为什么表数据删掉一半，表文件大小不变？》中，我会和你分析这条语句的执行流程。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>08 | 事务到底是隔离的还是不隔离的？</title>
    <url>/posts/5bf55fc8.html</url>
    <content><![CDATA[<blockquote>
<p>你好，我是林晓斌。<br>你现在看到的这篇文章是我重写过的。在第一版文章发布之后，我发现在介绍事务可见性规则时，由于引入了太多概念，导致理解起来很困难。随后，我索性就重写了这篇文章。<br>现在的用户留言中，还能看到第一版文章中引入的up_limit_id的概念，为了避免大家产生误解，再此特地和大家事先说明一下。</p>
</blockquote>
<span id="more"></span>

<p>我在第3篇文章和你讲事务隔离级别的时候提到过，如果是可重复读隔离级别，事务T启动的时候会创建一个视图read-view，之后事务T执行期间，即使有其他事务修改了数据，事务T看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p>
<p>但是，我在上一篇文章中，和你分享行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</p>
<p>我给你举一个例子吧。下面是一个只有两行的表的初始化语句。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `k` int(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 事务A、B、C的执行流程</b>
    </div>
    <br>
</center>

<p>这里，我们需要注意的是事务的启动时机。</p>
<p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用start transaction with consistent snapshot 这个命令。</p>
<blockquote>
<p>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的；<br>第二种启动方式，一致性视图是在执行start transaction with consistent snapshot时创建的。</p>
</blockquote>
<p>还需要注意的是，在整个专栏里面，我们的例子中如果没有特别说明，都是默认autocommit&#x3D;1。</p>
<p>在这个例子中，事务C没有显式地使用begin&#x2F;commit，表示这个update语句本身就是一个事务，语句完成的时候会自动提交。事务B在更新了行之后查询; 事务A在一个只读事务中查询，并且时间顺序上是在事务B的查询之后。</p>
<p>这时，如果我告诉你事务B查到的k的值是3，而事务A查到的k的值是1，你是不是感觉有点晕呢？</p>
<p>所以，今天这篇文章，我其实就是想和你说明白这个问题，希望借由把这个疑惑解开的过程，能够帮助你对InnoDB的事务和锁有更进一步的理解。</p>
<p>在MySQL里，有两个“视图”的概念：</p>
<ul>
<li>一个是view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view … ，而它的查询方法与表一样。</li>
<li>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>在第3篇文章<a href="/56fc687d.html">《事务隔离：为什么你改了我还看不见？》</a>中，我跟你解释过一遍MVCC的实现逻辑。今天为了说明查询和更新的区别，我换一个方式来说明，把read view拆开。你可以结合这两篇文章的说明来更深一步地理解MVCC。</p>
<h1 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h1><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>这时，你会说这看上去不太现实啊。如果一个库有100G，那么我启动一个事务，MySQL就要拷贝100G的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p>
<p>实际上，我们并不需要拷贝出这100G的数据。我们先来看看这个快照是怎么实现的。</p>
<p>InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</p>
<p>如图2所示，就是一个记录被多个事务连续更新后的状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图2 行状态变更图</b>
</div>
<br>

</center>


<p>图中虚线框里是同一行数据的4个版本，当前最新版本是V4，k的值是22，它是被transaction id 为25的事务更新的，因此它的row trx_id也是25。</p>
<p>你可能会问，前面的文章不是说，语句更新会生成undo log（回滚日志）吗？那么，<strong>undo log在哪呢？</strong></p>
<p>实际上，图2中的三个虚线箭头，就是undo log；而V1、V2、V3并不是物理上真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p>
<p>明白了多版本和row trx_id的概念后，我们再来想一下，InnoDB是怎么定义那个“100G”的快照的。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p>在实现上， InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p>
<p>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p>
<p>这个视图数组把所有的row trx_id 分成了几种不同的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 数据版本可见性规则</b>
    </div>
    <br>
</center>

<p>这样，对于当前事务的启动瞬间来说，一个数据版本的row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p>比如，对于图2中的数据来说，如果有一个事务，它的低水位是18，那么当它访问这一行数据时，就会从V4通过U3计算出V3，所以在它看来，这一行的值是11。</p>
<p>你看，有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的2或者3(a)的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。</p>
<p>所以你现在知道了，<strong>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>
<p>接下来，我们继续看一下图1中的三个事务，分析下事务A的语句返回的结果，为什么是k&#x3D;1。</p>
<p>这里，我们不妨做如下假设：</p>
<ol>
<li>事务A开始前，系统里面只有一个活跃事务ID是99；</li>
<li>事务A、B、C的版本号分别是100、101、102，且当前系统里只有这四个事务；</li>
<li>三个事务开始前，(1,1）这一行数据的row trx_id是90。</li>
</ol>
<p>这样，事务A的视图数组就是[99,100], 事务B的视图数组是[99,100,101], 事务C的视图数组是[99,100,101,102]。</p>
<p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务A查询逻辑有关的操作：</p>
<p><img src="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 事务A查询数据逻辑图</b>
    </div>
    <br>
</center>



<p>从图中可以看到，第一个有效更新是事务C，把数据从(1,1)改成了(1,2)。这时候，这个数据的最新版本的row trx_id是102，而90这个版本已经成为了历史版本。</p>
<p>第二个有效更新是事务B，把数据从(1,2)改成了(1,3)。这时候，这个数据的最新版本（即row trx_id）是101，而102又成为了历史版本。</p>
<p>你可能注意到了，在事务A查询的时候，其实事务B还没有提交，但是它生成的(1,3)这个版本已经变成当前版本了。但这个版本对事务A必须是不可见的，否则就变成脏读了。</p>
<p>好，现在事务A要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：</p>
<ul>
<li>找到(1,3)的时候，判断出row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li>
<li>接着，找到上一个历史版本，一看row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li>
<li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li>
</ul>
<p>这样执行下来，虽然期间这一行数据被修改过，但是事务A不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p>
<p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p>
<p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<p>现在，我们用这个规则来判断图4中的查询结果，事务A的查询语句的视图数组是在事务A启动的时候生成的，这时候：</p>
<ul>
<li>(1,3)还没提交，属于情况1，不可见；</li>
<li>(1,2)虽然提交了，但是是在视图数组创建之后提交的，属于情况2，不可见；</li>
<li>(1,1)是在视图数组创建之前提交的，可见。</li>
</ul>
<p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p>
<h1 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h1><p>细心的同学可能有疑问了：<strong>事务B的update语句，如果按照一致性读，好像结果不对哦？</strong></p>
<p>你看图5中，事务B的视图数组是先生成的，之后事务C才提交，不是应该看不见(1,2)吗，怎么能算出(1,3)来？</p>
<p><img src="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 事务B更新逻辑图</b>
    </div>
    <br>
</center>



<p>是的，如果事务B在更新之前查询一次数据，这个查询返回的k的值确实是1。</p>
<p>但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务C的更新就丢失了。因此，事务B此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作。</p>
<p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong></p>
<p>因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。</p>
<p>所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。</p>
<p>这里我们提到了一个概念，叫作当前读。其实，除了update语句外，select语句如果加锁，也是当前读。</p>
<p>所以，如果把事务A的查询语句select * from t where id&#x3D;1修改一下，加上lock in share mode 或 for update，也都可以读到版本号是101的数据，返回的k的值是3。下面这两个select语句，就是分别加了读锁（S锁，共享锁）和写锁（X锁，排他锁）。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> k from t <span class="built_in">where</span> id=<span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line">mysql&gt; <span class="built_in">select</span> k from t <span class="built_in">where</span> id=<span class="number">1</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<p>再往前一步，假设事务C不是马上提交的，而是变成了下面的事务C’，会怎么样呢？</p>
<p><img src="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 事务A、B、C'的执行流程</b>
    </div>
    <br>
</center>



<p>事务C’的不同是，更新后并没有马上提交，在它提交前，事务B的更新语句先发起了。前面说过了，虽然事务C’还没提交，但是(1,2)这个版本也已经生成了，并且是当前的最新版本。那么，事务B的更新语句会怎么处理呢？</p>
<p>这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务C’没提交，也就是说(1,2)这个版本上的写锁还没释放。而事务B是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务C’释放这个锁，才能继续它的当前读。</p>
<p><img src="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 事务B更新逻辑图（配合事务C'）</b>
    </div>
    <br>
</center>



<p>到这里，我们把一致性读、当前读和行锁就串起来了。</p>
<p>现在，我们再回到文章开头的问题：<strong>事务的可重复读的能力是怎么实现的？</strong></p>
<p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<p>那么，我们再看一下，在读提交隔离级别下，事务A和事务B的查询语句查到的k，分别应该是多少呢？</p>
<p>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的start transaction。</p>
<p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的read view框。（注意：这里，我们用的还是事务C的逻辑直接提交，而不是事务C’）</p>
<p><img src="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 读提交隔离级别下的事务状态图</b>
    </div>
    <br>
</center>



<p>这时，事务A的查询语句的视图数组是在执行这个语句的时候创建的，时序上(1,2)、(1,3)的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p>
<ul>
<li>(1,3)还没提交，属于情况1，不可见；</li>
<li>(1,2)提交了，属于情况3，可见。</li>
</ul>
<p>所以，这时候事务A查询语句返回的是k&#x3D;2。</p>
<p>显然地，事务B查询结果k&#x3D;3。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>InnoDB的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。</p>
<ul>
<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li>
<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>
</ul>
<p>而当前读，总是读取已经提交完成的最新版本。</p>
<p>你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑。</p>
<p>当然，MySQL 8.0已经可以把表结构放在InnoDB字典里了，也许以后会支持表结构的可重复读。</p>
<p>又到思考题时间了。我用下面的表结构和初始化语句作为试验环境，事务隔离级别是可重复读。现在，我要把所有“字段c和id值相等的行”的c值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `c` int(<span class="number">11</span>) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, c) values(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/9b/0b/9b8fe7cf88c9ba40dc12e93e36c3060b.png"><br>复现出来以后，请你再思考一下，在实际的业务开发中有没有可能碰到这种情况？你的应用代码会不会掉进这个“坑”里，你又是怎么解决的呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后，留给你的问题是：怎么删除表的前10000行。比较多的留言都选择了第二种方式，即：在一个连接中循环执行20次 delete from T limit 500。</p>
<p>确实是这样的，第二种方式是相对较好的。</p>
<p>第一种方式（即：直接执行delete from T limit 10000）里面，单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。</p>
<p>第三种方式（即：在20个连接中同时执行delete from T limit 500），会人为造成锁冲突。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@Tony Du的评论，详细而且准确。<br>@Knight²º¹⁸ 提到了如果可以加上特定条件，将这10000行天然分开，可以考虑第三种。是的，实际上在操作的时候我也建议你尽量拿到ID再删除。<br>@荒漠甘泉 提了一个不错的问题，大家需要区分行锁、MDL锁和表锁的区别。对InnoDB表更新一行，可能过了MDL关，却被挡在行锁阶段。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>07 | 行锁功过：怎么减少行锁对性能的影响？</title>
    <url>/posts/4f0e1d85.html</url>
    <content><![CDATA[<p>在上一篇文章中，我跟你介绍了MySQL的全局锁和表级锁，今天我们就来讲讲MySQL的行锁。</p>
<span id="more"></span>

<p>MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一。</p>
<p>我们今天就主要来聊聊InnoDB的行锁，以及如何通过减少锁冲突来提升业务并发度。</p>
<p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。</p>
<p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p>
<h1 id="从两阶段锁说起"><a href="#从两阶段锁说起" class="headerlink" title="从两阶段锁说起"></a>从两阶段锁说起</h1><p>我先给你举个例子。在下面的操作序列中，事务B的update语句执行时会是什么现象呢？假设字段id是表t的主键。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/51f501f718e420244b0a2ec2ce858710.webp"><br>这个问题的结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p>
<p>知道了这个答案，你一定知道了事务A持有的两个记录的行锁，都是在commit的时候才释放的。</p>
<p>也就是说，在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li><p>从顾客A账户余额中扣除电影票价；</p>
</li>
<li><p>给影院B的账户余额增加这张电影票价；</p>
</li>
<li><p>记录一条交易日志。</p>
</li>
</ol>
<p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<p>好了，现在由于你的正确设计，影院余额这一行的行锁在一个事务中不会停留很长时间。但是，这并没有完全解决你的困扰。</p>
<p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的MySQL就挂了。你登上服务器一看，CPU消耗接近100%，但整个数据库每秒就执行不到100个事务。这是什么原因呢？</p>
<p>这里，我就要说到死锁和死锁检测了。</p>
<h1 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h1><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/4d0eeec7b136371b79248a0aed005a52.webp"><br>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务。</p>
<p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的CPU资源。</p>
<p><strong>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
<p><strong>另一个思路是控制并发度。</strong>根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。</p>
<p>因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<p>可能你会问，如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</p>
<p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p>
<p>这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你介绍了MySQL的行锁，涉及了两阶段锁协议、死锁和死锁检测这两大部分内容。</p>
<p>其中，我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的原则&#x2F;我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。</p>
<p>但是，调整语句顺序并不能完全避免死锁。所以我们引入了死锁和死锁检测的概念，以及提供了三个方案，来减少死锁对数据库的影响。减少死锁的主要方向，就是控制访问相同资源的并发事务量。</p>
<p>最后，我给你留下一个问题吧。如果你要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p>
<ul>
<li>第一种，直接执行delete from T limit 10000;</li>
<li>第二种，在一个连接中循环执行20次 delete from T limit 500;</li>
<li>第三种，在20个连接中同时执行delete from T limit 500。</li>
</ul>
<p>你会选择哪一种方法呢？为什么呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我给你留的问题是：当备库用–single-transaction做逻辑备份的时候，如果从主库的binlog传来一个DDL语句会怎么样？</p>
<p>假设这个DDL是针对表t1的， 这里我把备份过程中几个关键的语句列出来：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Q1:<span class="built_in">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:<span class="built_in">START</span> TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">/* other tables */</span><br><span class="line">Q3:SAVEPOINT <span class="built_in">sp</span>;</span><br><span class="line">/* 时刻 <span class="number">1</span> */</span><br><span class="line">Q4:show create table `t1`;</span><br><span class="line">/* 时刻 <span class="number">2</span> */</span><br><span class="line">Q5:<span class="built_in">SELECT</span> * FROM `t1`;</span><br><span class="line">/* 时刻 <span class="number">3</span> */</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT <span class="built_in">sp</span>;</span><br><span class="line">/* 时刻 <span class="number">4</span> */</span><br><span class="line">/* other tables */</span><br></pre></td></tr></table></figure>

<p>在备份开始的时候，为了确保RR（可重复读）隔离级别，再设置一次RR隔离级别(Q1);</p>
<p>启动事务，这里用 WITH CONSISTENT SNAPSHOT确保这个语句执行完就可以得到一个一致性视图（Q2)；</p>
<p>设置一个保存点，这个很重要（Q3）；</p>
<p>show create 是为了拿到表结构(Q4)，然后正式导数据 （Q5），回滚到SAVEPOINT sp，在这里的作用是释放 t1的MDL锁 （Q6）。当然这部分属于“超纲”，上文正文里面都没提到。</p>
<p>DDL从主库传过来的时间按照效果不同，我打了四个时刻。题目设定为小表，我们假定到达后，如果开始执行，则很快能够执行完成。</p>
<p>参考答案如下：</p>
<ol>
<li><p>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</p>
</li>
<li><p>如果在“时刻 2”到达，则表结构被改过，Q5执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump终止；</p>
</li>
<li><p>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，直到Q6执行完成。</p>
</li>
<li><p>从“时刻4”开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</p>
</li>
</ol>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>10 | MySQL为什么有时候会选错索引？</title>
    <url>/posts/8a5fe2c.html</url>
    <content><![CDATA[<p>前面我们介绍过索引，你已经知道了在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。</p>
<span id="more"></span>

<p>不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索引，而导致执行速度变得很慢？</p>
<p>我们一起来看一个例子吧。</p>
<p>我们先建一个简单的表，表里有a、b两个字段，并分别建上索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB；</span><br></pre></td></tr></table></figure>

<p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p>
<p>我是用存储过程来插入数据的，这里我贴出来方便你复现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>接下来，我们分析一条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;</span><br></pre></td></tr></table></figure>

<p>你一定会说，这个语句还用分析吗，很简单呀，a上有索引，肯定是要使用索引a的。</p>
<p>你说得没错，图1显示的就是使用explain命令看到的这条语句的执行情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/2c/e3/2cfce769551c6eac9bfbee0563d48fe3.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图1 使用explain命令查看语句执行情况</b>
</div>
<br>

</center>



<p>从图1看上去，这条查询语句的执行也确实符合预期，key这个字段值是’a’，表示优化器选择了索引a。</p>
<p>不过别急，这个案例不会这么简单。在我们已经准备好的包含了10万行数据的表上，我们再做如下操作。</p>
<p><img src="https://static001.geekbang.org/resource/image/1e/1e/1e5ba1c2934d3b2c0d96b210a27e1a1e.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图2 session A和session B的执行流程</b>
</div>
<br>

</center>

<p>这里，session A的操作你已经很熟悉了，它就是开启了一个事务。随后，session B把数据都删除后，又调用了 idata这个存储过程，插入了10万行数据。</p>
<p>这时候，session B的查询语句select * from t where a between 10000 and 20000就不会再选择索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。</p>
<p>为了说明优化器选择的结果是否正确，我增加了一个对照，即：使用force index(a)来让优化器强制使用索引a（这部分内容，我还会在这篇文章的后半部分中提到）。</p>
<p>下面的三条SQL语句，就是这个实验过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一句，是将慢查询日志的阈值设置为0，表示这个线程接下来的语句都会被记录入慢查询日志中；</li>
<li>第二句，Q1是session B原来的查询；</li>
<li>第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</li>
</ul>
<p>如图3所示是这三条SQL语句执行完成后的慢查询日志。</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/f6/7c58b9c71853b8bba1a8ad5e926de1f6.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图3 slow log结果</b>
</div>
<br>

</center>

<p>可以看到，Q1扫描了10万行，显然是走了全表扫描，执行时间是40毫秒。Q2扫描了10001行，执行了21毫秒。也就是说，我们在没有使用force index的时候，MySQL用错了索引，导致了更长的执行时间。</p>
<p>这个例子对应的是我们平常不断地删除历史数据和新增数据的场景。这时，MySQL竟然会选错索引，是不是有点奇怪呢？今天，我们就从这个奇怪的结果说起吧。</p>
<h1 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h1><p>在第一篇文章中，我们就提到过，选择索引是优化器的工作。</p>
<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少。</p>
<p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
<p>我们这个简单的查询语句并没有涉及到临时表和排序，所以MySQL选错索引肯定是在判断扫描行数的时候出问题了。</p>
<p>那么，问题就是：<strong>扫描行数是怎么判断的？</strong></p>
<p>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p>
<p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p>我们可以使用show index方法，看到一个索引的基数。如图4所示，就是表t的show index 的结果 。虽然这个表的每一行的三个字段值都是一样的，但是在统计信息中，这三个索引的基数值并不同，而且其实都不准确。</p>
<p><img src="https://static001.geekbang.org/resource/image/16/d4/16dbf8124ad529fec0066950446079d4.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图4 表t的show index 结果</b>
</div>
<br>

</center>

<p>那么，<strong>MySQL是怎样得到索引的基数的呢？</strong>这里，我给你简单介绍一下MySQL采样统计的方法。</p>
<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>
<p>采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过1&#x2F;M的时候，会自动触发重新做一次索引统计。</p>
<p>在MySQL中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent的值来选择：</p>
<ul>
<li>设置为on的时候，表示统计信息会持久化存储。这时，默认的N是20，M是10。</li>
<li>设置为off的时候，表示统计信息只存储在内存中。这时，默认的N是8，M是16。</li>
</ul>
<p>由于是采样统计，所以不管N是20还是8，这个基数都是很容易不准的。</p>
<p>但，这还不是全部。</p>
<p>你可以从图4中看到，这次的索引统计值（cardinality列）虽然不够精确，但大体上还是差不多的，选错索引一定还有别的原因。</p>
<p>其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。</p>
<p>接下来，我们再一起看看优化器预估的，这两个语句的扫描行数是多少。</p>
<p><img src="https://static001.geekbang.org/resource/image/e2/89/e2bc5f120858391d4accff05573e1289.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图5 意外的explain结果</b>
</div>
<br>

</center>

<p>rows这个字段表示的是预计扫描行数。</p>
<p>其中，Q1的结果还是符合预期的，rows的值是104620；但是Q2的rows值是37116，偏差就大了。而图1中我们用explain命令看到的rows是只有10001行，是这个偏差误导了优化器的判断。</p>
<p>到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？</p>
<p>这是因为，如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</p>
<p>而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。</p>
<p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</p>
<p>使用普通索引需要把回表的代价算进去，在图1执行explain的时候，也考虑了这个策略的代价 ，但图1的选择是对的。也就是说，这个策略并没有问题。</p>
<p>所以冤有头债有主，MySQL选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。至于为什么会得到错误的扫描行数，这个原因就作为课后问题，留给你去分析了。</p>
<p>既然是统计信息不对，那就修正。analyze table t 命令，可以用来重新统计索引信息。我们来看一下执行效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/20/9c/209e9d3514688a3bcabbb75e54e1e49c.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图6 执行analyze table t 命令恢复的explain结果</b>
</div>
<br>

</center>

<p>这回对了。</p>
<p>所以在实践中，如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个方法来处理。</p>
<p>其实，如果只是索引统计不准确，通过analyze命令可以解决很多问题，但是前面我们说了，优化器可不止是看扫描行数。</p>
<p>依然是基于这个表t，我们看看另外一个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>从条件上看，这个查询没有符合条件的记录，因此会返回空集合。</p>
<p>在开始执行这条语句之前，你可以先设想一下，如果你来选择索引，会选择哪一个呢？</p>
<p>为了便于分析，我们先来看一下a、b这两个索引的结构图。</p>
<p><img src="https://static001.geekbang.org/resource/image/1d/b9/1d037f92063e800c3bfff3f4dbf1a2b9.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图7 a、b索引的结构图</b>
</div>
<br>

</center>

<p>如果使用索引a进行查询，那么就是扫描索引a的前1000个值，然后取到对应的id，再到主键索引上去查出每一行，然后根据字段b来过滤。显然这样需要扫描1000行。</p>
<p>如果使用索引b进行查询，那么就是扫描索引b的最后50001个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描50001行。</p>
<p>所以你一定会想，如果使用索引a的话，执行速度明显会快很多。那么，下面我们就来看看到底是不是这么一回事儿。</p>
<p>图8是执行explain的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/48/b8/483bcb1ef3bb902844e80d9cbdd73ab8.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图8 使用explain方法查看执行计划 2</b>
</div>
<br>

</center>

<p>可以看到，返回结果中key字段显示，这次优化器选择了索引b，而rows字段显示需要扫描的行数是50198。</p>
<p>从这个结果中，你可以得到两个结论：</p>
<ol>
<li>扫描行数的估计值依然不准确；</li>
<li>这个例子里MySQL又选错了索引。</li>
</ol>
<h1 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h1><p>其实大多数时候优化器都能找到正确的索引，但偶尔你还是会碰到我们上面举例的这两种情况：原本可以执行得很快的SQL语句，执行速度却比你预期的慢很多，你应该怎么办呢？</p>
<p><strong>一种方法是，像我们第一个例子一样，采用force index强行选择一个索引。</strong>MySQL会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p>
<p>我们来看看第二个例子。刚开始分析时，我们认为选择索引a会更好。现在，我们就来看看执行效果：</p>
<p><img src="https://static001.geekbang.org/resource/image/95/54/9582401a6bed6cb8fd803c9555750b54.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图9 使用不同索引的语句执行耗时</b>
</div>
<br>

</center>

<p>可以看到，原本语句需要执行2.23秒，而当你使用force index(a)的时候，只用了0.05秒，比优化器的选择快了40多倍。</p>
<p>也就是说，优化器没有选择正确的索引，force index起到了“矫正”的作用。</p>
<p>不过很多程序员不喜欢使用force index，一来这么写不优美，二来如果索引改了名字，这个语句也得改，显得很麻烦。而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。</p>
<p>但其实使用force index最主要的问题还是变更的及时性。因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上force index。而是等到线上出现问题的时候，你才会再去修改SQL语句、加上force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。</p>
<p>所以，数据库的问题最好还是在数据库内部来解决。那么，在数据库里面该怎样解决呢？</p>
<p>既然优化器放弃了使用索引a，说明a还不够合适，所以<strong>第二种方法就是，我们可以考虑修改语句，引导MySQL使用我们期望的索引。</strong>比如，在这个例子里，显然把“order by b limit 1” 改成 “order by b,a limit 1” ，语义的逻辑是相同的。</p>
<p>我们来看看改之后的效果：</p>
<p><img src="https://static001.geekbang.org/resource/image/14/94/14cd598e52a2b72dd334a42603e5b894.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图10 order by b,a limit 1 执行结果</b>
</div>
<br>

</center>

<p>之前优化器选择使用索引b，是因为它认为使用索引b可以避免排序（b本身是索引，已经是有序的了，如果选择索引b的话，不需要再做排序，只需要遍历），所以即使扫描行数多，也判定为代价更小。</p>
<p>现在order by b,a 这种写法，要求按照b,a排序，就意味着使用这两个索引都需要排序。因此，扫描行数成了影响决策的主要条件，于是此时优化器选了只需要扫描1000行的索引a。</p>
<p>当然，这种修改并不是通用的优化手段，只是刚好在这个语句里面有limit 1，因此如果有满足条件的记录， order by b limit 1和order by b,a limit 1 都会返回b是最小的那一行，逻辑上一致，才可以这么做。</p>
<p>如果你觉得修改语义这件事儿不太好，这里还有一种改法，图11是执行效果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>)  <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">100</span>)alias limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/b1/d7/b1a2ad43c78477d7f93dbc692cbaa0d7.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图11 改写SQL的explain</b>
</div>
<br>

</center>

<p>在这个例子里，我们用limit 100让优化器意识到，使用b索引代价是很高的。其实是我们根据数据特征诱导了一下优化器，也不具备通用性。</p>
<p><strong>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</strong></p>
<p>不过，在这个例子中，我没有找到通过新增索引来改变优化器行为的方法。这种情况其实比较少，尤其是经过DBA索引优化过的库，再碰到这个bug，找到一个更合适的索引一般比较难。</p>
<p>如果我说还有一个方法是删掉索引b，你可能会觉得好笑。但实际上我碰到过两次这样的例子，最终是DBA跟业务开发沟通后，发现这个优化器错误选择的索引其实根本没有必要存在，于是就删掉了这个索引，优化器也就重新选择到了正确的索引。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我们一起聊了聊索引统计的更新机制，并提到了优化器存在选错索引的可能性。</p>
<p>对于由于索引统计信息不准确导致的问题，你可以用analyze table来解决。</p>
<p>而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。</p>
<p>你可能会说，今天这篇文章后面的几个例子，怎么都没有展开说明其原理。我要告诉你的是，今天的话题，我们面对的是MySQL的bug，每一个展开都必须深入到一行行代码去量化，实在不是我们在这里应该做的事情。</p>
<p>所以，我把我用过的解决方法跟你分享，希望你在碰到类似情况的时候，能够有一些思路。</p>
<p>你平时在处理MySQL优化器bug的时候有什么别的方法，也发到评论区分享一下吧。</p>
<p>最后，我给你留下一个思考题。前面我们在构造第一个例子的过程中，通过session A的配合，让session B删除数据后又重新插入了一遍数据，然后就发现explain结果中，rows字段从10001变成37000多。</p>
<p>而如果没有session A的配合，只是单独执行delete from t 、call idata()、explain这三句话，会看到rows字段其实还是10000左右。你可以自己验证一下这个结果。</p>
<p>这是什么原因呢？也请你分析一下吧。</p>
<p>你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后留给你的问题是，如果某次写入使用了change buffer机制，之后主机异常重启，是否会丢失change buffer和数据。</p>
<p>这个问题的答案是不会丢失，留言区的很多同学都回答对了。虽然是只更新内存，但是在事务提交的时候，我们把change buffer的操作也记录到redo log里了，所以崩溃恢复的时候，change buffer也能找回来。</p>
<p>在评论区有同学问到，merge的过程是否会把数据直接写回磁盘，这是个好问题。这里，我再为你分析一下。</p>
<p>merge的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更。</li>
</ol>
<p>到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>12 | 为什么我的MySQL会“抖”一下？</title>
    <url>/posts/b4ac2666.html</url>
    <content><![CDATA[<p>平时的工作中，不知道你有没有遇到过这样的场景，一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p>
<p>看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。</p>
<span id="more"></span>

<h1 id="你的SQL语句为什么变“慢”了"><a href="#你的SQL语句为什么变“慢”了" class="headerlink" title="你的SQL语句为什么变“慢”了"></a>你的SQL语句为什么变“慢”了</h1><p>在前面第2篇文章<a href="/859aa137.html">《日志系统：一条SQL更新语句是如何执行的？》</a>中，我为你介绍了WAL机制。现在你知道了，InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p>
<p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p>
<p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是flush。在这个flush操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p>
<p><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。</p>
<p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p>
<p>接下来，我们用一个示意图来展示一下“孔乙己赊账”的整个操作过程。假设原来孔乙己欠账10文，这次又要赊9文。</p>
<p><img src="https://static001.geekbang.org/resource/image/34/da/349cfab9e4f5d2a75e07b2132a301fda.jpeg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 “孔乙己赊账”更新和flush过程</b>
    </div>
    <br>
</center>



<p>回到文章开头的问题，你不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p>
<p>那么，什么情况会引发数据库的flush过程呢？</p>
<p>我们还是继续用咸亨酒店掌柜的这个例子，想一想：掌柜在什么情况下会把粉板上的赊账记录改到账本上？</p>
<ul>
<li>第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。<br>这个场景，对应的就是InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。我在第二讲画了一个redo log的示意图，这里我改成环形，便于大家理解。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 redo log状态图</b>
    </div>
    <br>
</center>



<p>checkpoint可不是随便往前修改一下位置就可以的。比如图2中，把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。之后，图中从write pos到CP’之间就是可以再写入的redo log的区域。</p>
<ul>
<li>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。<br>这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。<br>你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：<ul>
<li>一种是内存里存在，内存里就肯定是正确的结果，直接返回；</li>
<li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。<br>这样的效率最高。</li>
</ul>
</li>
<li>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。<br>这种场景，对应的就是MySQL认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</li>
<li>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。<br>这种场景，对应的就是MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ul>
<p>接下来，<strong>你可以分析一下上面四种场景对性能的影响。</strong></p>
<p>其中，第三种情况是属于MySQL空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。</p>
<p>第一种是“redo log写满了，要flush脏页”，这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</p>
<p>第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p>
<ul>
<li>第一种是，还没有使用的；</li>
<li>第二种是，使用了并且是干净页；</li>
<li>第三种是，使用了并且是脏页。</li>
</ul>
<p>InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li>
</ol>
<p>所以，InnoDB需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p>
<h1 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h1><p>接下来，我就来和你说说InnoDB脏页的控制策略，以及和这些策略相关的参数。</p>
<p>首先，你要正确地告诉InnoDB所在主机的IO能力，这样InnoDB才能知道需要全力刷脏页的时候，可以刷多快。</p>
<p>这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。磁盘的IOPS可以通过fio这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">fio <span class="literal">-filename</span>=<span class="variable">$filename</span> <span class="literal">-direct</span>=<span class="number">1</span> <span class="literal">-iodepth</span> <span class="number">1</span> <span class="literal">-thread</span> <span class="literal">-rw</span>=randrw <span class="literal">-ioengine</span>=psync <span class="literal">-bs</span>=<span class="number">16</span>k <span class="literal">-size</span>=<span class="number">500</span>M <span class="literal">-numjobs</span>=<span class="number">10</span> <span class="literal">-runtime</span>=<span class="number">10</span> <span class="literal">-group_reporting</span> <span class="literal">-name</span>=mytest</span><br></pre></td></tr></table></figure>

<p>其实，因为没能正确地设置innodb_io_capacity参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说MySQL的写入速度很慢，TPS很低，但是数据库主机的IO压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。</p>
<p>他的主机磁盘用的是SSD，但是innodb_io_capacity的值设置的是300。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</p>
<p>虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看InnoDB怎么控制引擎按照“全力”的百分比来刷脏页。</p>
<p>根据我前面提到的知识点，试想一下，<strong>如果你来设计策略控制刷脏页的速度，会参考哪些因素呢？</strong></p>
<p>这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是redo log写满。</p>
<p>所以，InnoDB的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是redo log写盘速度。</p>
<p>InnoDB会根据这两个因素先单独算出两个数字。</p>
<p>参数innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字，计算这个数字的伪代码类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">F1</span>(<span class="params">M</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</p>
<p>然后，<strong>根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的速度。</strong></p>
<p>上述的计算流程比较抽象，不容易理解，所以我画了一个简单的流程图。图中的F1、F2就是上面我们通过脏页比例和redo log写入速度算出来的两个值。</p>
<p><img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 InnoDB刷脏页速度策略</b>
    </div>
    <br>
</center>



<p>现在你知道了，InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</p>
<p>要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，并且**平时要多关注脏页比例，不要让它经常接近75%**。</p>
<p>其中，脏页比例是通过Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total得到的，具体的命令参考下面的代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@a</span><span class="operator">/</span><span class="variable">@b</span>;</span><br></pre></td></tr></table></figure>

<p>接下来，我们再看一个有趣的策略。</p>
<p>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p>
<p>在InnoDB中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。</p>
<p>找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机IO。机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</p>
<p>而如果使用的是SSD这类IOPS比较高的设备的话，我就建议你把innodb_flush_neighbors的值设置成0。因为这时候IOPS往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</p>
<p>在MySQL 8.0中，innodb_flush_neighbors参数的默认值已经是0了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我延续第2篇中介绍的WAL的概念，和你解释了这个机制后续需要的刷脏页操作和执行时机。利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。</p>
<p>但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。在文章里，我也给你介绍了控制刷脏页的方法和对应的监控方式。</p>
<p>文章最后，我给你留下一个思考题吧。</p>
<p>一个内存配置为128GB、innodb_io_capacity设置为20000的大规格实例，正常会建议你将redo log设置成4个1GB的文件。</p>
<p>但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢？又为什么会出现这样的情况呢？</p>
<p>你可以把你的分析结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我留给你的问题是，给一个学号字段创建索引，有哪些方法。</p>
<p>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。</p>
<p>而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</p>
<p>评论区中，也有其他一些很不错的见解。</p>
<p>评论用户@封建的风 说，一个学校的总人数这种数据量，50年才100万学生，这个表肯定是小表。为了业务简单，直接存原来的字符串。这个答复里面包含了“优化成本和收益”的思想，我觉得值得at出来。</p>
<p>@小潘 同学提了另外一个极致的方向。如果碰到表数据量特别大的场景，通过这种方式的收益是很不错的。</p>
<h2 id="精选留言"><a href="#精选留言" class="headerlink" title="精选留言"></a>精选留言</h2><p>@Tony Du：<br>当内存不够用了，要将脏页写到磁盘，会有一个数据页淘汰机制（最久不使用），假设淘汰的是脏页，则此时脏页所对应的redo log的位置是随机的，当有多个不同的脏页需要刷，则对应的redo log可能在不同的位置，这样就需要把redo log的多个不同位置刷掉，这样对于redo log的处理不是就会很麻烦吗？（合并间隙，移动位置？）<br>另外，redo log的优势在于将磁盘随机写转换成了顺序写，如果需要将redo log的不同部分刷掉（刷脏页），不是就在redo log里随机读写了么？</p>
<p>@作者 回复：<br>其实由于淘汰的时候，刷脏页过程不用动redo log文件的。</p>
<p>这个有个额外的保证，是redo log在“重放”的时候，如果一个数据页已经是刷过的，会识别出来并跳过。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>13 | 为什么表数据删掉一半，表文件大小不变？</title>
    <url>/posts/d831b665.html</url>
    <content><![CDATA[<p>经常会有同学来问我，我的数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</p>
<p>那么今天，我就和你聊聊数据库表的空间回收，看看如何解决这个问题。</p>
<span id="more"></span>

<p>这里，我们还是针对MySQL中应用最广泛的InnoDB引擎展开讨论。一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，所以我们今天主要讨论的是表数据。</p>
<p>接下来，我会先和你说明为什么简单地删除表数据达不到表空间回收的效果，然后再和你介绍正确回收空间的方法。</p>
<h1 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="headerlink" title="参数innodb_file_per_table"></a>参数innodb_file_per_table</h1><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：</p>
<ol>
<li>这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>
<li>这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。</li>
</ol>
<p>从MySQL 5.6.6版本开始，它的默认值就是ON了。</p>
<p>我建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<p>所以，<strong>将innodb_file_per_table设置为ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p>
<p>我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p>
<p>我们要彻底搞明白这个问题的话，就要从数据删除流程说起了。</p>
<h1 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h1><p>我们先再来看一下InnoDB中一个索引的示意图。在前面<a href="/d89ca279.html">第4</a>和<a href="/6ec72dcd.html">第5</a>篇文章中，我和你介绍索引时曾经提到过，InnoDB里的数据都是用B+树的结构组织的。</p>
<p><img src="https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 B+树索引示意图</b>
    </div>
    <br>
</center>


<p>假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p>
<p>现在，你已经知道了InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，会怎么样？</p>
<p>答案是，整个数据页就可以被复用了。</p>
<p>但是，<strong>数据页的复用跟记录的复用是不同的。</strong></p>
<p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</p>
<p>而当整个页从B+树里面摘掉以后，可以复用到任何位置。以图1为例，如果将数据页page A上的所有记录删除以后，page A会被标记为可复用。这时候如果要插入一条ID&#x3D;50的记录需要使用新页的时候，page A是可以被复用的。</p>
<p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p>
<p>进一步地，如果我们用delete命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p>
<p>你现在知道了，delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p>
<p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<p>假设图1中page A已经满了，这时我要再插入一行数据，会怎样呢？</p>
<p><img src="https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 插入数据导致页分裂</b>
    </div>
    <br>
</center>


<p>可以看到，由于page A满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面page B来保存数据了。页分裂完成后，page A的末尾就留下了空洞（注意：实际上，可能不止1个记录的位置是空洞）。</p>
<p>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p>
<p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p>
<p>而重建表，就可以达到这样的目的。</p>
<h1 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h1><p>试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？</p>
<p>你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。</p>
<p>由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。显然地，表B的主键索引更紧凑，数据页的利用率也更高。如果我们把表B作为临时表，数据从表A导入表B的操作完成后，用表B替换A，从效果上看，就起到了收缩表A空间的作用。</p>
<p>这里，你可以使用alter table A engine&#x3D;InnoDB命令来重建表。在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表B不需要你自己创建，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p>
<p><img src="https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 改锁表DDL</b>
    </div>
    <br>
</center>


<p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表A的话，就会造成数据丢失。因此，在整个DDL过程中，表A中不能有更新。也就是说，这个DDL不是Online的。</p>
<p>而在<strong>MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。</strong></p>
<p>我给你简单描述一下引入了Online DDL之后，重建表的流程：</p>
<ol>
<li>建立一个临时文件，扫描表A主键的所有数据页；</li>
<li>用数据页中表A的记录生成B+树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</li>
<li>用临时文件替换表A的数据文件。</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 Online DDL</b>
    </div>
    <br>
</center>

<p>可以看到，与图3过程的不同之处在于，由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表A做增删改操作。这也就是Online DDL名字的来源。</p>
<p>我记得有同学在第6篇讲表锁的文章<a href="/24d654e1.html">《全局锁和表锁 ：给表加个字段怎么索这么多阻碍？》</a>的评论区留言说，DDL之前是要拿MDL写锁的，这样还能叫Online DDL吗？</p>
<p>确实，图4的流程中，alter语句在启动的时候需要获取MDL写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p>
<p>为什么要退化呢？为了实现Online，MDL读锁不会阻塞增删改操作。</p>
<p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做DDL。</p>
<p>而对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说，就可以认为是Online的。</p>
<p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗IO和CPU资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用GitHub开源的gh-ost来做。</p>
<h1 id="Online-和-inplace"><a href="#Online-和-inplace" class="headerlink" title="Online 和 inplace"></a>Online 和 inplace</h1><p>说到Online，我还要再和你澄清一下它和另一个跟DDL有关的、容易混淆的概念inplace的区别。</p>
<p>你可能注意到了，在图3中，我们把表A中的数据导出来的存放位置叫作tmp_table。这是一个临时表，是在server层创建的。</p>
<p>在图4中，根据表A重建出来的数据是放在“tmp_file”里的，这个临时文件是InnoDB在内部创建出来的。整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</p>
<p>所以，我现在问你，如果你有一个1TB的表，现在磁盘间是1.2TB，能不能做一个inplace的DDL呢？</p>
<p>答案是不能。因为，tmp_file也是要占用临时空间的。</p>
<p>我们重建表的这个语句alter table t engine&#x3D;InnoDB，其实隐含的意思是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span>inplace;</span><br></pre></td></tr></table></figure>

<p>跟inplace对应的就是拷贝表的方式了，用法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span><span class="keyword">copy</span>;</span><br></pre></td></tr></table></figure>

<p>当你使用ALGORITHM&#x3D;copy的时候，表示的是强制拷贝表，对应的流程就是图3的操作过程。</p>
<p>但我这样说你可能会觉得，inplace跟Online是不是就是一个意思？</p>
<p>其实不是的，只是在重建表这个逻辑中刚好是这样而已。</p>
<p>比如，如果我要给InnoDB表的一个字段加全文索引，写法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> FULLTEXT(field_name);</span><br></pre></td></tr></table></figure>

<p>这个过程是inplace的，但会阻塞增删改操作，是非Online的。</p>
<p>如果说这两个逻辑之间的关系是什么的话，可以概括为：</p>
<ol>
<li>DDL过程如果是Online的，就一定是inplace的；</li>
<li>反过来未必，也就是说inplace的DDL，有可能不是Online的。截止到MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引(SPATIAL index)就属于这种情况。</li>
</ol>
<p>最后，我们再延伸一下。</p>
<p>在第10篇文章<a href="https://time.geekbang.org/column/article/71173">《MySQL为什么有时候会选错索引》</a>的评论区中，有同学问到使用optimize table、analyze table和alter table这三种方式重建表的区别。这里，我顺便再简单和你解释一下。</p>
<ul>
<li>从MySQL 5.6版本开始，alter table t engine &#x3D; InnoDB（也就是recreate）默认的就是上面图4的流程了；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li>
<li>optimize table t 等于recreate+analyze。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你讨论了数据库中收缩表空间的方法。</p>
<p>现在你已经知道了，如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。我跟你介绍了重建表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，而MySQL 5.5及之前的版本，这个命令是会阻塞DML的，这个你需要特别小心。</p>
<p>最后，又到了我们的课后问题时间。</p>
<p>假设现在有人碰到了一个“想要收缩表空间，结果适得其反”的情况，看上去是这样的：</p>
<ol>
<li>一个表t文件大小为1TB；</li>
<li>对这个表执行 alter table t engine&#x3D;InnoDB；</li>
<li>发现执行完成后，空间不仅没变小，还稍微大了一点儿，比如变成了1.01TB。</li>
</ol>
<p>你觉得可能是什么原因呢 ？</p>
<p>你可以把你觉得可能的原因写在留言区里，我会在下一篇文章的末尾把大家描述的合理的原因都列出来，以后其他同学就不用掉到这样的坑里了。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>在上期文章最后，我留给你的问题是，如果一个高配的机器，redo log设置太小，会发生什么情况。</p>
<p>每次事务提交都要写redo log，如果设置太小，很快就会被写满，也就是下面这个图的状态，这个“环”将很快被写满，write pos一直追着CP。</p>
<p><img src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg"></p>
<p>这时候系统不得不停止所有更新，去推进checkpoint。</p>
<p>这时，你看到的现象就是<strong>磁盘压力很小，但是数据库出现间歇性的性能下跌。</strong></p>
<h1 id="评论区留言点赞板："><a href="#评论区留言点赞板：" class="headerlink" title="评论区留言点赞板："></a>评论区留言点赞板：</h1><p>@某、人 给了一个形象的描述，而且提到了，在这种情况下，连change buffer的优化也失效了。因为checkpoint一直要往前推，这个操作就会触发merge操作，然后又进一步地触发刷脏页操作；</p>
<p>@算不出流源 提到了“动态平衡”，其实只要出现了这种“平衡”，意味着本应该后台的操作，就已经影响了业务应用，属于有损失的平衡。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>09 | 普通索引和唯一索引，应该怎么选择</title>
    <url>/posts/2dd52b6a.html</url>
    <content><![CDATA[<p>在前面的基础篇文章中，我给你介绍过索引的基本概念，相信你已经了解了唯一索引和普通索引的区别。今天我们就继续来谈谈，在不同的业务场景下，应该选择普通索引，还是唯一索引？</p>
<span id="more"></span>

<p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> CUser <span class="keyword">where</span> id_card <span class="operator">=</span> <span class="string">&#x27;xxxxxxxyyyyyyzzzzz&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>所以，你一定会考虑在id_card字段上建索引。</p>
<p>由于身份证号字段比较大，我不建议你把身份证号当做主键，那么现在你有两个选择，要么给id_card字段创建唯一索引，要么创建一个普通索引。如果业务代码已经保证了不会写入重复的身份证号，那么这两个选择逻辑上都是正确的。</p>
<p>现在我要问你的是，从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p>
<p>简单起见，我们还是用第4篇文章<a href="/d89ca279.html">《深入浅出索引（上）》</a>中的例子来说明，假设字段 k 上的值都不重复。</p>
<p><img src="https://static001.geekbang.org/resource/image/1e/46/1ed9536031d6698570ea175a7b7f9a46.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图1 InnoDB的索引组织结构</b>
</div>
<br>

</center>

<p>接下来，我们就从这两种索引对查询语句和更新语句的性能影响来进行分析。</p>
<h1 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h1><p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p>
<p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p>
<p>因为引擎是按页读写的，所以说，当找到k&#x3D;5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>当然，如果k&#x3D;5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p>
<p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<h1 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h1><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，我需要先跟你介绍一下change buffer。</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。</p>
<p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。</p>
<p>显然，如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<p>那么，<strong>什么条件下可以使用change buffer呢？</strong></p>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k&#x3D;4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。</p>
<p>因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。</p>
<p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>现在，你已经理解了change buffer的机制，那么我们再一起来看看<strong>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的。</strong></p>
<p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</li>
</ul>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p>
<p>但，这不是我们关注的重点。</p>
<p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li>
</ul>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<p>之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引。</p>
<h1 id="change-buffer的使用场景"><a href="#change-buffer的使用场景" class="headerlink" title="change buffer的使用场景"></a>change buffer的使用场景</h1><p>通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？</p>
<p>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p>
<h1 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h1><p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。</p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</p>
<p>在实际使用中，你会发现，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。</p>
<p>特别地，在使用机械硬盘时，change buffer这个机制的收效是非常显著的。所以，当你有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，那你应该特别关注这些表里的索引，尽量使用普通索引，然后把change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p>
<h1 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h1><p>理解了change buffer的原理，你可能会联想到我在前面文章中和你介绍过的redo log和WAL。</p>
<p>在前面文章的评论中，我发现有同学混淆了redo log和change buffer。WAL 提升性能的核心机制，也的确是尽量减少随机读写，这两个概念确实容易混淆。所以，这里我把它们放到了同一个流程里来说明，便于你区分这两个概念。</p>
<blockquote>
<p>备注：这里，你可以再回顾下第2篇文章<a href="/859aa137.html">《日志系统：一条SQL更新语句是如何执行的？》</a>中的相关内容。</p>
</blockquote>
<p>现在，我们要在表上执行这个插入语句：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>

<p>这里，我们假设当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。如图2所示是带change buffer的更新状态图。</p>
<p><img src="https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图2 带change buffer的更新过程</b>
</div>
<br>

</center>

<p>分析这条更新语句，你会发现它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p>
<p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p>
<ol>
<li>Page 1在内存中，直接更新内存；</li>
<li>Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息</li>
<li>将上述两个动作记入redo log中（图中3和4）。</li>
</ol>
<p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p>
<p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。</p>
<p>那在这之后的读请求，要怎么处理呢？</p>
<p>比如，我们现在要执行 <code>select * from t where k in (k1, k2)</code> 。这里，我画了这两个读请求的流程图。</p>
<p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。所以，我在图中就没画出这两部分。</p>
<p><img src="https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png"></p>
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
<b>图3 带change buffer的读过程</b>
</div>
<br>

</center>
从图中可以看到：

<ol>
<li>读Page 1的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。你可以看一下图3的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</li>
<li>要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。</li>
</ol>
<p>可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。</p>
<p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我从普通索引和唯一索引的选择开始，和你分享了数据的查询和更新过程，然后说明了change buffer的机制以及应用场景，最后讲到了索引选择的实践。</p>
<p>由于唯一索引用不上change buffer的优化机制，因此如果业务可以接受，从性能角度出发我建议你优先考虑非唯一索引。</p>
<p>最后，又到了思考题时间。</p>
<p>通过图2你可以看到，change buffer一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致change buffer丢失呢？change buffer丢失可不是小事儿，再从磁盘读入数据可就没有了merge过程，就等于是数据丢失了。会不会出现这种情况呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<p><strong>补充：</strong><br>评论区大家对“是否使用唯一索引”有比较多的讨论，主要是纠结在“业务可能无法确保”的情况。这里，我再说明一下：</p>
<ul>
<li>首先，业务正确性优先。咱们这篇文章的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。这种情况下，本篇文章的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，可以给你多提供一个排查思路。</li>
<li>然后，在一些“归档库”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。</li>
</ul>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是：如何构造一个“数据无法修改”的场景。评论区里已经有不少同学给出了正确答案，这里我再描述一下。</p>
<p><img src="https://static001.geekbang.org/resource/image/be/ae/be7a4d8af04cdf93aaa11108933559ae.png"><br>这样，session A看到的就是我截图的效果了。</p>
<p>其实，还有另外一种场景，同学们在留言区都还没有提到。</p>
<p><img src="https://static001.geekbang.org/resource/image/e2/fa/e24a0689571337959138d787c408defa.png"></p>
<p>这个操作序列跑出来，session A看的内容也是能够复现我截图的效果的。这个session B’启动的事务比A要早，其实是上期我们描述事务版本的可见性规则时留的彩蛋，因为规则里还有一个“活跃事务的判断”，我是准备留到这里再补充的。</p>
<p>当我试图在这里讲述完整规则的时候，发现第8篇文章<a href="/5bf55fc8.html">《事务到底是隔离的还是不隔离的？》</a>中的解释引入了太多的概念，以致于分析起来非常复杂。</p>
<p>因此，我重写了第8篇，这样我们人工去判断可见性的时候，才会更方便。【看到这里，我建议你能够再重新打开第8篇文章并认真学习一次。如果学习的过程中，有任何问题，也欢迎你给我留言】</p>
<p>用新的方式来分析session B’的更新为什么对session A不可见就是：在session A视图数组创建的瞬间，session B’是活跃的，属于“版本未提交，不可见”这种情况。</p>
<p>业务中如果要绕过这类问题，@约书亚提供了一个“乐观锁”的解法，大家可以去上一篇的留言区看一下。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>11 | 怎么给字符串字段加索引？</title>
    <url>/posts/bc52c5bf.html</url>
    <content><![CDATA[<p>现在，几乎所有的系统都支持邮箱登录，如何在邮箱这样的字段上建立合理的索引，是我们今天要讨论的问题。</p>
<span id="more"></span>

<p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> SUser(</span><br><span class="line">ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>), </span><br><span class="line">... </span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>

<p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> f1, f2 <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>从第4和第5篇讲解索引的文章中，我们可以知道，如果email这个字段上没有索引，那么这个语句就只能做全表扫描。</p>
<p>同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p>
<p>比如，这两个在email字段上创建索引的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index1(email);</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。</p>
<p>那么，这两种不同的定义在数据结构和存储上有什么区别呢？如图2和3所示，就是这两个索引的示意图。</p>
<p><img src="https://static001.geekbang.org/resource/image/d3/b7/d31da662bee595991862c439a5567eb7.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 email 索引结构</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/13/42/134583875561de914991fc2e192cf842.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 email(6) 索引结构</b>
    </div>
    <br>
</center>

<p>从图中你可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</p>
<p>但，这同时带来的损失是，可能会增加额外的记录扫描次数。</p>
<p>接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li>从index1索引树找到满足索引值是’<a href="mailto:&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#x79;&#122;&#x40;&#120;&#x78;&#120;&#46;&#99;&#x6f;&#109;">&#122;&#x68;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#x79;&#122;&#x40;&#120;&#x78;&#120;&#46;&#99;&#x6f;&#109;</a>’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email&#x3D;‘<a href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#115;&#x78;&#x79;&#122;&#64;&#120;&#120;&#x78;&#x2e;&#x63;&#111;&#109;">&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#115;&#x78;&#x79;&#122;&#64;&#120;&#120;&#x78;&#x2e;&#x63;&#111;&#109;</a>’的条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#x7a;&#x68;&#97;&#110;&#103;&#115;&#x73;&#x78;&#x79;&#x7a;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#x6d;">&#x7a;&#x68;&#97;&#110;&#103;&#115;&#x73;&#x78;&#x79;&#x7a;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#x6d;</a>’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</p>
<p>通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p>
<p>但是，对于这个查询语句来说，如果你定义的index2不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。</p>
<p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>于是，你就有个问题：当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p>
<p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>
<p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure>

<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>

<p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。</p>
<h1 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h1><p>前面我们说了使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此，我们再看一下另外一个场景。</p>
<p>你先来看看这个SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>与前面例子中的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>相比，这个语句只要求返回id和email字段。</p>
<p>所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</p>
<p>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p>
<p>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
<h1 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h1><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时，我们要怎么办呢？</p>
<p>比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。</p>
<p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。</p>
<p>按照我们前面说的方法，可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。</p>
<p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p>
<p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p>
<p>答案是，有的。</p>
<p><strong>第一种方式是使用倒序存储。</strong> 如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用count(distinct)方法去做个验证。</p>
<p><strong>第二种方式是使用hash字段。</strong> 你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure>

<p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc<span class="operator">=</span>crc32(<span class="string">&#x27;input_id_card_string&#x27;</span>) <span class="keyword">and</span> id_card<span class="operator">=</span><span class="string">&#x27;input_id_card_string&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样，索引的长度变成了4个字节，比原来小了很多。</p>
<p>接下来，我们再一起看看<strong>使用倒序存储和使用hash字段这两种方法的异同点。</strong></p>
<p>首先，它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在[ID_X, ID_Y]的所有市民了。同样地，hash字段的方式也只能支持等值查询。</p>
<p>它们的区别，主要体现在以下三个方面：</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</li>
<li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在今天这篇文章中，我跟你聊了聊字符串字段创建索引的场景。我们来回顾一下，你可以使用的方式有：</p>
<ol>
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ol>
<p>在实际应用中，你要根据业务字段的特点选择使用哪种方式。</p>
<p>好了，又到了最后的问题时间。</p>
<p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。</p>
<p>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p>
<p>你可以把你的分析思路和设计结果写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上篇文章中的第一个例子，评论区有几位同学说没有复现，大家要检查一下隔离级别是不是RR（Repeatable Read，可重复读），创建的表t是不是InnoDB引擎。我把复现过程做成了一个视频，供你参考。<br><video preload="none" controls=""><source src="https://static001.geekbang.org/resource/video/2a/76/2a3ac914a325cdff1ca6ba999d1b8c76.mp4" type="video/mp4"><source src="https://res001.geekbang.org/media/video/2a/76/2a3ac914a325cdff1ca6ba999d1b8c76/sd/sd.m3u8" type="application/x-mpegURL"><source src="https://res001.geekbang.org/media/video/2a/76/2a3ac914a325cdff1ca6ba999d1b8c76/hd/hd.m3u8" type="application/x-mpegURL"></video></p>
<p>在上一篇文章最后，我给你留的问题是，为什么经过这个操作序列，explain的结果就不对了？这里，我来为你分析一下原因。</p>
<p>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来的10万行。</p>
<p>但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数据。</p>
<p>这样，索引a上的数据其实就有两份。</p>
<p>然后你会说，不对啊，主键上的数据也不能删，那没有使用force index的语句，使用explain命令看到的扫描行数为什么还是100000左右？（潜台词，如果这个也翻倍，也许优化器还会认为选字段a作为索引更合适）</p>
<p>是的，不过这个是主键，主键是直接按照表的行数来估计的。而表的行数，优化器直接用的是show table status的值。</p>
<p>这个值的计算方法，我会在后面有文章为你详细讲解。</p>
<p><img src="https://static001.geekbang.org/resource/image/e0/67/e0e4c8381f3feae4d87958470760d367.png"></p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>14 | count(*)这么慢，我该怎么办？</title>
    <url>/posts/c3e2259f.html</url>
    <content><![CDATA[<p>在开发系统的时候，你可能经常需要计算一个表的行数，比如一个交易系统的所有变更记录总数。这时候你可能会想，一条 <code>select count(*) from t</code>  语句不就解决了吗？</p>
<span id="more"></span>

<p>但是，你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。然后你可能就想了，MySQL怎么这么笨啊，记个总数，每次要查的时候直接读出来，不就好了吗。</p>
<p>那么今天，我们就来聊聊count(*)语句到底是怎样实现的，以及MySQL为什么会这么实现。然后，我会再和你说说，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做。</p>
<h1 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)的实现方式"></a>count(*)的实现方式</h1><p>你首先要明确的是，在不同的MySQL引擎中，count(*)有不同的实现方式。</p>
<ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</li>
<li>而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p>
<p>在前面的文章中，我们一起分析了为什么要使用InnoDB，因为不论是在事务支持、并发能力还是在数据安全方面，InnoDB都优于MyISAM。我猜你的表也一定是用了InnoDB引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。</p>
<p>那<strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p>
<p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。这里，我用一个算count(*)的例子来为你解释一下。</p>
<p>假设表t中现在有10000条记录，我们设计了三个用户并行的会话。</p>
<ul>
<li>会话A先启动事务并查询一次表的总行数；</li>
<li>会话B启动事务，插入一行后记录后，查询表的总行数；</li>
<li>会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。</li>
</ul>
<p>我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。</p>
<p><img src="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 会话A、B、C的执行流程</b>
    </div>
    <br>
</center>



<p>你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。</p>
<p>这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p>
<blockquote>
<p>备注：如果你对MVCC记忆模糊了，可以再回顾下第3篇文章<a href="https://time.geekbang.org/column/article/68963">《事务隔离：为什么你改了我还看不见？》</a>和第8篇文章<a href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>中的相关内容。</p>
</blockquote>
<p>当然，现在这个看上去笨笨的MySQL，在执行count(*)操作的时候还是做了优化的。</p>
<p>你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(<em>)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。*<em>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</em></em></p>
<p>如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p>
<p>你可能还记得在第10篇文章<a href="https://time.geekbang.org/column/article/71173">《 MySQL为什么有时候会选错索引？》</a>中我提到过，索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。<strong>所以，show table status命令显示的行数也不能直接使用。</strong></p>
<p>到这里我们小结一下：</p>
<ul>
<li>MyISAM表虽然count(*)很快，但是不支持事务；</li>
<li>show table status命令虽然返回很快，但是不准确；</li>
<li>InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<p>那么，回到文章开头的问题，如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，我们只能自己计数。</p>
<p>接下来，我们讨论一下，看看自己计数有哪些方法，以及每种方法的优缺点有哪些。</p>
<p>这里，我先和你说一下这些方法的基本思路：你需要自己找一个地方，把操作记录表的行数存起来。</p>
<h1 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h1><p>对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。</p>
<p>你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？</p>
<p>没错，缓存系统可能会丢失更新。</p>
<p>Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。</p>
<p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>
<p>但实际上，<strong>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使Redis正常工作，这个值还是逻辑上不精确的。</strong></p>
<p>你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。</p>
<p>我们是这么定义不精确的：</p>
<ol>
<li>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</li>
<li>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。</li>
</ol>
<p>这两种情况，都是逻辑不一致的。</p>
<p>我们一起来看看这个时序图。</p>
<p><img src="https://static001.geekbang.org/resource/image/39/33/39898af053695dad37227d71ae288e33.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 会话A、B执行时序图</b>
    </div>
    <br>
</center>



<p>图2中，会话A是一个插入交易记录的逻辑，往数据表里插入一行R，然后Redis计数加1；会话B就是查询页面显示时需要的数据。</p>
<p>在图2的这个时序里，在T3时刻会话B来查询的时候，会显示出新插入的R这个记录，但是Redis的计数还没加1。这时候，就会出现我们说的数据不一致。</p>
<p>你一定会说，这是因为我们执行新增记录逻辑时候，是先写数据表，再改Redis计数。而读的时候是先读Redis，再读数据表，这个顺序是相反的。那么，如果保持顺序一样的话，是不是就没问题了？我们现在把会话A的更新顺序换一下，再看看执行结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/5c/db/5c2f786beae1d8917cdc5033b7bf0bdb.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 调整顺序后，会话A、B的执行时序图</b>
    </div>
    <br>
</center>


<p>你会发现，这时候反过来了，会话B在T3时刻查询的时候，Redis计数加了1了，但还查不到新插入的R这一行，也是数据不一致的情况。</p>
<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使Redis正常工作，这个计数值还是逻辑上不精确的。</p>
<h1 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h1><p>根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，<strong>如果我们把这个计数直接放到数据库里单独的一张计数表C中，又会怎么样呢？</strong></p>
<p>首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。</p>
<blockquote>
<p>备注：关于InnoDB的崩溃恢复，你可以再回顾一下第2篇文章<a href="https://time.geekbang.org/column/article/68633">《日志系统：一条SQL更新语句是如何执行的？》</a>中的相关内容。</p>
</blockquote>
<p>然后，我们再看看能不能解决计数不精确的问题。</p>
<p>你会说，这不一样吗？无非就是把图3中对Redis的操作，改成了对计数表C的操作。只要出现图3的这种执行序列，这个问题还是无解的吧？</p>
<p>这个问题还真不是无解的。</p>
<p>我们这篇文章要解决的问题，都是由于InnoDB要支持事务，从而导致InnoDB表不能把count(*)直接存起来，然后查询的时候直接返回形成的。</p>
<p>所谓以子之矛攻子之盾，现在我们就利用“事务”这个特性，把问题解决掉。</p>
<p><img src="https://static001.geekbang.org/resource/image/9e/e3/9e4170e2dfca3524eb5e92adb8647de3.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 会话A、B的执行时序图</b>
    </div>
    <br>
</center>

<p>我们来看下现在的执行结果。虽然会话B的读操作仍然是在T3执行的，但是因为这时候更新事务还没有提交，所以计数值加1这个操作对会话B还不可见。</p>
<p>因此，会话B看到的结果里， 查计数值和“最近100条记录”看到的结果，逻辑上就是一致的。</p>
<h1 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h1><p>在前面文章的评论区，有同学留言问到：在<code>select count(?) from t</code> 这样的查询语句里面，<code>count(*)</code>、<code>count(主键id)</code>、<code>count(字段)</code>和<code>count(1)</code>等不同用法的性能，有哪些差别。今天谈到了count(*)的性能问题，我就借此机会和你详细说明一下这几种用法的性能差别。</p>
<p>需要注意的是，下面的讨论还是基于InnoDB引擎的。</p>
<p>这里，首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p>
<p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p>
<p>至于分析性能差别的时候，你可以记住这么几个原则：</p>
<ol>
<li>server层要什么就给什么；</li>
<li>InnoDB只给必要的值；</li>
<li>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</li>
</ol>
<p>这是什么意思呢？接下来，我们就一个个地来看看。</p>
<p><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</p>
<p><strong>对于count(1)来说</strong>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p>
<p><strong>对于count(字段)来说</strong>：</p>
<ol>
<li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li>
<li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
</ol>
<p>也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</p>
<p><strong>但是count(*)是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加。</p>
<p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(*)来处理，多么简单的优化啊。</p>
<p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(*)了，你直接使用这种用法就可以了。</p>
<p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(<em>)，所以我建议你，尽量使用count(</em>)。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你聊了聊MySQL中获得表行数的两种方法。我们提到了在不同引擎中count(*)的实现方式是不一样的，也分析了用缓存系统来存储计数值存在的问题。</p>
<p>其实，把计数放在Redis里面，不能够保证计数和MySQL表里的数据精确一致的原因，是<strong>这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。</strong>而把计数值也放在MySQL中，就解决了一致性视图的问题。</p>
<p>InnoDB引擎支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。这也是InnoDB引擎备受青睐的原因之一。</p>
<p>最后，又到了今天的思考题时间了。</p>
<p>在刚刚讨论的方案中，我们用了事务来确保计数准确。由于事务可以保证中间结果不被别的事务读到，因此修改计数值和插入新记录的顺序是不影响逻辑结果的。但是，从并发系统性能的角度考虑，你觉得在这个事务序列里，应该先插入操作记录，还是应该先更新计数表呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我给你留的问题是，什么时候使用 <code>alter table t engine=InnoDB</code> 会让一个表占用的空间反而变大。</p>
<p>在这篇文章的评论区里面，大家都提到了一个点，就是这个表，本身就已经没有空洞的了，比如说刚刚做过一次重建表操作。</p>
<p>在DDL期间，如果刚好有外部的DML在执行，这期间可能会引入一些新的空洞。</p>
<p>@飞翔 提到了一个更深刻的机制，是我们在文章中没说的。在重建表的时候，InnoDB不会把整张表占满，每个页留了1&#x2F;16给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。</p>
<p>假如是这么一个过程：</p>
<ol>
<li>将表t重建一次；</li>
<li>插入一部分数据，但是插入的这些数据，用掉了一部分的预留空间；</li>
<li>这种情况下，再重建一次表t，就可能会出现问题中的现象。</li>
</ol>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>15 | 答疑文章（一）：日志和索引相关问题</title>
    <url>/posts/39974b20.html</url>
    <content><![CDATA[<p>到目前为止，我已经收集了47个问题，很难通过今天这一篇文章全部展开。所以，我就先从中找了几个联系非常紧密的问题，串了起来，希望可以帮你解决关于日志和索引的一些疑惑。而其他问题，我们就留着后面慢慢展开吧。</p>
<span id="more"></span>

<h1 id="日志相关问题"><a href="#日志相关问题" class="headerlink" title="日志相关问题"></a>日志相关问题</h1><p>我在第2篇文章<a href="https://time.geekbang.org/column/article/68633">《日志系统：一条SQL更新语句是如何执行的？》</a>中，和你讲到binlog（归档日志）和redo log（重做日志）配合崩溃恢复的时候，用的是反证法，说明了如果没有两阶段提交，会导致MySQL出现主备数据不一致等问题。</p>
<p>在这篇文章下面，很多同学在问，在两阶段提交的不同瞬间，MySQL如果发生异常重启，是怎么保证数据完整性的？</p>
<p>现在，我们就从这个问题开始吧。</p>
<p>我再放一次两阶段提交的图，方便你学习下面的内容。</p>
<p><img src="https://static001.geekbang.org/resource/image/ee/2a/ee9af616e05e4b853eba27048351f62a.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 两阶段提交示意图</b>
    </div>
    <br>
</center>


<p>这里，我要先和你解释一个误会式的问题。有同学在评论区问到，这个图不是一个update语句的执行流程吗，怎么还会调用commit语句？</p>
<p>他产生这个疑问的原因，是把<strong>两个“commit”的概念</strong>混淆了：</p>
<ul>
<li>他说的“commit语句”，是指MySQL语法中，用于提交一个事务的命令。一般跟begin&#x2F;start transaction 配对使用。</li>
<li>而我们图中用到的这个“commit步骤”，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，这个事务就提交完成了。</li>
<li>“commit语句”执行的时候，会包含“commit 步骤”。</li>
</ul>
<p>而我们这个例子里面，没有显式地开启事务，因此这个update语句自己就是一个事务，在执行完成后提交事务时，就会用到这个“commit步骤“。</p>
<p>接下来，我们就一起分析一下<strong>在两阶段提交的不同时刻，MySQL异常重启会出现什么现象。</strong></p>
<p>如果在图中时刻A的地方，也就是写入redo log 处于prepare阶段之后、写binlog之前，发生了崩溃（crash），由于此时binlog还没写，redo log也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog还没写，所以也不会传到备库。到这里，大家都可以理解。</p>
<p>大家出现问题的地方，主要集中在时刻B，也就是binlog写完，redo log还没commit前发生crash，那崩溃恢复的时候MySQL会怎么处理？</p>
<p>我们先来看一下崩溃恢复时的判断规则。</p>
<ol>
<li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；</li>
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li>
</ol>
<p>这里，时刻B发生crash对应的就是2(a)的情况，崩溃恢复过程中事务会被提交。</p>
<p>现在，我们继续延展一下这个问题。</p>
<h2 id="追问1：MySQL怎么知道binlog是完整的"><a href="#追问1：MySQL怎么知道binlog是完整的" class="headerlink" title="追问1：MySQL怎么知道binlog是完整的?"></a>追问1：MySQL怎么知道binlog是完整的?</h2><p>回答：一个事务的binlog是有完整格式的：</p>
<ul>
<li>statement格式的binlog，最后会有COMMIT；</li>
<li>row格式的binlog，最后会有一个XID event。</li>
</ul>
<p>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容的正确性。对于binlog日志由于磁盘原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现。所以，MySQL还是有办法验证事务binlog的完整性的。</p>
<h2 id="追问2：redo-log-和-binlog是怎么关联起来的"><a href="#追问2：redo-log-和-binlog是怎么关联起来的" class="headerlink" title="追问2：redo log 和 binlog是怎么关联起来的?"></a>追问2：redo log 和 binlog是怎么关联起来的?</h2><p>回答：它们有一个共同的数据字段，叫XID。崩溃恢复的时候，会按顺序扫描redo log：</p>
<ul>
<li>如果碰到既有prepare、又有commit的redo log，就直接提交；</li>
<li>如果碰到只有parepare、而没有commit的redo log，就拿着XID去binlog找对应的事务。</li>
</ul>
<h2 id="追问3：处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计"><a href="#追问3：处于prepare阶段的redo-log加上完整binlog，重启就能恢复，MySQL为什么要这么设计" class="headerlink" title="追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?"></a>追问3：处于prepare阶段的redo log加上完整binlog，重启就能恢复，MySQL为什么要这么设计?</h2><p>回答：其实，这个问题还是跟我们在反证法中说到的数据与备份的一致性有关。在时刻B，也就是binlog写完以后MySQL发生崩溃，这时候binlog已经写入了，之后就会被从库（或者用这个binlog恢复出来的库）使用。</p>
<p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<h2 id="追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo-log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>追问4：如果这样的话，为什么还要两阶段提交呢？干脆先redo log写完，再写binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h2><p>回答：其实，两阶段提交是经典的分布式系统问题，并不是MySQL独有的。</p>
<p>如果必须要举一个场景，来说明这么做的必要性的话，那就是事务的持久性问题。</p>
<p>对于InnoDB引擎来说，如果redo log提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果redo log直接提交，然后binlog写入的时候失败，InnoDB又回滚不了，数据和binlog日志又不一致了。</p>
<p>两阶段提交就是为了给所有人一个机会，当每个人都说“我ok”的时候，再一起提交。</p>
<h2 id="追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？"></a>追问5：不引入两个日志，也就没有两阶段提交的必要了。只用binlog来支持崩溃恢复，又能支持归档，不就可以了？</h2><p>回答：这位同学的意思是，只保留binlog，然后可以把提交流程改成这样：… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，是不是也可以提供崩溃恢复的能力？</p>
<p>答案是不可以。</p>
<p>如果说<strong>历史原因</strong>的话，那就是InnoDB并不是MySQL的原生存储引擎。MySQL的原生引擎是MyISAM，设计之初就有没有支持崩溃恢复。</p>
<p>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。</p>
<p>InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那就用InnoDB原有的redo log好了。</p>
<p>而如果说<strong>实现上的原因</strong>的话，就有很多了。就按照问题中说的，只用binlog来实现崩溃恢复的流程，我画了一张示意图，这里就没有redo log了。</p>
<p><img src="https://static001.geekbang.org/resource/image/eb/63/eb838b87e9c20fa00aca50ef154f2a63.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 只用binlog支持崩溃恢复</b>
    </div>
    <br>
</center>

<p>这样的流程下，binlog还是不能支持崩溃恢复的。我说一个不支持的点吧：binlog没有能力恢复“数据页”。</p>
<p>如果在图中标的位置，也就是binlog2写完了，但是整个事务还没有commit的时候，MySQL发生了crash。</p>
<p>重启后，引擎内部事务2会回滚，然后应用binlog2可以补回来；但是对于事务1来说，系统已经认为提交完成了，不会再应用一次binlog1。</p>
<p>但是，InnoDB引擎使用的是WAL技术，执行事务的时候，写完内存和日志，事务就算完成了。如果之后崩溃，要依赖于日志来恢复数据页。</p>
<p>也就是说在图中这个位置发生崩溃的话，事务1也是可能丢失了的，而且是数据页级的丢失。此时，binlog里面并没有记录数据页的更新细节，是补不回来的。</p>
<p>你如果要说，那我优化一下binlog的内容，让它来记录数据页的更改可以吗？但，这其实就是又做了一个redo log出来。</p>
<p>所以，至少现在的binlog能力，还不能支持崩溃恢复。</p>
<h2 id="追问6：那能不能反过来，只用redo-log，不要binlog？"><a href="#追问6：那能不能反过来，只用redo-log，不要binlog？" class="headerlink" title="追问6：那能不能反过来，只用redo log，不要binlog？"></a>追问6：那能不能反过来，只用redo log，不要binlog？</h2><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把binlog关掉，这样就没有两阶段提交了，但系统依然是crash-safe的。</p>
<p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog都是开着的。因为binlog有着redo log无法替代的功能。</p>
<p>一个是归档。redo log是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log也就起不到归档的作用。</p>
<p>一个就是MySQL系统依赖于binlog。binlog作为MySQL一开始就有的功能，被用在了很多地方。其中，MySQL系统高可用的基础，就是binlog复制。</p>
<p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费MySQL的binlog来更新自己的数据。关掉binlog的话，这些下游系统就没法输入了。</p>
<p>总之，由于现在包括MySQL高可用在内的很多系统机制都依赖于binlog，所以“鸠占鹊巢”redo log还做不到。你看，发展生态是多么重要。</p>
<h2 id="追问7：redo-log一般设置多大？"><a href="#追问7：redo-log一般设置多大？" class="headerlink" title="追问7：redo log一般设置多大？"></a>追问7：redo log一般设置多大？</h2><p>回答：redo log太小的话，会导致很快就被写满，然后不得不强行刷redo log，这样WAL机制的能力就发挥不出来了。</p>
<p>所以，如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧。</p>
<h2 id="追问8：正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？"><a href="#追问8：正常运行中的实例，数据写入后的最终落盘，是从redo-log更新过来的还是从buffer-pool更新过来的呢？" class="headerlink" title="追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？"></a>追问8：正常运行中的实例，数据写入后的最终落盘，是从redo log更新过来的还是从buffer pool更新过来的呢？</h2><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log里面到底是什么”的问题。</p>
<p>实际上，redo log并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由redo log更新过去”的情况。</p>
<ol>
<li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与redo log毫无关系。</li>
<li>在崩溃恢复场景中，InnoDB如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让redo log更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li>
</ol>
<h2 id="追问9：redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？"><a href="#追问9：redo-log-buffer是什么？是先修改内存，还是先写redo-log文件？" class="headerlink" title="追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？"></a>追问9：redo log buffer是什么？是先修改内存，还是先写redo log文件？</h2><p>回答：这两个问题可以一起回答。</p>
<p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没commit的时候就直接写到redo log文件里。</p>
<p>所以，redo log buffer就是一块内存，用来先存redo日志的。也就是说，在执行第一个insert的时候，数据的内存被修改了，redo log buffer也写入了日志。</p>
<p>但是，真正把日志写到redo log文件（文件名是 ib_logfile+数字），是在执行commit语句的时候做的。</p>
<p>（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的IO消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第22篇文章《MySQL有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p>
<p>单独执行一个更新语句的时候，InnoDB会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p>
<p>以上这些问题，就是把大家提过的关于redo log和binlog的问题串起来，做的一次集中回答。如果你还有问题，可以在评论区继续留言补充。</p>
<h1 id="业务设计问题"><a href="#业务设计问题" class="headerlink" title="业务设计问题"></a>业务设计问题</h1><p>接下来，我再和你分享@ithunter 同学在第8篇文章<a href="https://time.geekbang.org/column/article/70562">《</a><a href="https://time.geekbang.org/column/article/70562">事务到底是隔离的还是不隔离的？</a><a href="https://time.geekbang.org/column/article/70562">》</a>的评论区提到的跟索引相关的一个问题。我觉得这个问题挺有趣、也挺实用的，其他同学也可能会碰上这样的场景，在这里解答和分享一下。</p>
<p>问题是这样的（我文字上稍微做了点修改，方便大家理解）：</p>
<blockquote>
<p>业务上有这样的需求，A、B两个用户，如果互相关注，则成为好友。设计上是有两张表，一个是like表，一个是friend表，like表有user_id、liker_id两个字段，我设置为复合唯一索引即uk_user_id_liker_id。语句执行逻辑是这样的：</p>
</blockquote>
<blockquote>
<p>以A关注B为例：<br>第一步，先查询对方有没有关注自己（B有没有关注A）<br>select * from like where user_id &#x3D; B and liker_id &#x3D; A;</p>
</blockquote>
<blockquote>
<p>如果有，则成为好友<br>insert into friend;</p>
</blockquote>
<blockquote>
<p>没有，则只是单向关注关系<br>insert into like;</p>
</blockquote>
<blockquote>
<p>但是如果A、B同时关注对方，会出现不会成为好友的情况。因为上面第1步，双方都没关注对方。第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效。请问这种情况，在MySQL锁层面有没有办法处理？</p>
</blockquote>
<p>首先，我要先赞一下这样的提问方式。虽然极客时间现在的评论区还不能追加评论，但如果大家能够一次留言就把问题讲清楚的话，其实影响也不大。所以，我希望你在留言提问的时候，也能借鉴这种方式。</p>
<p>接下来，我把@ithunter 同学说的表模拟出来，方便我们讨论。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">like</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `liker_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_user_id_liker_id` (`user_id`,`liker_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">  id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `friend_1_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `firned_2_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_friend` (`friend_1_id`,`firned_2_id`)</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>虽然这个题干中，并没有说到friend表的索引结构。但我猜测friend_1_id和friend_2_id也有索引，为便于描述，我给加上唯一索引。</p>
<p>顺便说明一下，“like”是关键字，我一般不建议使用关键字作为库名、表名、字段名或索引名。</p>
<p>我把他的疑问翻译一下，在并发场景下，同时有两个人，设置为关注对方，就可能导致无法成功加为朋友关系。</p>
<p>现在，我用你已经熟悉的时刻顺序表的形式，把这两个事务的执行语句列出来：<br><img src="https://static001.geekbang.org/resource/image/c4/ed/c45063baf1ae521bf5d98b6d7c0e0ced.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 并发“喜欢”逻辑操作顺序</b>
    </div>
    <br>
</center>

<p>由于一开始A和B之间没有关注关系，所以两个事务里面的select语句查出来的结果都是空。</p>
<p>因此，session 1的逻辑就是“既然B没有关注A，那就只插入一个单向关注关系”。session 2也同样是这个逻辑。</p>
<p>这个结果对业务来说就是bug了。因为在业务设定里面，这两个逻辑都执行完成以后，是应该在friend表里面插入一行记录的。</p>
<p>如提问里面说的，“第1步即使使用了排他锁也不行，因为记录不存在，行锁无法生效”。不过，我想到了另外一个方法，来解决这个问题。</p>
<p>首先，要给“like”表增加一个字段，比如叫作 relation_ship，并设为整型，取值1、2、3。</p>
<blockquote>
<p>值是1的时候，表示user_id 关注 liker_id;<br>值是2的时候，表示liker_id 关注 user_id;<br>值是3的时候，表示互相关注。</p>
</blockquote>
<p>然后，当 A关注B的时候，逻辑改成如下所示的样子：</p>
<p>应用代码里面，比较A和B的大小，如果A&lt;B，就执行下面的逻辑</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(A, B, <span class="number">1</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>A <span class="keyword">and</span> liker_id<span class="operator">=</span>B;</span><br><span class="line"><span class="comment">/*代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">  如果是1，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">  如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(A,B);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>如果A&gt;B，则执行下面的逻辑</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(B, A, <span class="number">2</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>B <span class="keyword">and</span> liker_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">/*代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">  如果是2，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">  如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(B,A);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>这个设计里，让“like”表里的数据保证user_id &lt; liker_id，这样不论是A关注B，还是B关注A，在操作“like”表的时候，如果反向的关系已经存在，就会出现行锁冲突。</p>
<p>然后，insert … on duplicate语句，确保了在事务内部，执行了这个SQL语句后，就强行占住了这个行锁，之后的select 判断relation_ship这个逻辑时就确保了是在行锁保护下的读操作。</p>
<p>操作符 “|” 是按位或，连同最后一句insert语句里的ignore，是为了保证重复调用时的幂等性。</p>
<p>这样，即使在双方“同时”执行关注操作，最终数据库里的结果，也是like表里面有一条关于A和B的记录，而且relation_ship的值是3， 并且friend表里面也有了A和B的这条记录。</p>
<p>不知道你会不会吐槽：之前明明还说尽量不要使用唯一索引，结果这个例子一上来我就创建了两个。这里我要再和你说明一下，之前文章我们讨论的，是在“业务开发保证不会插入重复记录”的情况下，着重要解决性能问题的时候，才建议尽量使用普通索引。</p>
<p>而像这个例子里，按照这个设计，业务根本就是保证“我一定会插入重复数据，数据库一定要要有唯一性约束”，这时就没啥好说的了，唯一索引建起来吧。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这是专栏的第一篇答疑文章。</p>
<p>我针对前14篇文章，大家在评论区中的留言，从中摘取了关于日志和索引的相关问题，串成了今天这篇文章。这里我也要再和你说一声，有些我答应在答疑文章中进行扩展的话题，今天这篇文章没来得及扩展，后续我会再找机会为你解答。所以，篇幅所限，评论区见吧。</p>
<p>最后，虽然这篇是答疑文章，但课后问题还是要有的。</p>
<p>我们创建了一个简单的表t，并插入一行，然后对这一行做修改。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">`a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这时候，表t里有唯一的一行数据(1,2)。假设，我现在要执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t <span class="keyword">set</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>你会看到这样的结果：</p>
<p><img src="https://static001.geekbang.org/resource/image/36/70/367b3f299b94353f32f75ea825391170.png"><br>结果显示，匹配(rows matched)了一行，修改(Changed)了0行。</p>
<p>仅从现象上看，MySQL内部在处理这个命令的时候，可以有以下三种选择：</p>
<ol>
<li>更新都是先读后写的，MySQL读出数据，发现a的值本来就是2，不更新，直接返回，执行结束；</li>
<li>MySQL调用了InnoDB引擎提供的“修改为(1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li>
<li>InnoDB认真执行了“把这个值修改成(1,2)”这个操作，该加锁的加锁，该更新的更新。</li>
</ol>
<p>你觉得实际情况会是以上哪种呢？你可否用构造实验的方式，来证明你的结论？进一步地，可以思考一下，MySQL为什么要选择这种策略呢？</p>
<p>你可以把你的验证方法和思考写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，用一个计数表记录一个业务表的总行数，在往业务表插入数据的时候，需要给计数值加1。</p>
<p>逻辑实现上是启动一个事务，执行两个语句：</p>
<ol>
<li>insert into 数据表；</li>
<li>update 计数表，计数值加1。</li>
</ol>
<p>从系统并发能力的角度考虑，怎么安排这两个语句的顺序。</p>
<p>这里，我直接复制 @阿建 的回答过来供你参考：</p>
<blockquote>
<p>并发系统性能的角度考虑，应该先插入操作记录，再更新计数表。<br>知识点在<a href="https://time.geekbang.org/column/article/70215">《行锁功过：怎么减少行锁对性能的影响？》</a><br>因为更新计数表涉及到行锁的竞争，先插入再更新能最大程度地减少事务之间的锁等待，提升并发度。</p>
</blockquote>
<p>评论区有同学说，应该把update计数表放后面，因为这个计数表可能保存了多个业务表的计数值。如果把update计数表放到事务的第一个语句，多个业务表同时插入数据的话，等待时间会更长。</p>
<p>这个答案的结论是对的，但是理解不太正确。即使我们用一个计数表记录多个业务表的行数，也肯定会给表名字段加唯一索引。类似于下面这样的表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `rows_stat` (</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `row_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>在更新计数表的时候，一定会传入where table_name&#x3D;$table_name，使用主键索引，更新加行锁只会锁在一行上。</p>
<p>而在不同业务表插入数据，是更新不同的行，不会有行锁。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@果然如此 同学提了一个好问题，虽然引入事务，避免看到”业务上还没提交的更新”，但是Redis的计数被提前看到了。核心原因还是两个系统，不支持一致性视图；<br>@ 帆帆帆帆帆帆帆帆 同学的问题提醒了大家，count(id)也是可以走普通索引得到的。</p>
</blockquote>
<h2 id="精选留言"><a href="#精选留言" class="headerlink" title="精选留言"></a>精选留言</h2><p>@萤火虫：林老师的每次更新我都会跟着看 跟着学 已经坚持15节课了 受益良多 只是心里有时会反问自己 底层原理有那么重要吗？ 会用不就行了吗？ 自己不知道该怎么推翻这些想法 加上自己有个不好的习惯 就是容易放弃 希望自己能够坚持到最后。</p>
<p>@作者 回复：</p>
<p>说下我自己的理解。</p>
<p>我在带新人的时候，要求大家在写SQL语句的时候，心里是有数的，知道每个语句执行的结果，以及这些代码会消耗什么资源、如果慢了会慢在哪里、每个语句执行会占用哪些锁等等。</p>
<p>有的新人会问“为什么需要这么麻烦，我执行一下，看看结果对不对，对了就行，不对就改，是不是也可以？”</p>
<p>我说不可以。因为如果这样，我们就会受到很多局限，即使我们定位自己是业务开发人员。</p>
<p>这里我说一个限制：</p>
<p>这会限制基于数据库的业务架构能力。一个语句可以试，一个五个语句的事务分析就要试很多次，一个复杂业务系统的数据库设计，是试不出来的。</p>
<p>原理可以帮我们剪枝，排除掉那些理论上明显错误的方案，这样才有精力真的去试那些有限的、可能正确的方案。</p>
<p>我们不需要100%精通MySQL(我自己离这个目标也相去甚远），但是只要多知道一些原理，就能多剪一些枝，架构设计就能少一些错误选项的干扰，设计出来的项目架构正确的可能性更高。</p>
<p>我自己特别喜欢这个剪枝的过程和感觉，他表示我用以前学习的时间，来节省了现在工作的时间。</p>
<p>当然，“原理”是一个很大的概念，有的原理更接近实战，有的远一些。这个专栏我挑的是跟平时使用相关的原理，以便大家可以有机会边学边用。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>19 | 为什么我只查一行的语句，也执行这么慢</title>
    <url>/posts/20b6c3f5.html</url>
    <content><![CDATA[<p>一般情况下，如果我跟你说查询性能优化，你首先会想到一些复杂的语句，想到查询需要返回大量的数据。但有些情况下，“查一行”，也会执行得特别慢。今天，我就跟你聊聊这个有趣的话题，看看什么情况下，会出现这个现象。</p>
<span id="more"></span>

<p>需要说明的是，如果MySQL数据库本身就有很大的压力，导致数据库服务器CPU占用率很高或ioutil（IO利用率）很高，这种情况下所有语句的执行都有可能变慢，不属于我们今天的讨论范围。</p>
<p>为了便于描述，我还是构造一个表，基于这个表来说明今天的问题。这个表有两个字段id和c，并且我在里面插入了10万行记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>接下来，我会用几个不同的场景来举例，有些是前面的文章中我们已经介绍过的知识点，你看看能不能一眼看穿，来检验一下吧。</p>
<h1 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h1><p>如图1所示，在表t执行下面的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果长时间不返回。</p>
<p><img src="https://static001.geekbang.org/resource/image/87/2a/8707b79d5ed906950749f5266014f22a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 查询长时间不返回</b>
    </div>
    <br>
</center>

<p>一般碰到这种情况的话，大概率是表t被锁住了。接下来分析原因的时候，一般都是首先执行一下show processlist命令，看看当前语句处于什么状态。</p>
<p>然后我们再针对每种状态，去分析它们产生的原因、如何复现，以及如何处理。</p>
<h2 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h2><p>如图2所示，就是使用show processlist命令查看Waiting for table metadata lock的示意图。</p>
<p><img src="https://static001.geekbang.org/resource/image/50/28/5008d7e9e22be88a9c80916df4f4b328.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 Waiting for table metadata lock状态示意图</b>
    </div>
    <br>
</center>

<p>出现<strong>这个状态表示的是，现在有一个线程正在表t上请求或者持有MDL写锁，把select语句堵住了。</strong></p>
<p>在第6篇文章<a href="https://time.geekbang.org/column/article/69862">《全局锁和表锁 ：给表加个字段怎么有这么多阻碍？》</a>中，我给你介绍过一种复现方法。但需要说明的是，那个复现过程是基于MySQL 5.6版本的。而MySQL 5.7版本修改了MDL的加锁策略，所以就不能复现这个场景了。</p>
<p>不过，在MySQL 5.7版本下复现这个场景，也很容易。如图3所示，我给出了简单的复现步骤。<br><img src="https://static001.geekbang.org/resource/image/74/ca/742249a31b83f4858c51bfe106a5daca.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 MySQL 5.7中Waiting for table metadata lock的复现步骤</b>
    </div>
    <br>
</center>

<p>session A 通过lock table命令持有表t的MDL写锁，而session B的查询需要获取MDL读锁。所以，session B进入等待状态。</p>
<p>这类问题的处理方式，就是找到谁持有MDL写锁，然后把它kill掉。</p>
<p>但是，由于在show processlist的结果里面，session A的Command列是“Sleep”，导致查找起来很不方便。不过有了performance_schema和sys系统库以后，就方便多了。（MySQL启动时需要设置performance_schema&#x3D;on，相比于设置为off会有10%左右的性能损失)</p>
<p>通过查询sys.schema_table_lock_waits这张表，我们就可以直接找出造成阻塞的process id，把这个连接用kill 命令断开即可。</p>
<p><img src="https://static001.geekbang.org/resource/image/74/01/74fb24ba3826e3831eeeff1670990c01.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 查获加表锁的线程id</b>
    </div>
    <br>
</center>

<h2 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h2><p>接下来，我给你举另外一种查询被堵住的情况。</p>
<p>我在表t上，执行下面的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这里，我先卖个关子。</p>
<p>你可以看一下图5。我查出来这个线程的状态是Waiting for table flush，你可以设想一下这是什么原因。<br><img src="https://static001.geekbang.org/resource/image/2d/24/2d8250398bc7f8f7dce8b6b1923c3724.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 Waiting for table flush状态示意图</b>
    </div>
    <br>
</center>

<p>这个状态表示的是，现在有一个线程正要对表t做flush操作。MySQL里面对表做flush操作的用法，一般有以下两个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>

<p>这两个flush语句，如果指定表t的话，代表的是只关闭表t；如果没有指定具体的表名，则表示关闭MySQL里所有打开的表。</p>
<p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>
<p>所以，出现Waiting for table flush状态的可能情况是：有一个flush tables命令被别的语句堵住了，然后它又堵住了我们的select语句。</p>
<p>现在，我们一起来复现一下这种情况，<strong>复现步骤</strong>如图6所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/2b/9c/2bbc77cfdb118b0d9ef3fdd679d0a69c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 Waiting for table flush的复现步骤</b>
    </div>
    <br>
</center>

<p>在session A中，我故意每行都调用一次sleep(1)，这样这个语句默认要执行10万秒，在这期间表t一直是被session A“打开”着。然后，session B的flush tables t命令再要去关闭表t，就需要等session A的查询结束。这样，session C要再次查询的话，就会被flush 命令堵住了。</p>
<p>图7是这个复现步骤的show processlist结果。这个例子的排查也很简单，你看到这个show processlist的结果，肯定就知道应该怎么做了。</p>
<p><img src="https://static001.geekbang.org/resource/image/39/7e/398407014180be4146c2d088fc07357e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 7 Waiting for table flush的show processlist 结果</b>
    </div>
    <br>
</center>

<h2 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h2><p>现在，经过了表级锁的考验，我们的select 语句终于来到引擎里了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>上面这条语句的用法你也很熟悉了，我们在第8篇<a href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>文章介绍当前读时提到过。</p>
<p>由于访问id&#x3D;1这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的select语句就会被堵住。</p>
<p>复现步骤和现场如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/3e/75/3e68326b967701c59770612183277475.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 8 行锁复现</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/3c/8f/3c266e23fc307283aa94923ecbbc738f.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 9 行锁show processlist 现场</b>
    </div>
    <br>
</center>

<p>显然，session A启动了事务，占有写锁，还不提交，是导致session B被堵住的原因。</p>
<p>这个问题并不难分析，但问题是怎么查出是谁占着这个写锁。如果你用的是MySQL 5.7版本，可以通过sys.innodb_lock_waits 表查到。</p>
<p>查询方法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>`<span class="string">&#x27;test&#x27;</span>.<span class="string">&#x27;t&#x27;</span>`\G</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/d8/18/d8603aeb4eaad3326699c13c46379118.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图10 通过sys.innodb_lock_waits 查行锁</b>
    </div>
    <br>
</center>

<p>可以看到，这个信息很全，4号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是KILL QUERY 4或KILL 4。</p>
<p>不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止4号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是update语句，这个语句已经是之前执行完成了的，现在执行KILL QUERY，无法让这个事务去掉id&#x3D;1上的行锁。</p>
<p>实际上，KILL 4才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了id&#x3D;1上的行锁。</p>
<h1 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h1><p>经过了重重封“锁”，我们再来看看一些查询慢的例子。</p>
<p>先来看一条你一定知道原因的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">50000</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>由于字段c上没有索引，这个语句只能走id主键顺序扫描，因此需要扫描5万行。</p>
<p>作为确认，你可以看一下慢查询日志。注意，这里为了把所有语句记录到slow log里，我在连接后先执行了 set long_query_time&#x3D;0，将慢查询日志的时间阈值设置为0。</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/3c/d8b2b5f97c60ae4fc4a03c616847503c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图11 全表扫描5万行的slow log</b>
    </div>
    <br>
</center>

<p>Rows_examined显示扫描了50000行。你可能会说，不是很慢呀，11.5毫秒就返回了，我们线上一般都配置超过1秒才算慢查询。但你要记住：<strong>坏查询不一定是慢查询</strong>。我们这个例子里面只有10万行记录，数据量大起来的话，执行时间就线性涨上去了。</p>
<p>扫描行数多，所以执行慢，这个很好理解。</p>
<p>但是接下来，我们再看一个只扫描一行，但是执行很慢的语句。</p>
<p>如图12所示，是这个例子的slow log。可以看到，执行的语句是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p>虽然扫描行数是1，但执行时间却长达800毫秒。</p>
<p><img src="https://static001.geekbang.org/resource/image/66/46/66f26bb885401e8e460451ff6b0c0746.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图12 扫描一行却执行得很慢</b>
    </div>
    <br>
</center>

<p>是不是有点奇怪呢，这些时间都花在哪里了？</p>
<p>如果我把这个slow log的截图再往下拉一点，你可以看到下一个语句，select * from t where id&#x3D;1 lock in share mode，执行时扫描行数也是1行，执行时间是0.2毫秒。</p>
<p><img src="https://static001.geekbang.org/resource/image/bd/d2/bde83e269d9fa185b27900c8aa8137d2.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 13 加上lock in share mode的slow log</b>
    </div>
    <br>
</center>

<p>看上去是不是更奇怪了？按理说lock in share mode还要加锁，时间应该更长才对啊。</p>
<p>可能有的同学已经有答案了。如果你还没有答案的话，我再给你一个提示信息，图14是这两个语句的执行输出结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/1f/1c/1fbb84bb392b6bfa93786fe032690b1c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图14 两个语句的输出结果</b>
    </div>
    <br>
</center>

<p>第一个语句的查询结果里c&#x3D;1，带lock in share mode的语句返回的是c&#x3D;1000001。看到这里应该有更多的同学知道原因了。如果你还是没有头绪的话，也别着急。我先跟你说明一下复现步骤，再分析原因。</p>
<p><img src="https://static001.geekbang.org/resource/image/84/ff/84667a3449dc846e393142600ee7a2ff.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图15 复现步骤</b>
    </div>
    <br>
</center>

<p>你看到了，session A先用start transaction with consistent snapshot命令启动了一个事务，之后session B才开始执行update 语句。</p>
<p>session B执行完100万次update语句后，id&#x3D;1这一行处于什么状态呢？你可以从图16中找到答案。</p>
<p><img src="https://static001.geekbang.org/resource/image/46/8c/46bb9f5e27854678bfcaeaf0c3b8a98c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图16 id=1的数据状态</b>
    </div>
    <br>
</center>

<p>session B更新完100万次，生成了100万个回滚日志(undo log)。</p>
<p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id&#x3D;1这个语句，是一致性读，因此需要从1000001开始，依次执行undo log，执行了100万次以后，才将1这个结果返回。</p>
<p>注意，undo log里记录的其实是“把2改成1”，“把3改成2”这样的操作逻辑，画成减1的目的是方便你看图。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我给你举了在一个简单的表上，执行“查一行”，可能会出现的被锁住和执行慢的例子。这其中涉及到了表锁、行锁和一致性读的概念。</p>
<p>在实际使用中，碰到的场景会更复杂。但大同小异，你可以按照我在文章中介绍的定位方法，来定位并解决问题。</p>
<p>最后，我给你留一个问题吧。</p>
<p>我们在举例加锁读的时候，用的是这个语句，select * from t where id&#x3D;1 lock in share mode。由于id上有索引，所以可以直接定位到id&#x3D;1这一行，因此读锁也是只加在了这一行上。</p>
<p>但如果是下面的SQL语句，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？</p>
<p>你可以把你的观点和验证方法写在留言区里，我会在下一篇文章的末尾给出我的参考答案。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>在上一篇文章最后，我留给你的问题是，希望你可以分享一下之前碰到过的、与文章中类似的场景。</p>
<p>@封建的风 提到一个有趣的场景，值得一说。我把他的问题重写一下，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `table_a` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>假设现在表里面，有100万行数据，其中有10万行数据的b的值是’1234567890’， 假设现在执行语句是这么写的:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">where</span> b<span class="operator">=</span><span class="string">&#x27;1234567890abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这时候，MySQL会怎么执行呢？</p>
<p>最理想的情况是，MySQL看到字段b定义的是varchar(10)，那肯定返回空呀。可惜，MySQL并没有这么做。</p>
<p>那要不，就是把’1234567890abcd’拿到索引里面去做匹配，肯定也没能够快速判断出索引树b上并没有这个值，也很快就能返回空结果。</p>
<p>但实际上，MySQL也不是这么做的。</p>
<p>这条SQL语句的执行很慢，流程是这样的：</p>
<ol>
<li>在传给引擎执行的时候，做了字符截断。因为引擎里面这个行只定义了长度是10，所以只截了前10个字节，就是’1234567890’进去做匹配；</li>
<li>这样满足条件的数据有10万行；</li>
<li>因为是select *， 所以要做10万次回表；</li>
<li>但是每次回表以后查出整行，到server层一判断，b的值都不是’1234567890abcd’;</li>
<li>返回结果是空。</li>
</ol>
<p>这个例子，是我们文章内容的一个很好的补充。虽然执行过程中可能经过函数操作，但是最终在拿到结果后，server层还是要做一轮判断的。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>20 | 幻读是什么，幻读有什么问题</title>
    <url>/posts/5de839d7.html</url>
    <content><![CDATA[<p>在上一篇文章最后，我给你留了一个关于加锁规则的问题。今天，我们就从这个问题说起吧。</p>
<span id="more"></span>

<p>为了便于说明问题，这一篇文章，我们就先使用一个小一点儿的表。建表和初始化语句如下（为了便于本期的例子说明，我把上篇文章中用到的表结构做了点儿修改）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>这个表除了主键id外，还有一个索引c，初始化语句在表中插入了6行数据。</p>
<p>上期我留给你的问题是，下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>比较好理解的是，这个语句会命中d&#x3D;5的这一行，对应的主键id&#x3D;5，因此在select 语句执行完成后，id&#x3D;5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。</p>
<p>由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的5行记录上，会不会被加锁呢？</p>
<p>我们知道，InnoDB的默认事务隔离级别是可重复读，所以本文接下来没有特殊说明的部分，都是设定在可重复读隔离级别下。</p>
<h1 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h1><p>现在，我们就来分析一下，如果只在id&#x3D;5这一行加锁，而其他行的不加锁的话，会怎么样。</p>
<p>下面先来看一下这个场景：</p>
<p><img src="https://static001.geekbang.org/resource/image/5b/8b/5bc506e5884d21844126d26bbe6fa68b.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 1 假设只在id=5这一行加行锁</b>
    </div>
    <br>
</center>

<p>可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是select * from t where d&#x3D;5 for update。这个语句的意思你应该很清楚了，查所有d&#x3D;5的行，而且使用的是当前读，并且加上写锁。现在，我们来看一下这三条SQL语句，分别会返回什么结果。</p>
<ol>
<li>Q1只返回id&#x3D;5这一行；</li>
<li>在T2时刻，session B把id&#x3D;0这一行的d值改成了5，因此T3时刻Q2查出来的是id&#x3D;0和id&#x3D;5这两行；</li>
<li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id&#x3D;0、id&#x3D;1和id&#x3D;5的这三行。</li>
</ol>
<p>其中，Q3读到id&#x3D;1这一行的现象，被称为“幻读”。也就是说，幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p>这里，我需要对“幻读”做一个说明：</p>
<ol>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
<li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</li>
</ol>
<p>如果只从第8篇文章<a href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>我们学到的事务可见性规则来分析的话，上面这三条SQL语句的返回结果都没有问题。</p>
<p>因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。</p>
<p>但是，这是不是真的没问题呢？</p>
<p>不，这里还真就有问题。</p>
<h1 id="幻读有什么问题？"><a href="#幻读有什么问题？" class="headerlink" title="幻读有什么问题？"></a>幻读有什么问题？</h1><p><strong>首先是语义上的。</strong>session A在T1时刻就声明了，“我要把所有d&#x3D;5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</p>
<p>如果现在这样看感觉还不明显的话，我再往session B和session C里面分别加一条SQL语句，你再看看会出现什么现象。</p>
<p><img src="https://static001.geekbang.org/resource/image/7a/07/7a9ffa90ac3cc78db6a51ff9b9075607.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 2 假设只在id=5这一行加行锁--语义被破坏</b>
    </div>
    <br>
</center>

<p>session B的第二条语句update t set c&#x3D;5 where id&#x3D;0，语义是“我把id&#x3D;0、d&#x3D;5这一行的c值，改成了5”。</p>
<p>由于在T1时刻，session A 还只是给id&#x3D;5这一行加了行锁， 并没有给id&#x3D;0这行加上锁。因此，session B在T2时刻，是可以执行这两条update语句的。这样，就破坏了 session A 里Q1语句要锁住所有d&#x3D;5的行的加锁声明。</p>
<p>session C也是一样的道理，对id&#x3D;1这一行的修改，也是破坏了Q1的加锁声明。</p>
<p><strong>其次，是数据一致性的问题。</strong></p>
<p>我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p>
<p>为了说明这个问题，我给session A在T1时刻再加一个更新语句，即：update t set d&#x3D;100 where d&#x3D;5。</p>
<p><img src="https://static001.geekbang.org/resource/image/dc/92/dcea7845ff0bdbee2622bf3c67d31d92.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 3 假设只在id=5这一行加行锁--数据一致性问题</b>
    </div>
    <br>
</center>

<p>update的加锁语义和select …for update 是一致的，所以这时候加上这条update语句也很合理。session A声明说“要给d&#x3D;5的语句加上锁”，就是为了要更新数据，新加的这条update语句就是把它认为加上了锁的这一行的d值修改成了100。</p>
<p>现在，我们来分析一下图3执行完成后，数据库里会是什么结果。</p>
<ol>
<li>经过T1时刻，id&#x3D;5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li>
<li>经过T2时刻，id&#x3D;0这一行变成(0,5,5);</li>
<li>经过T4时刻，表里面多了一行(1,5,5);</li>
<li>其他行跟这个执行序列无关，保持不变。</li>
</ol>
<p>这样看，这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。</p>
<ol>
<li>T2时刻，session B事务提交，写入了两条语句；</li>
<li>T4时刻，session C事务提交，写入了两条语句；</li>
<li>T6时刻，session A事务提交，写入了update t set d&#x3D;100 where d&#x3D;5 这条语句。</li>
</ol>
<p>我统一放到一起的话，就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure>

<p>好，你应该看出问题了。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。</p>
<p>也就是说，id&#x3D;0和id&#x3D;1这两行，发生了数据不一致。这个问题很严重，是不行的。</p>
<p>到这里，我们再回顾一下，<strong>这个数据不一致到底是怎么引入的？</strong></p>
<p>我们分析一下可以知道，这是我们假设“select * from t where d&#x3D;5 for update这条语句只给d&#x3D;5这一行，也就是id&#x3D;5的这一行加锁”导致的。</p>
<p>所以我们认为，上面的设定不合理，要改。</p>
<p>那怎么改呢？我们把扫描过程中碰到的行，也都加上写锁，再来看看执行效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/34/47/34ad6478281709da833856084a1e3447.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 4 假设扫描到的行都被加上了行锁</b>
    </div>
    <br>
</center>

<p>由于session A把所有的行都加了写锁，所以session B在执行第一个update语句的时候就被锁住了。需要等到T6时刻session A提交以后，session B才能继续执行。</p>
<p>这样对于id&#x3D;0这一行，在数据库里的最终结果还是 (0,5,5)。在binlog里面，执行序列是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，按照日志顺序执行，id&#x3D;0这一行的最终结果也是(0,5,5)。所以，id&#x3D;0这一行的问题解决了。</p>
<p>但同时你也可以看到，id&#x3D;1这一行，在数据库里面的结果是(1,5,5)，而根据binlog的执行结果是(1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了id&#x3D;1这一行的插入和更新呢？</p>
<p>原因很简单。在T3时刻，我们给所有行加锁的时候，id&#x3D;1这一行还不存在，不存在也就加不上锁。</p>
<p><strong>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，</strong> 这也是为什么“幻读”会被单独拿出来解决的原因。</p>
<p>到这里，其实我们刚说明完文章的标题 ：幻读的定义和幻读有什么问题。</p>
<p>接下来，我们再看看InnoDB怎么解决幻读的问题。</p>
<h1 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h1><p>现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</p>
<p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</p>
<p><img src="https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 5 表t主键索引上的行锁和间隙锁</b>
    </div>
    <br>
</center>

<p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p>
<p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p>
<p>现在你知道了，数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p>
<p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p>
<p><img src="https://static001.geekbang.org/resource/image/c4/51/c435c765556c0f3735a6eda0779ff151.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 两种行锁间的冲突关系</b>
    </div>
    <br>
</center>

<p>也就是说，跟行锁有冲突关系的是“另外一个行锁”。</p>
<p>但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong> 间隙锁之间都不存在冲突关系。</p>
<p>这句话不太好理解，我给你举个例子：</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/98/7c37732d936650f1cda7dbf27daf7498.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 间隙锁之间不互锁</b>
    </div>
    <br>
</center>

<p>这里session B并不会被堵住。因为表t里并没有c&#x3D;7这个记录，因此session A加的是间隙锁(5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
<p>间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。也就是说，我们的表t初始化以后，如果用select * from t for update要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p>
<blockquote>
<p>备注：这篇文章中，如果没有特别说明，我们把间隙锁记为开区间，把next-key lock记为前开后闭区间。</p>
</blockquote>
<p>你可能会问说，这个suprenum从哪儿来的呢？</p>
<p>这是因为+∞是开区间。实现上，InnoDB给每个索引加了一个不存在的最大值suprenum，这样才符合我们前面说的“都是前开后闭区间”。</p>
<p><strong>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。</strong></p>
<p>在前面的文章中，就有同学提到了这个问题。我把他的问题转述一下，对应到我们这个例子的表来说，业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span>N <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果行不存在*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(N,N,N);</span><br><span class="line"><span class="comment">/*如果行存在*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span>N <span class="keyword">set</span> id<span class="operator">=</span>N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>可能你会说，这个不是insert … on duplicate key update 就能解决吗？但其实在有多个唯一键的时候，这个方法是不能满足这位提问同学的需求的。至于为什么，我会在后面的文章中再展开说明。</p>
<p>现在，我们就只讨论这个逻辑。</p>
<p>这个同学碰到的现象是，这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？</p>
<p>这里，我用两个session来模拟并发，并假设N&#x3D;9。</p>
<p><img src="https://static001.geekbang.org/resource/image/df/be/df37bf0bb9f85ea59f0540e24eb6bcbe.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 间隙锁导致的死锁</b>
    </div>
    <br>
</center>

<p>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p>
<ol>
<li>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁(5,10);</li>
<li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li>
<li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li>
</ol>
<p>至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</p>
<p>你现在知道了，<strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</strong>。其实，这还只是一个简单的例子，在下一篇文章中我们还会碰到更多、更复杂的例子。</p>
<p>你可能会说，为了解决幻读的问题，我们引入了这么一大串内容，有没有更简单一点的处理方法呢。</p>
<p>我在文章一开始就说过，如果没有特别说明，今天和你分析的问题都是在可重复读隔离级别下的，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。</p>
<p>前面文章的评论区有同学留言说，他们公司就使用的是读提交隔离级别加binlog_format&#x3D;row的组合。他曾问他们公司的DBA说，你为什么要这么配置。DBA直接答复说，因为大家都这么用呀。</p>
<p>所以，这个同学在评论区就问说，这个配置到底合不合理。</p>
<p>关于这个问题本身的答案是，如果读提交隔离级别够用，也就是说，业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p>
<p>但其实我想说的是，配置是否合理，跟业务场景有关，需要具体问题具体分析。</p>
<p>但是，如果DBA认为之所以这么用的原因是“大家都这么用”，那就有问题了，或者说，迟早会出问题。</p>
<p>比如说，大家都用读提交，可是逻辑备份的时候，mysqldump为什么要把备份线程设置成可重复读呢？（这个我在前面的文章中已经解释过了，你可以再回顾下第6篇文章<a href="https://time.geekbang.org/column/article/69862">《全局锁和表锁 ：给表加个字段怎么有这么多阻碍？》</a>的内容）</p>
<p>然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题？</p>
<p>进一步地，这两个不同的隔离级别现象有什么不一样的，关于我们的业务，“用读提交就够了”这个结论是怎么得到的？</p>
<p>如果业务开发和运维团队这些问题都没有弄清楚，那么“没问题”这个结论，本身就是有问题的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我们从上一篇文章的课后问题说起，提到了全表扫描的加锁方式。我们发现即使给所有的行都加上行锁，仍然无法解决幻读问题，因此引入了间隙锁的概念。</p>
<p>我碰到过很多对数据库有一定了解的业务开发人员，他们在设计数据表结构和业务SQL语句的时候，对行锁有很准确的认识，但却很少考虑到间隙锁。最后的结果，就是生产库上会经常出现由于间隙锁导致的死锁现象。</p>
<p>行锁确实比较直观，判断规则也相对简单，间隙锁的引入会影响系统的并发度，也增加了锁分析的复杂度，但也有章可循。下一篇文章，我就会为你讲解InnoDB的加锁规则，帮你理顺这其中的“章法”。</p>
<p>作为对下一篇文章的预习，我给你留下一个思考题。</p>
<p><img src="https://static001.geekbang.org/resource/image/0d/3d/0d796060073668ca169166a8903fbf3d.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 事务进入锁等待状态</b>
    </div>
    <br>
</center>

<p>如果你之前没有了解过本篇文章的相关内容，一定觉得这三个语句简直是风马牛不相及。但实际上，这里session B和session C的insert 语句都会进入锁等待状态。</p>
<p>你可以试着分析一下，出现这种情况的原因是什么？</p>
<p>这里需要说明的是，这其实是我在下一篇文章介绍加锁规则后才能回答的问题，是留给你作为预习的，其中session C被锁住这个分析是有点难度的。如果你没有分析出来，也不要气馁，我会在下一篇文章和你详细说明。</p>
<p>你也可以说说，你的线上MySQL配置的是什么隔离级别，为什么会这么配置？你有没有碰到什么场景，是必须使用可重复读隔离级别的呢？</p>
<p>你可以把你的碰到的场景和分析写在留言区里，我会在下一篇文章选取有趣的评论跟大家一起分享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我们在本文的开头回答了上期问题。有同学的回答中还说明了读提交隔离级别下，在语句执行完成后，是只有行锁的。而且语句执行完成后，InnoDB就会把不满足条件的行行锁去掉。</p>
<p>当然了，c&#x3D;5这一行的行锁，还是会等到commit的时候才释放的。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@薛畅 、@张永志同学给出了正确答案。而且提到了在读提交隔离级别下，是只有行锁的。<br>@帆帆帆帆帆帆帆帆、@欧阳成 对上期的例子做了验证，需要说明一下，需要在启动配置里面增加performance_schema&#x3D;on，才能用上这个功能，performance_schema库里的表才有数据。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>18 | 为什么这些SQL语句逻辑相同，性能却差异巨大</title>
    <url>/posts/9b95946f.html</url>
    <content><![CDATA[<p>在MySQL中，有很多看上去逻辑相同，但性能却差异巨大的SQL语句。对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大。</p>
<span id="more"></span>

<p>我今天挑选了三个这样的案例和你分享。希望再遇到相似的问题时，你可以做到举一反三、快速解决问题。</p>
<h1 id="案例一：条件字段函数操作"><a href="#案例一：条件字段函数操作" class="headerlink" title="案例一：条件字段函数操作"></a>案例一：条件字段函数操作</h1><p>假设你现在维护了一个交易系统，其中交易记录表tradelog包含交易流水号（tradeid）、交易员id（operator）、交易时间（t_modified）等字段。为了便于描述，我们先忽略其他字段。这个表的建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p>假设，现在已经记录了从2016年初到2018年底的所有数据，运营部门有一个需求是，要统计发生在所有年份中7月份的交易记录总数。这个逻辑看上去并不复杂，你的SQL语句可能会这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>由于t_modified字段上有索引，于是你就很放心地在生产库中执行了这条语句，但却发现执行了特别久，才返回了结果。</p>
<p>如果你问DBA同事为什么会出现这样的情况，他大概会告诉你：如果对字段做了函数计算，就用不上索引了，这是MySQL的规定。</p>
<p>现在你已经学过了InnoDB的索引结构了，可以再追问一句为什么？为什么条件是where t_modified&#x3D;’2018-7-1’的时候可以用上索引，而改成where month(t_modified)&#x3D;7的时候就不行了？</p>
<p>下面是这个t_modified索引的示意图。方框上面的数字就是month()函数对应的值。</p>
<p><img src="https://static001.geekbang.org/resource/image/3e/86/3e30d9a5e67f711f5af2e2599e800286.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 t_modified索引示意图</b>
    </div>
    <br>
</center>

<p>如果你的SQL语句条件用的是where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。</p>
<p>实际上，B+树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。</p>
<p>但是，如果计算month()函数的话，你会看到传入7的时候，在树的第一层就不知道该怎么办了。</p>
<p>也就是说，<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>需要注意的是，优化器并不是要放弃使用这个索引。</p>
<p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引t_modified，优化器对比索引大小后发现，索引t_modified更小，遍历这个索引比遍历主键索引来得更快。因此最终还是会选择索引t_modified。</p>
<p>接下来，我们使用explain命令，查看一下这条SQL语句的执行结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/27/55/27c2f5ff3549b18ba37a28f4919f3655.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 explain 结果</b>
    </div>
    <br>
</center>

<p>key&#x3D;”t_modified”表示的是，使用了t_modified这个索引；我在测试表数据中插入了10万行数据，rows&#x3D;100335，说明这条语句扫描了整个索引的所有值；Extra字段的Using index，表示的是使用了覆盖索引。</p>
<p>也就是说，由于在t_modified字段加了month()函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把SQL语句改成基于字段本身的范围查询。按照下面这个写法，优化器就能按照我们预期的，用上t_modified索引的快速定位能力了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">or</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;</span><span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当然，如果你的系统上线时间更早，或者后面又插入了之后年份的数据的话，你就需要再把其他年份补齐。</p>
<p>到这里我给你说明了，由于加了month()函数操作，MySQL无法再使用索引快速定位功能，而只能使用全索引扫描。</p>
<p>不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于select * from tradelog where id + 1 &#x3D; 10000这个SQL语句，这个加1操作并不会改变有序性，但是MySQL优化器还是不能用id索引快速定位到9999这一行。所以，需要你在写SQL语句的时候，手动改写成 where id &#x3D; 10000 -1才可以。</p>
<h1 id="案例二：隐式类型转换"><a href="#案例二：隐式类型转换" class="headerlink" title="案例二：隐式类型转换"></a>案例二：隐式类型转换</h1><p>接下来我再跟你说一说，另一个经常让程序员掉坑里的例子。</p>
<p>我们一起看一下这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>交易编号tradeid这个字段上，本来就有索引，但是explain的结果却显示，这条语句需要走全表扫描。你可能也发现了，tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。</p>
<p>那么，现在这里就有两个问题：</p>
<ol>
<li>数据类型转换的规则是什么？</li>
<li>为什么有数据类型转换，就需要走全索引扫描？</li>
</ol>
<p>先来看第一个问题，你可能会说，数据库里面类型这么多，这种数据类型转换规则更多，我记不住，应该怎么办呢？</p>
<p>这里有一个简单的方法，看 select “10” &gt; 9的结果：</p>
<ol>
<li>如果规则是“将字符串转成数字”，那么就是做数字比较，结果应该是1；</li>
<li>如果规则是“将数字转成字符串”，那么就是做字符串比较，结果应该是0。</li>
</ol>
<p>验证结果如图3所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/2b/14/2b67fc38f1651e2622fe21d49950b214.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 MySQL中字符串和数字转换的效果示意图</b>
    </div>
    <br>
</center>

<p>从图中可知，select “10” &gt; 9返回的是1，所以你就能确认MySQL里的转换规则了：在MySQL中，字符串和数字做比较的话，是将字符串转换成数字。</p>
<p>这时，你再看这个全表扫描的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>就知道对于优化器来说，这个语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<p>现在，我留给你一个小问题，id的类型是int，如果执行下面这个语句，是否会导致全表扫描呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id<span class="operator">=</span>&quot;83126&quot;;</span><br></pre></td></tr></table></figure>

<p>你可以先自己分析一下，再到数据库里面去验证确认。</p>
<p>接下来，我们再来看一个稍微复杂点的例子。</p>
<h1 id="案例三：隐式字符编码转换"><a href="#案例三：隐式字符编码转换" class="headerlink" title="案例三：隐式字符编码转换"></a>案例三：隐式字符编码转换</h1><p>假设系统里还有另外一个表trade_detail，用于记录交易的操作细节。为了便于量化分析和复现，我往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这时候，如果要查询id&#x3D;2的交易的所有操作步骤信息，SQL语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>; <span class="comment">/*语句Q1*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/ad/22/adfe464af1d15f3261b710a806c0fa22.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 语句Q1的explain 结果</b>
    </div>
    <br>
</center>

<p>我们一起来看下这个结果：</p>
<ol>
<li>第一行显示优化器会先在交易记录表tradelog上查到id&#x3D;2的行，这个步骤用上了主键索引，rows&#x3D;1表示只扫描一行；</li>
<li>第二行key&#x3D;NULL，表示没有用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li>
</ol>
<p>在这个执行计划里，是从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，我们把tradelog称为驱动表，把trade_detail称为被驱动表，把tradeid称为关联字段。</p>
<p>接下来，我们看下这个explain结果表示的执行流程：</p>
<p><img src="https://static001.geekbang.org/resource/image/82/a9/8289c184c8529acea0269a7460dc62a9.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 语句Q1的执行过程</b>
    </div>
    <br>
</center>

<p>图中：</p>
<ul>
<li>第1步，是根据id在tradelog表里找到L2这一行；</li>
<li>第2步，是从L2中取出tradeid字段的值；</li>
<li>第3步，是根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key&#x3D;NULL表示的就是，这个过程是通过遍历主键索引的方式，一个一个地判断tradeid的值是否匹配。</li>
</ul>
<p>进行到这里，你会发现第3步不符合我们的预期。因为表trade_detail里tradeid字段上是有索引的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但，这里并没有。</p>
<p>如果你去问DBA同学，他们可能会告诉你，因为这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。这个回答，也是通常你搜索这个问题时会得到的答案。</p>
<p>但是你应该再追问一下，为什么字符集不同就用不上索引呢？</p>
<p>我们说问题是出在执行步骤的第3步，如果单独把这一步改成SQL语句的话，那就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid<span class="operator">=</span>$L2.tradeid.value;</span><br></pre></td></tr></table></figure>

<p>其中，$L2.tradeid.value的字符集是utf8mb4。</p>
<p>参照前面的两个例子，你肯定就想到了，字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。</p>
<blockquote>
<p>这个设定很好理解，utf8mb4是utf8的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</p>
</blockquote>
<p>因此， 在执行上面这个语句的时候，需要将被驱动数据表里的字段一个个地转换成utf8mb4，再跟L2做比较。</p>
<p>也就是说，实际上这个语句等同于下面这个写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)<span class="operator">=</span>$L2.tradeid.value;</span><br></pre></td></tr></table></figure>

<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p>
<p>这就再次触发了我们上面说到的原则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<p>到这里，你终于明确了，字符集不同只是条件之一，<strong>连接过程中要求在被驱动表的索引字段上加函数操作</strong>，是直接导致对被驱动表做全表扫描的原因。</p>
<p>作为对比验证，我给你提另外一个需求，“查找trade_detail表里id&#x3D;4的操作，对应的操作者是谁”，再来看下这个语句和它的执行计划。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">select</span> l.operator <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> d.id<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/92/11/92cb498ceb3557e41700fae53ce9bd11.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 explain 结果</b>
    </div>
    <br>
</center>

<p>这个语句里trade_detail 表成了驱动表，但是explain结果的第二行显示，这次的查询操作用上了被驱动表tradelog里的索引(tradeid)，扫描行数是1。</p>
<p>这也是两个tradeid字段的join操作，为什么这次能用上被驱动表的tradeid索引呢？我们来分析一下。</p>
<p>假设驱动表trade_detail里id&#x3D;4的行记为R4，那么在连接的时候（图5的第3步），被驱动表tradelog上执行的就是类似这样的SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog  <span class="keyword">where</span> traideid <span class="operator">=</span>$R4.tradeid.value;</span><br></pre></td></tr></table></figure>

<p>这时候$R4.tradeid.value的字符集是utf8, 按照字符集转换规则，要转成utf8mb4，所以这个过程就被改写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> operator <span class="keyword">from</span> tradelog  <span class="keyword">where</span> traideid <span class="operator">=</span><span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4);</span><br></pre></td></tr></table></figure>

<p>你看，这里的CONVERT函数是加在输入参数上的，这样就可以用上被驱动表的traideid索引。</p>
<p>理解了原理以后，就可以用来指导操作了。如果要优化语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>的执行过程，有两种做法：</p>
<ul>
<li>比较常见的优化方法是，把trade_detail表上的tradeid字段的字符集也改成utf8mb4，这样就没有字符集转换的问题了。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail modify tradeid <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果能够修改字段的字符集的话，是最好不过了。但如果数据量比较大， 或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l , trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span><span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8) <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/aa/d6/aa844a7bf35d330b9ec96fc159331bd6.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 SQL语句优化后的explain结果</b>
    </div>
    <br>
</center>

<p>这里，我主动把 l.tradeid转成utf8，就避免了被驱动表上的字符编码转换，从explain结果可以看到，这次索引走对了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天我给你举了三个例子，其实是在说同一件事儿，即：<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<p>第二个例子是隐式类型转换，第三个例子是隐式字符编码转换，它们都跟第一个例子一样，因为要求在索引字段上做函数操作而导致了全索引扫描。</p>
<p>MySQL的优化器确实有“偷懒”的嫌疑，即使简单地把where id+1&#x3D;1000改写成where id&#x3D;1000-1就能够用上索引快速查找，也不会主动做这个语句重写。</p>
<p>因此，每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习惯。</p>
<p>最后，又到了思考题时间。</p>
<p>今天我留给你的课后问题是，你遇到过别的、类似今天我们提到的性能问题吗？你认为原因是什么，又是怎么解决的呢？</p>
<p>你可以把你经历和分析写在留言区里，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上篇文章的最后，留给你的问题是：我们文章中最后的一个方案是，通过三次limit Y,1 来得到需要的数据，你觉得有没有进一步的优化方法。</p>
<p>这里我给出一种方法，取Y1、Y2和Y3里面最大的一个数，记为M，最小的一个数记为N，然后执行下面这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit N, M<span class="operator">-</span>N<span class="operator">+</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>再加上取整个表总行数的C行，这个方案的扫描行数总共只需要C+M+1行。</p>
<p>当然也可以先取回id值，在应用中确定了三个id值以后，再执行三次where id&#x3D;X的语句也是可以的。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>17 | 如何正确地显示随机消息</title>
    <url>/posts/a6416269.html</url>
    <content><![CDATA[<p>我在上一篇文章，为你讲解完order by语句的几种执行模式后，就想到了之前一个做英语学习App的朋友碰到过的一个性能问题。今天这篇文章，我就从这个性能问题说起，和你说说MySQL中的另外一种排序需求，希望能够加深你对MySQL排序逻辑的理解。</p>
<span id="more"></span>

<p>这个英语学习App首页有一个随机显示单词的功能，也就是根据每个用户的级别有一个单词表，然后这个用户每次访问首页的时候，都会随机滚动显示三个单词。他们发现随着单词表变大，选单词这个逻辑变得越来越慢，甚至影响到了首页的打开速度。</p>
<p>现在，如果让你来设计这个SQL语句，你会怎么写呢？</p>
<p>为了便于理解，我对这个例子进行了简化：去掉每个级别的用户都有一个对应的单词表这个逻辑，直接就是从一个单词表中随机选出三个单词。这个表的建表语句和初始数据的命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  while i<span class="operator">&lt;</span><span class="number">10000</span> do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(concat(<span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i div <span class="number">1000</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>为了便于量化说明，我在这个表里面插入了10000行记录。接下来，我们就一起看看要随机选择3个单词，有什么方法实现，存在什么问题以及如何改进。</p>
<h1 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h1><p>首先，你会想到用order by rand()来实现这个逻辑。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句的意思很直白，随机排序取前3个。虽然这个SQL语句写法很简单，但执行流程却有点复杂的。</p>
<p>我们先用explain命令来看看这个语句的执行情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 使用explain命令查看语句的执行情况</b>
    </div>
    <br>
</center>

<p>Extra字段显示Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p>
<p>因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序。</p>
<p>这里，你可以先回顾一下<a href="https://time.geekbang.org/column/article/73479">上一篇文章</a>中全字段排序和rowid排序的内容。我把上一篇文章的两个流程图贴过来，方便你复习。</p>
<p><img src="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 全字段排序</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 rowid排序</b>
    </div>
    <br>
</center>

<p>然后，我再问你一个问题，你觉得对于临时内存表的排序来说，它会选择哪一种算法呢？回顾一下上一篇文章的一个结论：<strong>对于InnoDB表来说</strong>，执行全字段排序会减少磁盘访问，因此会被优先选择。</p>
<p>我强调了“InnoDB表”，你肯定想到了，<strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘</strong>。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越少越好了，所以，MySQL这时就会选择rowid排序。</p>
<p>理解了这个算法选择的逻辑，我们再来看看语句的执行流程。同时，通过今天的这个例子，我们来尝试分析一下语句的扫描行数。</p>
<p>这条语句的执行流程是这样的：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是memory引擎，表里有两个字段，第一个字段是double类型，为了后面描述方便，记为字段R，第二个字段是varchar(64)类型，记为字段W。并且，这个表没有建索引。</li>
<li>从words表中，按主键顺序取出所有的word值。对于每一个word值，调用rand()函数生成一个大于0小于1的随机小数，并把这个随机小数和word分别存入临时表的R和W字段中，到此，扫描行数是10000。</li>
<li>现在临时表有10000行数据了，接下来你要在这个没有索引的内存临时表上，按照字段R排序。</li>
<li>初始化 sort_buffer。sort_buffer中有两个字段，一个是double类型，另一个是整型。</li>
<li>从内存临时表中一行一行地取出R值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入sort_buffer中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加10000，变成了20000。</li>
<li>在sort_buffer中根据R的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li>
<li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出word值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了20003。</li>
</ol>
<p>接下来，我们通过慢查询日志（slow log）来验证一下我们分析得到的扫描行数是否正确。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Query_time: <span class="number">0.900376</span>  Lock_time: <span class="number">0.000347</span> Rows_sent: <span class="number">3</span> Rows_examined: <span class="number">20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>其中，Rows_examined：20003就表示这个语句执行过程中扫描了20003行，也就验证了我们分析得出的结论。</p>
<p>这里插一句题外话，在平时学习概念的过程中，你可以经常这样做，先通过原理分析算出扫描行数，然后再通过查看慢查询日志，来验证自己的结论。我自己就是经常这么做，这个过程很有趣，分析对了开心，分析错了但是弄清楚了也很开心。</p>
<p>现在，我来把完整的排序执行流程图画出来。</p>
<p><img src="https://static001.geekbang.org/resource/image/2a/fc/2abe849faa7dcad0189b61238b849ffc.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 随机排序完整流程</b>
    </div>
    <br>
</center>

<p>图1图中的pos就是位置信息，你可能会觉得奇怪，这里的“位置信息”是个什么概念？在上一篇文章中，我们对InnoDB表排序的时候，明明用的还是ID字段。</p>
<p>这时候，我们就要回到一个基本概念：<strong>MySQL的表是用什么方法来定位“一行数据”的。</strong></p>
<p>在前面<a href="https://time.geekbang.org/column/article/69236">第4</a>和<a href="https://time.geekbang.org/column/article/69636">第5</a>篇介绍索引的文章中，有几位同学问到，如果把一个InnoDB表的主键删掉，是不是就没有主键，就没办法回表了？</p>
<p>其实不是的。如果你创建的表没有主键，或者把一个表的主键删掉了，那么InnoDB会自己生成一个长度为6字节的rowid来作为主键。</p>
<p>这也就是排序模式里面，rowid名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。</p>
<ul>
<li>对于有主键的InnoDB表来说，这个rowid就是主键ID；</li>
<li>对于没有主键的InnoDB表来说，这个rowid就是由系统生成的；</li>
<li>MEMORY引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个rowid其实就是数组的下标。</li>
</ul>
<p>到这里，我来稍微小结一下：<strong>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</strong></p>
<h1 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h1><p>那么，是不是所有的临时表都是内存表呢？</p>
<p>其实不是的。tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</p>
<p>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。</p>
<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</p>
<p>为了复现这个过程，我把tmp_table_size设置成1024，把sort_buffer_size设置成 32768, 把 max_length_for_sort_data 设置成16。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size<span class="operator">=</span><span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data<span class="operator">=</span><span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/78/ab/78d2db9a4fdba81feadccf6e878b4aab.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 OPTIMIZER_TRACE部分结果</b>
    </div>
    <br>
</center>

<p>然后，我们来看一下这次OPTIMIZER_TRACE的结果。</p>
<p>因为将max_length_for_sort_data设置成16，小于word字段的长度定义，所以我们看到sort_mode里面显示的是rowid排序，这个是符合预期的，参与排序的是随机值R字段和rowid字段组成的行。</p>
<p>这时候你可能心算了一下，发现不对。R字段存放的随机值就8个字节，rowid是6个字节（至于为什么是6字节，就留给你课后思考吧），数据总行数是10000，这样算出来就有140000字节，超过了sort_buffer_size 定义的 32768字节了。但是，number_of_tmp_files的值居然是0，难道不需要用临时文件吗？</p>
<p>这个SQL语句的排序确实没有用到临时文件，采用是MySQL 5.6版本引入的一个新的排序算法，即：优先队列排序算法。接下来，我们就看看为什么没有使用临时文件的算法，也就是归并排序算法，而是采用了优先队列排序算法。</p>
<p>其实，我们现在的SQL语句，只需要取R值最小的3个rowid。但是，如果使用归并排序算法的话，虽然最终也能得到前3个值，但是这个算法结束后，已经将10000行数据都排好序了。</p>
<p>也就是说，后面的9997行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，想一下就明白了，这浪费了非常多的计算量。</p>
<p>而优先队列算法，就可以精确地只得到三个最小值，执行流程如下：</p>
<ol>
<li>对于这10000个准备排序的(R,rowid)，先取前三行，构造成一个堆；</li>
</ol>
<p>（对数据结构印象模糊的同学，可以先设想成这是一个由三个元素组成的数组）</p>
<ol>
<li>取下一个行(R’,rowid’)，跟当前堆里面最大的R比较，如果R’小于R，把这个(R,rowid)从堆中去掉，换成(R’,rowid’)；</li>
<li>重复第2步，直到第10000个(R’,rowid’)完成比较。</li>
</ol>
<p>这里我简单画了一个优先队列排序过程的示意图。</p>
<p><img src="https://static001.geekbang.org/resource/image/e9/97/e9c29cb20bf9668deba8981e444f6897.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 优先队列排序算法示例</b>
    </div>
    <br>
</center>

<p>图6是模拟6个(R,rowid)行，通过优先队列排序找到最小的三个R值的行的过程。整个排序过程中，为了最快地拿到当前堆的最大值，总是保持最大值在堆顶，因此这是一个最大堆。</p>
<p>图5的OPTIMIZER_TRACE结果中，filesort_priority_queue_optimization这个部分的chosen&#x3D;true，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的number_of_tmp_files是0。</p>
<p>这个流程结束后，我们构造的堆里面，就是这个10000行里面R值最小的三行。然后，依次把它们的rowid取出来，去临时表里面拿到word字段，这个过程就跟上一篇文章的rowid排序的过程一样了。</p>
<p>我们再看一下上面一篇文章的SQL查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure>

<p>你可能会问，这里也用到了limit，为什么没用优先队列排序算法呢？原因是，这条SQL语句是limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是1000行的(name,rowid)，超过了我设置的sort_buffer_size大小，所以只能使用归并排序算法。</p>
<p>总之，不论是使用哪种类型的临时表，order by rand()这种写法都会让计算过程非常复杂，需要大量的扫描行数，因此排序过程的资源消耗也会很大。</p>
<p>再回到我们文章开头的问题，怎么正确地随机排序呢？</p>
<h1 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h1><p>我们先把问题简化一下，如果只随机选择1个word值，可以怎么做呢？思路上是这样的：</p>
<ol>
<li>取得这个表的主键id的最大值M和最小值N;</li>
<li>用随机函数生成一个最大值到最小值之间的数 X &#x3D; (M-N)*rand() + N;</li>
<li>取不小于X的第一个ID的行。</li>
</ol>
<p>我们把这个算法，暂时称作随机算法1。这里，我直接给你贴一下执行语句的序列:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">max</span>(id),<span class="built_in">min</span>(id) <span class="keyword">into</span> <span class="variable">@M</span>,<span class="variable">@N</span> <span class="keyword">from</span> t ;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@X</span><span class="operator">=</span> <span class="built_in">floor</span>((<span class="variable">@M</span><span class="operator">-</span><span class="variable">@N</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>rand() <span class="operator">+</span> <span class="variable">@N</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="variable">@X</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法效率很高，因为取max(id)和min(id)都是不需要扫描索引的，而第三步的select也可以用索引快速定位，可以认为就只扫描了3行。但实际上，这个算法本身并不严格满足题目的随机要求，因为ID中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p>
<p>比如你有4个id，分别是1、2、4、5，如果按照上面的方法，那么取到 id&#x3D;4的这一行的概率是取得其他行概率的两倍。</p>
<p>如果这四行的id分别是1、2、40000、40001呢？这个算法基本就能当bug来看待了。</p>
<p>所以，为了得到严格随机的结果，你可以用下面这个流程:</p>
<ol>
<li>取得整个表的行数，并记为C。</li>
<li>取得 Y &#x3D; floor(C * rand())。 floor函数在这里的作用，就是取整数部分。</li>
<li>再用limit Y,1 取得一行。</li>
</ol>
<p>我们把这个算法，称为随机算法2。下面这段代码，就是上面流程的执行语句的序列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@sql</span> <span class="operator">=</span> concat(&quot;select * from t limit &quot;, <span class="variable">@Y</span>, &quot;,1&quot;);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> <span class="variable">@sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>

<p>由于limit 后面的参数不能直接跟变量，所以我在上面的代码中使用了prepare+execute的方法。你也可以把拼接SQL语句的方法写在应用程序中，会更简单些。</p>
<p>这个随机算法2，解决了算法1里面明显的概率不均匀问题。</p>
<p>MySQL处理limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前Y个，然后把下一个记录作为返回结果，因此这一步需要扫描Y+1行。再加上，第一步扫描的C行，总共需要扫描C+Y+1行，执行代价比随机算法1的代价要高。</p>
<p>当然，随机算法2跟直接order by rand()比起来，执行代价还是小很多的。</p>
<p>你可能问了，如果按照这个表有10000行来计算的话，C&#x3D;10000，要是随机到比较大的Y值，那扫描行数也跟20000差不多了，接近order by rand()的扫描行数，为什么说随机算法2的代价要小很多呢？我就把这个问题留给你去课后思考吧。</p>
<p>现在，我们再看看，如果我们按照随机算法2的思路，要随机取3个word值呢？你可以这么做：</p>
<ol>
<li>取得整个表的行数，记为C；</li>
<li>根据相同的随机方法得到Y1、Y2、Y3；</li>
<li>再执行三个limit Y, 1语句得到三行数据。</li>
</ol>
<p>我们把这个算法，称作随机算法3。下面这段代码，就是上面流程的执行语句的序列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span>，<span class="number">1</span>； <span class="operator">/</span><span class="operator">/</span>在应用代码里面取Y1、Y2、Y3值，拼出<span class="keyword">SQL</span>后执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span>，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span>，<span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我是借着随机排序的需求，跟你介绍了MySQL对临时表排序的执行过程。</p>
<p>如果你直接使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代价往往是比较大的。所以，在设计的时候你要量避开这种写法。</p>
<p>今天的例子里面，我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读写数据”的事情。因此，这类方法的应用还是比较广泛的。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>上面的随机算法3的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p>
<p>我的问题是，如果你是这个需求的开发人员，你会怎么做，来减少扫描行数呢？说说你的方案，并说明你的方案需要的扫描行数。</p>
<p>你可以把你的设计和结论写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后留给你的问题是，select * from t where city in (“杭州”,” 苏州 “) order by name limit 100;这个SQL语句是否需要排序？有什么方案可以避免排序？</p>
<p>虽然有(city,name)联合索引，对于单个city内部，name是递增的。但是由于这条SQL语句不是要单独地查一个city的值，而是同时查了”杭州”和” 苏州 “两个城市，因此所有满足条件的name就不是递增的了。也就是说，这条SQL语句需要排序。</p>
<p>那怎么避免排序呢？</p>
<p>这里，我们要用到(city,name)联合索引的特性，把这一条语句拆成两条语句，执行流程如下：</p>
<ol>
<li>执行<code>select * from t where city=“杭州” order by name limit 100; </code> 这个语句是不需要排序的，客户端用一个长度为100的内存数组A保存结果。</li>
<li>执行<code>select * from t where city=“苏州” order by name limit 100;</code>  用相同的方法，假设结果被存进了内存数组B。</li>
<li>现在A和B是两个有序数组，然后你可以用归并排序的思想，得到name最小的前100值，就是我们需要的结果了。</li>
</ol>
<p>如果把这条SQL语句里“limit 100”改成“limit 10000,100”的话，处理方式其实也差不多，即：要把上面的两条语句改成写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot;杭州&quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot;苏州&quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>。</span><br></pre></td></tr></table></figure>

<p>这时候数据量较大，可以同时起两个连接一行行读结果，用归并排序算法拿到这两个结果集里，按顺序取第10001~10100的name值，就是需要的结果了。</p>
<p>当然这个方案有一个明显的损失，就是从数据库返回给客户端的数据量变大了。</p>
<p>所以，如果数据的单行比较大的话，可以考虑把这两条SQL语句改成下面这种写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot;杭州&quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span>&quot;苏州&quot; <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">10100</span>。</span><br></pre></td></tr></table></figure>

<p>然后，再用归并排序的方法取得按name顺序第10001~10100的name、id的值，然后拿着这100个id到数据库中去查出所有记录。</p>
<p>上面这些方法，需要你根据性能需求和开发的复杂度做出权衡。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>评论区很多同学都提到不能排序，说明各位对索引的存储都理解对了。<br>@峰 同学提到了归并排序，是我们这个问题解法的核心思想；<br>@老杨同志 的回答中提到了“从业务上砍掉功能”，这个也确实是在业务设计中可以考虑的一个方向；</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>2021十九届六中全会精神主要内容概括：十个要点总结！</title>
    <url>/posts/14c1757.html</url>
    <content><![CDATA[<h2 id="一、十九届六中全会精神主要内容概括"><a href="#一、十九届六中全会精神主要内容概括" class="headerlink" title="一、十九届六中全会精神主要内容概括"></a>一、十九届六中全会精神主要内容概括</h2><p>十九届六中全会精神主要内容就是审议通过了《<strong>中共中央关于党的百年奋斗重大成就和历史经验的决议</strong>》。这是党的十九届六中全会的重要历史贡献，对于全党更加紧密地团结在以习近平同志为核心的党中央周围，进一步增强“<strong>四个意识</strong>”、坚定“<strong>四个自信</strong>”、做到“<strong>两个维护</strong>”，团结带领全国各族人民夺取新时代中国特色社会主义新的伟大胜利，具有重大现实意义和深远历史意义。</p>
<span id="more"></span>

<h3 id="1-五个方面总结百年奋斗历史意义"><a href="#1-五个方面总结百年奋斗历史意义" class="headerlink" title="1.五个方面总结百年奋斗历史意义"></a>1.五个方面总结百年奋斗历史意义</h3><p>一是指从根本上改变了中国人民的前途命运；</p>
<p>二是开辟了实现中华民族伟大复兴的正确道路；</p>
<p>三是展示了马克思主义的强大生命力；</p>
<p>四是深刻影响了世界历史进程；</p>
<p>五是锻造了走在时代前列的中国共产党。</p>
<h3 id="2-深刻领会党百年奋斗的历史经验"><a href="#2-深刻领会党百年奋斗的历史经验" class="headerlink" title="2.深刻领会党百年奋斗的历史经验"></a>2.深刻领会党百年奋斗的历史经验</h3><p>党一步步走过来，很重要的一条就是不断总结经验、提高本领，不断提高应对风险、迎接挑战、化险为夷的能力水平。十条历史经验为：<strong>坚持党的领导，坚持人民至上，坚持理论创新，坚持独立自主，坚持中国道路，坚持胸怀天下，坚持开拓创新，坚持敢于斗争，坚持统一战线，坚持自我革命</strong>。</p>
<h3 id="3-马克思主义中国化的三个飞跃"><a href="#3-马克思主义中国化的三个飞跃" class="headerlink" title="3.马克思主义中国化的三个飞跃"></a>3.马克思主义中国化的三个飞跃</h3><p>第一个飞跃时期：毛泽东思想是马克思列宁主义在中国的创造性运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是马克思主义中国化的第一次历史性飞跃。</p>
<p>第二个飞跃时期：中国特色社会主义理论体系，实现了马克思主义中国化新的飞跃。</p>
<p>第三个飞跃时期：习近平新时代中国特色社会主义思想是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华，实现了马克思主义中国化新的飞跃。</p>
<h3 id="4-四个必须是全党坚持内容"><a href="#4-四个必须是全党坚持内容" class="headerlink" title="4.四个必须是全党坚持内容"></a>4.四个必须是全党坚持内容</h3><p>全党必须坚持马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观，全面贯彻习近平新时代中国特色社会主义思想，用马克思主义的立场、观点、方法观察时代、把握时代、引领时代，不断深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识。</p>
<h3 id="5-两个确立具有决定性意义"><a href="#5-两个确立具有决定性意义" class="headerlink" title="5.两个确立具有决定性意义"></a>5.两个确立具有决定性意义</h3><p>党确立习近平同志党中央的核心、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位，反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。</p>
<h3 id="6-四个历史时期四个伟大飞跃"><a href="#6-四个历史时期四个伟大飞跃" class="headerlink" title="6.四个历史时期四个伟大飞跃"></a>6.四个历史时期四个伟大飞跃</h3><p>新民主主义革命时期：实现了中国从几千年封建专制政治向人民民主的伟大飞跃；</p>
<p>社会主义革命和建设时期：实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃；</p>
<p>改革开放和社会主义现代化建设新时期：实现了人民生活从温饱不足到总体小康、奔向全面小康的历史性跨越，推进了中华民族从站起来到富起来的伟大飞跃；</p>
<p>中国特色社会主义进入新时代：中华民族迎来了从站起来、富起来到强起来的伟大飞跃。</p>
<h3 id="7-牢记一个根本问题"><a href="#7-牢记一个根本问题" class="headerlink" title="7.牢记一个根本问题"></a>7.牢记一个根本问题</h3><p>全党要牢记党是什么、要干什么这个根本问题 十九届六中全会提出，全党要牢记中国共产党是什么、要干什么这个根本问题。</p>
<h3 id="8-一个号召"><a href="#8-一个号召" class="headerlink" title="8.一个号召"></a>8.一个号召</h3><p>全党全军全国各族人民要更加紧密地团结在以习近平同志为核心的党中央周围，全面贯彻习近平新时代中国特色社会主义思想，大力弘扬伟大建党精神，勿忘昨天的苦难辉煌，无愧今天的使命担当,不负明天的伟大梦想，以史为鉴、开创未来，埋头苦干、勇毅前行，为实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦而不懈奋斗。</p>
<h3 id="9-十个明确"><a href="#9-十个明确" class="headerlink" title="9.十个明确"></a>9.十个明确</h3><p>明确中国特色社会主义最本质的特征是中国共产党领导；明确坚持和发展中国特色社会主义；明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾；明确中国特色社会主义事业总体布局是经济建设、政治建设、文化建设、社会建设、生态文明建设五位一体；明确全面深化改革总目标；明确全面推进依法治国总目标；明确坚持和完善社会主义基本经济制度；明确党在新时代的强军目标；明确中国特色大国外交服务；明确全面从严治党的战略方针。</p>
<h3 id="10-十三个方面的历史性成就"><a href="#10-十三个方面的历史性成就" class="headerlink" title="10.十三个方面的历史性成就"></a>10.十三个方面的历史性成就</h3><p>包括在坚持党的全面领导上、在全面从严治党上、在经济建设上、在全面深化改革开放上、在政治建设上、在全面依法治国上、在文化建设上、在社会建设上、在生态文明建设上、在国防和军队建设上、在维护国家安全上、在坚持“一国两制”和推进祖国统一上及在外交工作上。</p>
]]></content>
      <categories>
        <category>时事政治</category>
      </categories>
      <tags>
        <tag>时事政治</tag>
      </tags>
  </entry>
  <entry>
    <title>2023国考行测模考大赛（第三十二季）错题整理</title>
    <url>/posts/20cc180f.html</url>
    <content><![CDATA[<style>
details{
  color: brown;
  margin-bottom: 16px;
  }
</style>
<p>20世纪80年代，改革开放的春风带来了经济的复苏和发展，也带动了文艺的繁荣，人们的精神文化需求被空前_________。各地方卫视春晚依托综艺节目的积累，开始在语言类节目方面争奇斗艳。与此同时，喜剧综艺_________，由此推动了喜剧的快速发展。</p>
<span id="more"></span>



<p>依次填入画横线部分最恰当的一项是：</p>
<p>A 满足 日甚一日</p>
<p>B 激活 遍地开花</p>
<p>C 催生 脱颖而出</p>
<p>D 丰富 异军突起</p>
<details>
<summary>查看答案和解析</summary>
正确答案是 B
  
<p>** 解析 **<br>第一空，由“改革开放的春风带来了经济的复苏和发展，也带动了文艺的繁荣”可知，横线处应体现出文艺繁荣对人们的精神文化需求的影响。A项“满足”指完全满意于一项欲望、渴念、需要或者要求的实现，B项“激活”指刺激从而使其活跃地发挥作用，C项“催生”指促使事物发生或形成，均符合文意，保留。D项“丰富”指丰裕富足，可搭配“生活、经验”，与“需求”搭配不当，排除。</p>
<p>第二空，由“与此同时”及“由此推动了喜剧的快速发展”可知，横线处应体现出喜剧综艺蓬勃发展之意。B项“遍地开花”比喻好事普遍流传、蓬勃发展，与文意相符，当选。A项“日甚一日”指程度日渐严重，逐日加深，感情色彩偏消极，与文段感情色彩不符，排除；C项“脱颖而出”比喻人的才能全部显示出来，与“喜剧综艺”搭配不当，排除。</p>
<p>故正确答案为B。</p>
<p>【文段出处】《舞台喜剧会迎来又一春吗？》</p>
</details>

<p>考点：<code>对应关系-重点词句对应</code> <code>混搭填空</code> <code>词的辨析-感情色彩</code> <code>词的辨析-固定搭配</code></p>
<hr>
<p>评书的勃兴，早年和书场的繁荣_________ 。北方评书，南方弹词，上世纪30年代，伴随着城市文化的兴起，曾经_________，在上海是仅次于电影的第二大娱乐项目，至四五十年代，最多时上海有近600家书场。</p>
<p>依次填入画横线部分最恰当的一项是：</p>
<p>A 环环相扣 炙手可热</p>
<p>B 唇齿相依 风靡一时</p>
<p>C 惺惺相惜 名声大噪</p>
<p>D 息息相关 交口称赞</p>
<details>
<summary>查看答案和解析</summary>
正确答案是 B
  
<p><strong>解析</strong></p>
<p>第一空，根据后文可知，伴随着城市文化的兴起，“北方评书，南方弹词”成为了上海的第二大娱乐项目，故“评书的勃兴”与“书场的繁荣”有比较密切的关联。A项“环环相扣”意思是一环接着一环，形容连接的紧密，B项“唇齿相依”比喻关系密切，相互依靠，D项“息息相关”形容彼此的关系非常密切，均符合文意，保留。C项“惺惺相惜”指性格、志趣、境遇相同的人互相爱护、同情、支持，与文意无关，排除。</p>
<p>第二空，根据“是仅次于电影的第二大娱乐项目，至四五十年代，最多时上海有近600家书场”可知，评书和弹词曾经十分流行。B项“风靡一时”形容事物在一个时期里极其盛行，像风吹倒草木一样，符合文意，当选。A项“炙手可热”比喻权势大，气焰盛，使人不敢接近，不符合文意，排除；D项“交口称赞”意为异口同声地称赞，常表述为“令人交口称赞”“让人交口称赞”，置于此处用法不当，排除。</p>
<p>故正确答案为B。</p>
<p>【文段出处】《送别大师，兼议古典表演样式的价值》</p>
</details>

<p>考点：<code>对应关系-重点词句对应</code> <code>对应关系-解释类对应</code> <code>成语填空</code> <code>词的辨析-固定搭配</code></p>
<hr>
<p>在人生的道路上，闻道有先后，术业有专攻，唯有善于学习，才能自我超越，不断进步。正所谓“读书万卷始通神”，文艺创作是艰辛的创造性工作，尤需在广泛阅读中转益多师，在专心致志中_________。同时，投身创作实践，为作家艺术家提供了学真知、悟真谛的_________。对于作家艺术家而言，阅读是“输入”，创作是“输出”，二者同根同源，互促互通。</p>
<p>依次填入画横线部分最恰当的一项是：</p>
<p>A 吐故纳新 他山之石</p>
<p>B 学以致用 灵丹妙药</p>
<p>C 厚积薄发 不二法门</p>
<p>D 笔走龙蛇 源头活水</p>
<details>
<summary>查看答案和解析</summary>
正确答案是 C
  
<p>解析</p>
<p>第一空，“在广泛阅读中转益多师，在专心致志中······”相同句式表并列，“转益多师”意为尽可能多地以人或自然物为老师，且根据前文“唯有善于学习，才能自我超越，不断进步”以及“文艺创作是艰辛的创造性工作”可知，文段意在表达唯有广泛且专心地阅读，文艺创作者才能进步。A项“吐故纳新”比喻扬弃旧的、不好的，吸收新的、好的，C项“厚积薄发”形容只有准备充分才能办好事情，均符合文意，保留。B项“学以致用”指为了实际应用而学习，“投身创作实践”为“同时”后的另一方面内容，“同时”前并未涉及“实践”，与文意不符，排除；D项“笔走龙蛇”形容书法生动而有气势，与文意不符，排除。</p>
<p>第二空，根据文意可知，横线处意在表达“为作家艺术家提供了学真知、悟真谛的”方式或渠道。C项“不二法门”比喻最好的或独一无二的方法，符合文意，当选。A项“他山之石”比喻能帮助自己改正缺点的外力，通常用作“借助或利用他山之石”，且阅读之于文艺创作也并非是“他山”，即非外力，与文意不符，排除。</p>
<p>故正确答案为C。</p>
<p>【文段出处】《读万千气象 涵艺坛书香》</p>
</details>

<p>考点 <code>对应关系-重点词句对应</code> <code>成语填空</code> <code>关联关系-并列关系</code></p>
<hr>
<p>贯彻依法治军战略需要落实的规定内容多、涉及对象多、流程环节多，只有善于突出重点，才能起到_________、以点带面的效果，不断取得新的成效和更大突破。特别是随着我军组织结构实现历史性变革、力量体系实现革命性_________，军队信息化智能化程度不断提高，贯彻依法治军战略涵盖的因素更加多元、涉及面更加广泛，必须用系统观念全面_________ 依法治军战略的贯彻落实。</p>
<p>依次填入画横线部分最恰当的一项是：</p>
<p>A 抓大放小 构建 筹划</p>
<p>B 纲举目张 重塑 谋划</p>
<p>C 对症下药 改造 计划</p>
<p>D 提纲挈领 进展 策划</p>
<details>
<summary>查看答案和解析</summary>
  
<p>正确答案是 B</p>
<p>解析</p>
<p>第一空，由“突出重点”“以点带面”可知，横线处成语应体现把握住战略重点就能够推动其他工作，B项“纲举目张”意为提起渔网的总绳一撒，所有网眼就都张开了，比喻做事抓住要领，就可带动其他环节，D项“提纲挈领”比喻举其要领，扼其要害，就能理顺关系，处事得心应手，均符合文意，保留。A项“抓大放小”意思是抓住主要矛盾和矛盾的主要方面，搞好宏观控制，对次要矛盾和矛盾的次要方面进行微观调节，文段意为把握住战略重点就能够推动其他工作，并没有体现“放小”的语义，与文意不符，排除；C项“对症下药”比喻针对事物的问题所在，采取有效的措施，无法体现把握住战略重点就能够推动其他工作，与文意不符，排除。</p>
<p>第二空，搭配“力量体系”，由“历史性变革”可知，横线处词语应体现出脱胎换骨的改变之意。B项“重塑”指重新塑造，符合文意，保留。D项“进展”指向前发展，与“力量体系”搭配不当，排除。</p>
<p>第三空，代入验证。搭配“依法治军战略”，由文意可知，横线处词语应表达出如何全面贯彻落实依法治军战略工作之意。B项“谋划”指计划、想办法，符合文意，且“全面谋划”为常用搭配，当选。</p>
<p>故正确答案为B。</p>
<p>【文段出处】《运用系统观念贯彻依法治军战略》</p>
</details>

<p>考点：<code>对应关系-重点词句对应</code> <code>混搭填空</code> <code>词的辨析-固定搭配</code></p>
<hr>
<p>____________。司法治理效能的增强有赖于司法同政府部门、社会组织及公众结成优化协同的治理关系，司法与政府部门之间既要明晰职权界限，又要共同瞄准高效能治理的目标展开紧密的协同，同样，司法与其他各类参与主体在司法过程中的对话与协商也是达成公正高效司法的必备条件。多方主体所实施的调解、仲裁、行政裁决、行政复议等多元纠纷解决渠道，与司法结成紧密衔接、有效配合的协同治理系统，共同致力于纠纷的源头化、效率化的解决。</p>
<p>填入画横线部分最恰当的一项是：</p>
<p>A 司法治理的高效运行要求明确的职责划分</p>
<p>B 司法体制机制的完善应当从顶层设计入手</p>
<p>C 构建司法体系需政府各部门的对话与协商</p>
<p>D 司法治理的精髓在于协同治理与多元参与</p>
<details>
<summary>查看答案和解析</summary>
  
<p>正确答案是 D</p>
<p>解析</p>
<p>横线出现在文段开头，需要起到总领全文的作用。横线后指出司法治理效能的增强有赖于多方主体协同的治理关系，司法与政府部门间既要明晰职权界限，又要紧密合作，紧接着通过“同样”引导并列，强调司法与其他主体也要对话与协商，尾句论述多方主体协商的意义，故横线后为“同样”引导的并列结构，侧重强调司法治理效能增强需要多方主体参与并进行协商合作，对应D项。</p>
<p>A项，“明确的职责划分”对应横线后首句，是并列的其中一方面，表述片面，排除；</p>
<p>B项，“顶层设计”文段并未提及，无中生有，排除；</p>
<p>C项，“政府各部门”表述片面，忽略了后文论述的司法与其他主体之间的对话与协商，且缺乏文段核心话题“司法治理”，排除。</p>
<p>故正确答案为D。</p>
<p>【文段出处】《司法体制综合配套改革推进国家治理创新实践》</p>
</details>

<p>考点：<code>开头</code></p>
<hr>
<p>在社交网络上，围绕性格测试的不同性格类型的鄙视链已经形成并不断固化。性格本无高下之分，然而有人仍得意于自己“拥有”处于性格金字塔顶端的性格，并将之与高能力、高职位相关联。而围绕性格的这种隐形“算法”，正是这类游戏本身所暗示和强化的。更重要的是，这种提取自社会经验的“算法”，____________。在网传的性格金字塔中，善于思考的INTJ性格处于顶端，并被冠以“军师”之誉，而在金字塔庞大的底层，则是“具有奉献精神的保护者”的ISFJ性格，比如“照料者”。这与我们熟悉的“内向&#x3D;没出息”“外向&#x3D;探索”偏见何其相似。</p>
<p>填入画横线部分最恰当的一项是：</p>
<p>A 可能逐步加深一些社会偏见和歧视</p>
<p>B 为现代人的社交戴上了一副“面具”</p>
<p>C 已成为简单粗暴地“解读”他人的工具</p>
<p>D 导致人们陷入自我怀疑和自我消耗之中</p>
<details>
<summary>查看答案和解析</summary>

<p>正确答案是 A</p>
<p>解析</p>
<p>横线在文段中间，需考虑与前后文的衔接。文段开篇引出话题，即社交网络上的性格测试导致了性格鄙视链，不同性格原本是平等的，接着通过转折词“然而”强调有人却因性格测试的结果而产生优越感。横线后阐述性格测试造成鄙视链的具体表现。横线前“更重要的是”表强调，“这种······‘算法’”指代性格测试，故本句意在强调性格测试加深了社会偏见，对应A项。</p>
<p>B项，“戴上‘面具’”意为性格测试成为了现代人在社交中伪装自己的工具，横线前后缺少对“社交”的论述，衔接不当，排除；</p>
<p>C项，“‘解读’他人”文段并未提及，无中生有，排除；</p>
<p>D项，“自我怀疑和自我消耗”文段并未提及，无中生有，排除。</p>
<p>故正确答案为A。</p>
<p>【文段出处】《光明网评论员：你做性格测试了吗》</p>
</details>

<p>考点：<code>中间</code></p>
<hr>
<p>让工业化城镇化的增长效应更公平地扩散到广大农民农村，____________。一方面，应进一步推动城镇对农民的开放，继续深化户籍制度改革，完善基本公共服务制度，尽快提高城镇基本公共服务覆盖进城农民的广度和深度。另一方面，应进一步推动农村对城镇居民的开放，随着交通、通信条件改善和产业、就业形态变化，乡村的居住生活形态对城镇部分人群的吸引力逐步增强。部分城镇居民下乡有利于优化农村人口结构、更好利用农村闲置资源，应继续深化农村集体经济组织相关制度、宅基地制度等方面的改革，保障“新村民”依法享有农村相关权益。</p>
<p>填入画横线部分最恰当的一项是：</p>
<p>A 能提高劳动力收入水平以及劳动力人均资源占有量</p>
<p>B 实施乡村振兴战略可以解决发展不平衡不充分问题</p>
<p>C 促进劳动力从农业向非农产业、从乡村向城镇转移</p>
<p>D 关键是破除阻碍城乡人口双向流动的城乡二元体制</p>
<details>
<summary>查看答案和解析</summary>
  
<p>正确答案是 D</p>
<p>解析</p>
<p>横线出现在文段开头，需要起到总领全文的作用。横线前提出让工业化城镇化的增长效应更公平地扩散到农民农村，横线后通过“一方面”说明应推动城镇对农民的开放，“另一方面”后围绕加强农村对城镇居民的开放展开论述，故横线处衔接前后文，应体现让工业化城镇化的增长效应更公平地扩散到农村的方式一个是城镇对农民的开放，另一个是农村对城镇居民的开放，即实现城乡人口的双向流动，对应D项。</p>
<p>A项，未体现城乡人口的流动，无法衔接后文，排除；</p>
<p>B项，文段并未论述“实施乡村振兴战略”，无中生有，无法衔接前后文，排除；</p>
<p>C项，“从农业向非农产业、从乡村向城镇转移”仅对应后文“一方面”的内容，表述片面，没有体现城乡人口的双向流动，无法衔接后文，排除。</p>
<p>故正确答案为D。</p>
<p>【文段出处】《在乡村振兴中提高发展包容性》</p>
</details>

<hr>
<p>考点：<code>开头</code></p>
<p>三峡工程投入运行以来，拦河大坝及泄洪消能、引水发电、通航及防护工程等主要建筑物工作性态正常，机电系统及设备、金属结构设备运行安全稳定；输变电工程运行安全稳定可靠，设备状态良好。稳如磐石的三峡工程，在防洪、发电、航运、水资源利用等方面也交出一份份表现卓越的答卷。在与洪水的反复较量中，三峡工程力挽狂澜，与长江上中游其他水库联手筑起“铜墙铁壁”，极大减轻了下游地区的防洪压力，大幅度降低了防汛风险和成本。此外，三峡工程还有力支持了华东、华中、广东等地区电力供应。投产以来三峡工程发出的优质清洁电力能源，相当于节约标准煤4.30亿吨，减少二氧化碳排放11.69亿吨。</p>
<p>这段文字主要介绍了三峡工程：</p>
<p>A 自投入使用以来的运行情况</p>
<p>B 在生态保护方面做出的贡献</p>
<p>C 工程运行稳定全面发挥效用</p>
<p>D 工作原理及取得的卓越成绩</p>
<p>正确答案是 C</p>
<p>解析</p>
<p>文段开篇介绍了三峡工程稳定的工作状态，接着指出“稳如磐石”的三峡工程，在各方面也交出了卓越的答卷，随后介绍三峡工程在抗洪、供电、环保方面发挥的作用。文段通过“也”表示并列，介绍了三峡工程稳定的运行状态和多方面的综合运用，对应C项。</p>
<p>A项，“运行情况”表述片面，文段主要介绍了运行稳定和作用发挥两方面的内容，排除；</p>
<p>B项，文段提到了三峡工程在“抗洪、供电、环保”方面做出的贡献，“生态保护”偷换概念，且表述片面，排除；</p>
<p>D项，文段并未论述三峡工程的“工作原理”，无中生有，排除。</p>
<p>故正确选项为C。</p>
<p>【文段出处】《当之无愧的大国重器——写在三峡工程完成整体竣工验收之际》</p>
<p>考点：<code>关联词-并列</code></p>
<hr>
<p>河套之称出现于明代。《明史》记载：“大河三面环之，所谓河套也。”事实上，仅有三面环河的自然地理条件还不足以形成河套之形胜，因为三面环之的特点古已有之；明季以降，长城横截其面，才是河套之谓出现的根本原因。这一三面环河加上长城横穿而过的地理特征构成了相对独立的地理单元，是自然因素和人文条件共同催生的结果。随着黄河改道等缘故，清季又有前套、后套、西套等称谓，形成了现代地理意义上的河套。虽然这一地区在广袤的中国国土中并不十分起眼，但在中国古代历史进程中却具有扼系天下安危的重要地位。这一点也早为古代先贤所认知。</p>
<p>接下来最有可能论述的是：</p>
<p>A<br>古代先贤对于河套的赞美</p>
<p>B<br>历代政权重视河套的原因</p>
<p>C<br>文人对于河套地理位置的描述</p>
<p>D<br>古代贤哲对河套重要性的评价</p>
<p>正确答案是 D，你的答案是 B收起<br>解析<br>本题为接语选择题，重点关注文段尾句。文段开篇指出河套这一名称出现于明代，接着介绍了河套出现的自然地理条件和人文条件及现代地理意义上的河套形成的原因，随后指出河套在中国历史进程中具有扼系天下安危的重要地位，尾句“这一点”指代前文，指出河套扼系天下安危的重要地位早为古代先贤所知，故接下来应继续围绕“河套的重要地位”和“古代先贤”的话题展开论述，对应D项。</p>
<p>A项，“对于河套的赞美”表述不明确，尾句重在强调河套扼系天下安危的重要地位早为古代先贤所知，排除；</p>
<p>B项“重视河套的原因”、C项“对于河套地理位置的描述”均与尾句话题无关，排除。</p>
<p>故正确答案为D。</p>
<p>【文段出处】《河套地区的西夏史迹》</p>
<p>考点<br>接语选择题<br>来源<br>2023年国考第三十二季行测模考大赛（地市级）第55题</p>
<hr>
<p>过去，知网查重只对机构开放，再由学校给予学生少量的查重机会，远不能满足学生的需要，学生只能想方设法去查重，花费巨大，这也是学生毕业前的“大山”。开放个人查重，为学生提供正规渠道、减轻经济负担，算是一个进步。不过，知网被指摘的问题，远不止查重这一个。知网的版权收益问题也悬而未决。平台用作者的成果牟利，作者自己不仅毫无收益，还要付费下载，这个现实悖论让人觉得荒诞。因此，开放个人查重只是其中一小步，但知网应该明白，要做的事还有很多。</p>
<p>这段文字意在强调：</p>
<p>A<br>知识付费还有很长的探索之路要走</p>
<p>B<br>知网查重问题应纳入社会治理范畴</p>
<p>C<br>开放个人查重是知网良性发展的开端</p>
<p>D<br>平台应主动听取意见实现知识共享初衷</p>
<p>正确答案是 C，你的答案是 A收起<br>解析<br>文段开篇论述过去知网查重存在的问题，即过去的知网查重远不能满足学生需求，且令学生花费巨大，接着介绍开放个人查重为学生提供了正规渠道、减轻了经济负担，解决了前文提及的问题，然后由转折词“不过”引出知网存在的另一问题，即知网的版权收益问题，并进行具体说明，最后由结论词“因此”总结前文，强调知网开放个人查重只是进步的一小步，但要做的事情还有很多，故文段为分总结构，重点为尾句，强调知网还有很多问题需要解决。C项，“良性发展的开端”表明只是第一步，后面还有很长的路，符合文意，当选。</p>
<p>A项，文段强调的核心话题是“知网”而非“知识付费”，偷换主题词，排除；</p>
<p>B项，“纳入社会治理范畴”文段未明确提及，与文意无关，排除；</p>
<p>D项，“主动听取意见”文段未明确提及，与文意无关，排除。</p>
<p>故正确答案为C。</p>
<p>【文段出处】《知网开放个人查重，但整改之路还很长》</p>
<p>考点<br>主题词<br>行文脉络-分总<br>关联词-转折<br>来源<br>2023年国考第三十二季行测模考大赛（地市级）第58题</p>
<p>统计<br>正确率<br>61%</p>
<p>答题时间<br>120秒</p>
<p>易错项<br>D</p>
<ol start="59">
<li>单选题<br>中国残疾人联合会统计数据显示，截止2020年2月，中国共有8500万残疾人，包括视力、听力、肢体或精神残疾等。为他们提供友好的生活发展环境，体现着社会的文明层次与权利水位。友好型社会，不止涵括有形的无障碍设施，也包括无形的无障碍服务。这就需要拆除人心藩篱与规则围栏，将无障碍标准贯穿到很多产品与服务的供给中，既与权利保障的要求对标，也真正体现向善的人文温度。换言之，在涉及残障人士正当权利的问题上，不能让他们去适应呆板规则，而应让规则去适应他们。</li>
</ol>
<p>这段文字意在说明：</p>
<p>A<br>应为残障人士提供友好型社会环境从而体现人文温度</p>
<p>B<br>为残障人士提供人性化服务是文明社会的题中之义</p>
<p>C<br>保障残障人士的权利不能以“筑墙”思维进行阻隔</p>
<p>D<br>社会各方应以“变则通”思维呼应残障人士权利保障问题</p>
<p>正确答案是 D，你的答案是 C收起<br>解析<br>文段开篇通过数据交代中国残疾人数量多及包含的残疾类型，随后指出为他们提供友好型社会环境的意义，接着论述友好型社会环境不止涵括有形的无障碍设施，也包括无形的无障碍服务，然后通过“这就需要”一词引出对策，要拆除人心藩篱与规则围栏，将无障碍标准贯穿到产品与服务的供给中。尾句通过总结词“换言之”引出结论，即在涉及残障人士正当权利的问题上，应让规则去适应他们，由此可知，文段为分总结构，意在说明应改变规则保障残障人士的权利，D项，“‘变则通’思维”即改变规则之意，当选。</p>
<p>A项，文段强调应改变规则保障残障人士的权利，而非如何给残障人士提供“友好型社会环境”，偏离文段核心话题，排除；</p>
<p>B项，文段未提及“提供人性化服务”，无中生有，排除；</p>
<p>C项，文段强调应改变规则保障残障人士的权利，“不能以‘筑墙’思维进行阻隔”表述不明确，排除。</p>
<p>故正确答案为D。</p>
<p>【文段出处】《残障人士“理财权”该予保障而非架空》</p>
<p>考点<br>关联词-对策<br>行文脉络-分总<br>来源<br>2023年国考第三十二季行测模考大赛（地市级）第59题</p>
<p>统计<br>正确率<br>47%</p>
<p>答题时间<br>61秒</p>
<p>易错项<br>A</p>
<ol start="60">
<li>单选题<br>“饭圈文化”中所产生的文化内涵具有强烈的趋向性，不同的“圈子”所表现出的文化内涵各有差异。基于互联网平台，青年能够通过自我认知以及自我认同的方式建构主体意识。媒体技术的发展是从“群体化”到“个体化”再到“群体化”的过程，这为青年提供了选择的环境，青年粉丝在不同圈层之间自主选择，表明他们已经具有自身能力和功能性价值的自我认知、自我判断、自我预估，其主体意识进一步强化。</li>
</ol>
<p>这段文字意在说明：</p>
<p>A<br>媒体技术助推青年主体意识建构异化现象的发展</p>
<p>B<br>“饭圈文化”的文化内涵助推青年主体意识的建构</p>
<p>C<br>青年主体意识建构应蕴含鲜明的人文精神特征</p>
<p>D<br>互联网平台为建构青年主体意识营造了技术环境</p>
<p>正确答案是 D，你的答案是 A收起<br>解析<br>文段首先提出不同的“饭圈文化”背后的文化内涵各有差异，随后指出基于互联网平台，青年能够建构主体意识，紧接着进行解释说明，即媒体技术的发展为青年提供了选择的环境，使得青年粉丝可以在不同的圈层之间自主选择，促进了青年主体意识进一步强化，故文段为分总分结构，强调互联网技术的发展有利于青年主体意识的建构，对应D项。</p>
<p>A项，文段强调“青年主体意识的建构”，而非“青年主体意识建构异化现象”，偷换主题词，排除；</p>
<p>B项，文段强调的是“互联网技术的发展”推动“青年主体意识的建构”，而非“饭圈文化”，表述错误，排除；</p>
<p>C项，文段并未提及如何建构主体意识，无中生有，排除。</p>
<p>故正确答案为D。</p>
<p>【文段出处】人民论坛《“饭圈文化”下青年主体意识的建构》</p>
<p>考点<br>主题词<br>行文脉络-分总分<br>来源<br>2023年国考第三十二季行测模考大赛（地市级）第60题</p>
]]></content>
      <categories>
        <category>公考</category>
        <category>行测</category>
      </categories>
      <tags>
        <tag>公考</tag>
        <tag>试题</tag>
        <tag>行测</tag>
      </tags>
  </entry>
  <entry>
    <title>22 | MySQL有哪些“饮鸩止渴”提高性能的方法</title>
    <url>/posts/949be54e.html</url>
    <content><![CDATA[<p>不知道你在实际运维过程中有没有碰到这样的情景：业务高峰期，生产环境的MySQL压力太大，没法正常响应，需要短期内、临时性地提升一些性能。</p>
<span id="more"></span>

<p>我以前做业务护航的时候，就偶尔会碰上这种场景。用户的开发负责人说，不管你用什么方案，让业务先跑起来再说。</p>
<p>但，如果是无损方案的话，肯定不需要等到这个时候才上场。今天我们就来聊聊这些临时方案，并着重说一说它们可能存在的风险。</p>
<h1 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h1><p>正常的短连接模式就是连接到数据库后，执行很少的SQL语句就断开，下次需要的时候再重连。如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p>
<p>我在第1篇文章<a href="https://time.geekbang.org/column/article/68319">《基础架构：一条SQL查询语句是如何执行的？》</a>中说过，MySQL建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p>
<p>在数据库压力比较小的时候，这些额外的成本并不明显。</p>
<p>但是，短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。max_connections参数，用来控制一个MySQL实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。</p>
<p>在机器负载比较高的时候，处理现有请求的时间变长，每个连接保持的时间也更长。这时，再有新建连接的话，就可能会超过max_connections的限制。</p>
<p>碰到这种情况时，一个比较自然的想法，就是调高max_connections的值。但这样做是有风险的。因为设计max_connections这个参数的目的是想保护MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到CPU资源去执行业务的SQL请求。</p>
<p>那么这种情况下，你还有没有别的建议呢？我这里还有两种方法，但要注意，这些方法都是有损的。</p>
<p><strong>第一种方法：先处理掉那些占着连接但是不工作的线程。</strong></p>
<p>max_connections的计算，不是看谁在running，是只要连着就占用一个计数位置。对于那些不需要保持的连接，我们可以通过kill connection主动踢掉。这个行为跟事先设置wait_timeout的效果是一样的。设置wait_timeout参数表示的是，一个线程空闲wait_timeout这么多秒之后，就会被MySQL直接断开连接。</p>
<p>但是需要注意，在show processlist的结果里，踢掉显示为sleep的线程，可能是有损的。我们来看下面这个例子。</p>
<p><img src="https://static001.geekbang.org/resource/image/90/2a/9091ff280592c8c68665771b1516c62a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 sleep线程的两种状态</b>
    </div>
    <br>
</center>

<p>在上面这个例子里，如果断开session A的连接，因为这时候session A还没有提交，所以MySQL只能按照回滚事务来处理；而断开session B的连接，就没什么大影响。所以，如果按照优先级来说，你应该优先断开像session B这样的事务外空闲的连接。</p>
<p>但是，怎么判断哪些是事务外空闲的呢？session C在T时刻之后的30秒执行show processlist，看到的结果是这样的。</p>
<p><img src="https://static001.geekbang.org/resource/image/ae/25/ae6a9ceecf8517e47f9ebfc565f0f925.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 sleep线程的两种状态，show processlist结果</b>
    </div>
    <br>
</center>

<p>图中id&#x3D;4和id&#x3D;5的两个会话都是Sleep 状态。而要看事务具体状态的话，你可以查information_schema库的innodb_trx表。</p>
<p><img src="https://static001.geekbang.org/resource/image/ca/e8/ca4b455c8eacbf32b98d1fe9ed9876e8.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 从information_schema.innodb_trx查询事务状态</b>
    </div>
    <br>
</center>

<p>这个结果里，trx_mysql_thread_id&#x3D;4，表示id&#x3D;4的线程还处在事务中。</p>
<p>因此，如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p>
<p>从服务端断开连接使用的是kill connection + id的命令， 一个客户端处于sleep状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p>
<p>从数据库端主动断开连接可能是有损的，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL一直没恢复”。</p>
<p>你可能觉得这是一个冷笑话，但实际上我碰到过不下10次。</p>
<p>所以，如果你是一个支持业务的DBA，不要假设所有的应用代码都会被正确地处理。即使只是一个断开连接的操作，也要确保通知到业务开发团队。</p>
<p><strong>第二种方法：减少连接过程的消耗。</strong></p>
<p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是让数据库跳过权限验证阶段。</p>
<p>跳过权限验证的方法是：重启数据库，并使用–skip-grant-tables参数启动。这样，整个MySQL会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p>
<p>但是，这种方法特别符合我们标题里说的“饮鸩止渴”，风险极高，是我特别不建议使用的方案。尤其你的库外网可访问的话，就更不能这么做了。</p>
<p>在MySQL 8.0版本里，如果你启用–skip-grant-tables参数，MySQL会默认把 –skip-networking参数打开，表示这时候数据库只能被本地的客户端连接。可见，MySQL官方对skip-grant-tables这个参数的安全问题也很重视。</p>
<p>除了短连接数暴增可能会带来性能问题外，实际上，我们在线上碰到更多的是查询或者更新语句导致的性能问题。其中，查询问题比较典型的有两类，一类是由新出现的慢查询导致的，一类是由QPS（每秒查询数）突增导致的。而关于更新语句导致的性能问题，我会在下一篇文章和你展开说明。</p>
<h1 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h1><p>在MySQL中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<ol>
<li>索引没有设计好；</li>
<li>SQL语句没写好；</li>
<li>MySQL选错了索引。</li>
</ol>
<p>接下来，我们就具体分析一下这三种可能，以及对应的解决方案。</p>
<p><strong>导致慢查询的第一种可能是，索引没有设计好。</strong></p>
<p>这种场景一般就是通过紧急创建索引来解决。MySQL 5.6版本以后，创建索引都支持Online DDL了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行alter table 语句。</p>
<p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库A、备库B，这个方案的大致流程是这样的：</p>
<ol>
<li>在备库B上执行 set sql_log_bin&#x3D;off，也就是不写binlog，然后执行alter table 语句加上索引；</li>
<li>执行主备切换；</li>
<li>这时候主库是B，备库是A。在A上执行 set sql_log_bin&#x3D;off，然后执行alter table 语句加上索引。</li>
</ol>
<p>这是一个“古老”的DDL方案。平时在做变更的时候，你应该考虑类似gh-ost这样的方案，更加稳妥。但是在需要紧急处理时，上面这个方案的效率是最高的。</p>
<p><strong>导致慢查询的第二种可能是，语句没写好。</strong></p>
<p>比如，我们犯了在第18篇文章<a href="https://time.geekbang.org/column/article/74059">《为什么这些SQL语句逻辑相同，性能却差异巨大？》</a>中提到的那些错误，导致语句没有使用上索引。</p>
<p>这时，我们可以通过改写SQL语句来处理。MySQL 5.7提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p>
<p>比如，语句被错误地写成了 select * from t where id + 1 &#x3D; 10000，你可以通过下面的方式，增加一个语句改写规则。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(<span class="keyword">pattern</span>, replacement, pattern_database) <span class="keyword">values</span> (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure>

<p>这里，call query_rewrite.flush_rewrite_rules()这个存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。你可以用图4中的方法来确认改写规则是否生效。</p>
<p><img src="https://static001.geekbang.org/resource/image/47/8a/47a1002cbc4c05c74841591d20f7388a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 查询重写效果</b>
    </div>
    <br>
</center>

<p><strong>导致慢查询的第三种可能，就是碰上了我们在第10篇文章</strong><a href="https://time.geekbang.org/column/article/71173"><strong>《MySQL为什么有时候会选错索引？》</strong></a><strong>中提到的情况，MySQL选错了索引。</strong></p>
<p>这时候，应急方案就是给这个语句加上force index。</p>
<p>同样地，使用查询重写功能，给原来的语句加上force index，也可以解决这个问题。</p>
<p>上面我和你讨论的由慢查询导致性能问题的三种可能情况，实际上出现最多的是前两种，即：索引没设计好和语句没写好。而这两种情况，恰恰是完全可以避免的。比如，通过下面这个过程，我们就可以预先发现问题。</p>
<ol>
<li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把long_query_time设置成0，确保每个语句都会被记录入慢查询日志；</li>
<li>在测试表里插入模拟线上的数据，做一遍回归测试；</li>
<li>观察慢查询日志里每类语句的输出，特别留意Rows_examined字段是否与预期一致。（我们在前面文章中已经多次用到过Rows_examined方法了，相信你已经动手尝试过了。如果还有不明白的，欢迎给我留言，我们一起讨论）。</li>
</ol>
<p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障复盘的时间。</p>
<p>如果新增的SQL语句不多，手动跑一下就可以。而如果是新项目的话，或者是修改了原有项目的 表结构设计，全量回归测试都是必要的。这时候，你需要工具帮你检查所有的SQL语句的返回结果。比如，你可以使用开源工具pt-query-digest(<a href="https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html">https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html</a>)。</p>
<h1 id="QPS突增问题"><a href="#QPS突增问题" class="headerlink" title="QPS突增问题"></a>QPS突增问题</h1><p>有时候由于业务突然出现高峰，或者应用程序bug，导致某个语句的QPS突然暴涨，也可能导致MySQL压力过大，影响服务。</p>
<p>我之前碰到过一类情况，是由一个新功能的bug导致的。当然，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。</p>
<p>而下掉一个功能，如果从数据库端处理的话，对应于不同的背景，有不同的方法可用。我这里再和你展开说明一下。</p>
<ol>
<li>一种是由全新业务的bug导致的。假设你的DB运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li>
<li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的QPS就会变成0。</li>
<li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的SQL语句直接重写成”select 1”返回。</li>
</ol>
<p>当然，这个操作的风险很高，需要你特别细致。它可能存在两个副作用：</p>
<ol>
<li>如果别的功能里面也用到了这个SQL语句模板，会有误伤；</li>
<li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以select 1的结果返回的话，可能会导致后面的业务逻辑一起失败。</li>
</ol>
<p>所以，方案3是用于止血的，跟前面提到的去掉权限验证一样，应该是你所有选项里优先级最低的一个方案。</p>
<p>同时你会发现，其实方案1和2都要依赖于规范的运维体系：虚拟化、白名单机制、业务账号分离。由此可见，更多的准备，往往意味着更稳定的系统。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我以业务高峰期的性能问题为背景，和你介绍了一些紧急处理的手段。</p>
<p>这些处理手段中，既包括了粗暴地拒绝连接和断开连接，也有通过重写语句来绕过一些坑的方法；既有临时的高危方案，也有未雨绸缪的、相对安全的预案。</p>
<p>在实际开发中，我们也要尽量避免一些低效的方法，比如避免大量地使用短连接。同时，如果你做业务开发的话，要知道，连接异常断开是常有的事，你的代码里要有正确地重连并重试的机制。</p>
<p>DBA虽然可以通过语句重写来暂时处理问题，但是这本身是一个风险高的操作，做好SQL审计可以减少需要这类操作的机会。</p>
<p>其实，你可以看得出来，在这篇文章中我提到的解决方法主要集中在server层。在下一篇文章中，我会继续和你讨论一些跟InnoDB有关的处理方法。</p>
<p>最后，又到了我们的思考题时间了。</p>
<p>今天，我留给你的课后问题是，你是否碰到过，在业务高峰期需要临时救火的场景？你又是怎么处理的呢？</p>
<p>你可以把你的经历和经验写在留言区，我会在下一篇文章的末尾选取有趣的评论跟大家一起分享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>前两期我给你留的问题是，下面这个图的执行序列中，为什么session B的insert语句会被堵住。</p>
<p><img src="https://static001.geekbang.org/resource/image/3a/1e/3a7578e104612a188a2d574eaa3bd81e.png"><br>我们用上一篇的加锁规则来分析一下，看看session A的select语句加了哪些锁：</p>
<ol>
<li>由于是order by c desc，第一个要定位的是索引c上“最右边的”c&#x3D;20的行，所以会加上间隙锁(20,25)和next-key lock (15,20]。</li>
<li>在索引c上向左遍历，要扫描到c&#x3D;10才停下来，所以next-key lock会加到(5,10]，这正是阻塞session B的insert语句的原因。</li>
<li>在扫描过程中，c&#x3D;20、c&#x3D;15、c&#x3D;10这三行都存在值，由于是select *，所以会在主键id上加三个行锁。</li>
</ol>
<p>因此，session A 的select语句锁的范围就是：</p>
<ol>
<li>索引c上 (5, 25)；</li>
<li>主键索引上id&#x3D;10、15、20三个行锁。</li>
</ol>
<p>这里，我再啰嗦下，你会发现我在文章中，每次加锁都会说明是加在“哪个索引上”的。因为，锁就是加在索引上的，这是InnoDB的一个基础设定，需要你在分析问题的时候要一直记得。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@HuaMax 给出了正确的解释。</p>
</blockquote>
<blockquote>
<p>@Justin 同学提了个好问题，&lt;&#x3D;到底是间隙锁还是行锁？其实，这个问题，你要跟“执行过程”配合起来分析。在InnoDB要去找“第一个值”的时候，是按照等值去找的，用的是等值判断的规则；找到第一个值以后，要在索引内找“下一个值”，对应于我们规则中说的范围查找。</p>
</blockquote>
<blockquote>
<p>@信信 提了一个不错的问题，要知道最终的加锁是根据实际执行情况来的。所以，如果一个select * from … for update 语句，优化器决定使用全表扫描，那么就会把主键索引上next-key lock全加上。</p>
</blockquote>
<blockquote>
<p>@nero 同学的问题，提示我需要提醒大家注意，“有行”才会加行锁。如果查询条件没有命中行，那就加next-key lock。当然，等值判断的时候，需要加上优化2（即：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。）。</p>
</blockquote>
<blockquote>
<p>@小李子、@发条橙子同学，都提了很好的问题，这期高质量评论很多，你也都可以去看看。</p>
</blockquote>
<p>最后，我要为元旦期间还坚持学习的同学们，点个赞 ^_^</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>16 | “orderby”是怎么工作的</title>
    <url>/posts/1d189ae5.html</url>
    <content><![CDATA[<p>在你开发应用的时候，一定会经常碰到需要根据指定的字段排序来显示结果的需求。还是以我们前面举例用过的市民表为例，假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前1000个人的姓名、年龄。</p>
<span id="more"></span>

<p>假设这个表的部分定义是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>这时，你的SQL语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure>

<p>这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。</p>
<h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><p>前面我们介绍过索引，所以你现在就很清楚了，为避免全表扫描，我们需要在city字段加上索引。</p>
<p>在city字段上创建索引之后，我们用explain命令来看看这个语句的执行情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 使用explain命令查看语句的执行情况</b>
    </div>
    <br>
</center>

<p>Extra这个字段中的“Using filesort”表示的就是需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p>
<p>为了说明这个SQL查询语句的执行过程，我们先来看一下city这个索引的示意图。</p>
<p><img src="https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 city字段的索引示意图</b>
    </div>
    <br>
</center>

<p>从图中可以看到，满足city&#x3D;’杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。</p>
<p>通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age这三个字段；</li>
<li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name做快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<p>我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，下一篇文章中我们还会用到这个排序。</p>
<p><img src="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 全字段排序</b>
    </div>
    <br>
</center>

<p>图中“按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size。</p>
<p>sort_buffer_size，就是MySQL为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<p>你可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p>
<p><img src="https://static001.geekbang.org/resource/image/89/95/89baf99cdeefe90a22370e1d6f5e6495.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 全排序的OPTIMIZER_TRACE部分结果</b>
    </div>
    <br>
</center>

<p>number_of_tmp_files表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要12个文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</strong></p>
<p>如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，表示排序可以直接在内存中完成。</p>
<p>否则就需要放在临时文件中排序。sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。</p>
<p>接下来，我再和你解释一下图4中其他两个值的意思。</p>
<p>我们的示例表中有4000条满足city&#x3D;’杭州’的记录，所以你可以看到 examined_rows&#x3D;4000，表示参与排序的行数是4000行。</p>
<p>sort_mode 里面的packed_additional_fields的意思是，排序过程对字符串做了“紧凑”处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</p>
<p>同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。</p>
<p>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会显示为4001。</p>
<p>这是因为查询OPTIMIZER_TRACE这个表时，需要用到临时表，而internal_tmp_disk_storage_engine的默认值是InnoDB。如果使用的是InnoDB引擎的话，把数据从临时表取出来的时候，会让Innodb_rows_read的值加1。</p>
<h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p>所以如果单行很大，这个方法效率不够好。</p>
<p>那么，<strong>如果MySQL认为排序的单行长度太大会怎么做呢？</strong></p>
<p>接下来，我来修改一个参数，让MySQL采用另外一种算法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>max_length_for_sort_data，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</p>
<p>city、name、age 这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，我们再来看看计算过程有什么改变。</p>
<p>新的算法放入sort_buffer的字段，只有要排序的列（即name字段）和主键id。</p>
<p>但这时，排序的结果就因为少了city和age字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id；</li>
<li>从索引city找到第一个满足city&#x3D;’杭州’条件的主键id，也就是图中的ID_X；</li>
<li>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到不满足city&#x3D;’杭州’条件为止，也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name进行排序；</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表中取出city、name和age三个字段返回给客户端。</li>
</ol>
<p>这个执行流程的示意图如下，我把它称为rowid排序。</p>
<p><img src="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 rowid排序</b>
    </div>
    <br>
</center>

<p>对比图3的全字段排序流程图你会发现，rowid排序多访问了一次表t的主键索引，就是步骤7。</p>
<p>需要说明的是，最后的“结果集”是一个逻辑概念，实际上MySQL服务端从排序后的sort_buffer中依次取出id，然后到原表查到city、name和age这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p>
<p>根据这个说明过程和图示，你可以想一下，这个时候执行select @b-@a，结果会是多少呢？</p>
<p>现在，我们就来看看结果有什么不同。</p>
<p>首先，图中的examined_rows的值还是4000，表示用于排序的数据是4000行。但是select @b-@a这个语句的值变成5000了。</p>
<p>因为这时候除了排序过程外，在排序完成后，还要根据id去原表取值。由于语句是limit 1000，因此会多读1000行。</p>
<p><img src="https://static001.geekbang.org/resource/image/27/9b/27f164804d1a4689718291be5d10f89b.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 rowid排序的OPTIMIZER_TRACE部分输出</b>
    </div>
    <br>
</center>

<p>从OPTIMIZER_TRACE的结果中，你还能看到另外两个信息也变了。</p>
<ul>
<li>sort_mode变成了&lt;sort_key, rowid&gt;，表示参与排序的只有name和id这两个字段。</li>
<li>number_of_tmp_files变成10了，是因为这时候参与排序的行数虽然仍然是4000行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li>
</ul>
<h1 id="全字段排序-VS-rowid排序"><a href="#全字段排序-VS-rowid排序" class="headerlink" title="全字段排序 VS rowid排序"></a>全字段排序 VS rowid排序</h1><p>我们来分析一下，从这两个执行流程里，还能得出什么结论。</p>
<p>如果MySQL实在是担心排序内存太小，会影响排序效率，才会采用rowid排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>
<p>如果MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到sort_buffer中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>
<p>这也就体现了MySQL的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<p>对于InnoDB表来说，rowid排序会要求回表多造成磁盘读，因此不会被优先选择。</p>
<p>这个结论看上去有点废话的感觉，但是你要记住它，下一篇文章我们就会用到。</p>
<p>看到这里，你就了解了，MySQL做排序是一个成本比较高的操作。那么你会问，是不是所有的order by都需要排序操作呢？如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p>
<p>其实，并不是所有的order by语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的。</strong></p>
<p>你可以设想下，如果能够保证从city这个索引上取出来的行，天然就是按照name递增排序的话，是不是就可以不用再排序了呢？</p>
<p>确实是这样的。</p>
<p>所以，我们可以在这个市民表上创建一个city和name的联合索引，对应的SQL语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user(city, name);</span><br></pre></td></tr></table></figure>

<p>作为与city索引的对比，我们来看看这个索引的示意图。</p>
<p><img src="https://static001.geekbang.org/resource/image/f9/bf/f980201372b676893647fb17fac4e2bf.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 city和name联合索引示意图</b>
    </div>
    <br>
</center>

<p>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足city&#x3D;’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要city的值是杭州，name的值就一定是有序的。</p>
<p>这样整个查询过程的流程就变成了：</p>
<ol>
<li>从索引(city,name)找到第一个满足city&#x3D;’杭州’条件的主键id；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name)取下一个记录主键id；</li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/3f/92/3f590c3a14f9236f2d8e1e2cb9686692.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 引入(city,name)联合索引后，查询语句的执行计划</b>
    </div>
    <br>
</center>

<p>可以看到，这个查询过程不需要临时表，也不需要排序。接下来，我们用explain的结果来印证一下。</p>
<p><img src="https://static001.geekbang.org/resource/image/fc/8a/fc53de303811ba3c46d344595743358a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 引入(city,name)联合索引后，查询语句的执行计划</b>
    </div>
    <br>
</center>

<p>从图中可以看到，Extra字段中没有Using filesort了，也就是不需要排序了。而且由于(city,name)这个联合索引本身有序，所以这个查询也不用把4000行全都读一遍，只要找到满足条件的前1000条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描1000次。</p>
<p>既然说到这里了，我们再往前讨论，<strong>这个语句的执行流程有没有可能进一步简化呢？</strong>不知道你还记不记得，我在第5篇文章<a href="https://time.geekbang.org/column/article/69636">《 深入浅出索引（下）》</a>中，和你介绍的覆盖索引。</p>
<p>这里我们可以再稍微复习一下。<strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p>
<p>按照覆盖索引的概念，我们可以再优化一下这个查询语句的执行流程。</p>
<p>针对这个查询，我们可以创建一个city、name和age的联合索引，对应的SQL语句就是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure>

<p>这时，对于city字段的值相同的行来说，还是按照name字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引(city,name,age)找到第一个满足city&#x3D;’杭州’条件的记录，取出其中的city、name和age这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name,age)取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city&#x3D;’杭州’条件时循环结束。</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/df/d6/df4b8e445a59c53df1f2e0f115f02cd6.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图10 引入(city,name,age)联合索引后，查询语句的执行流程</b>
    </div>
    <br>
</center>

<p>然后，我们再来看看explain的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/9e/23/9e40b7b8f0e3f81126a9171cc22e3423.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图11 引入(city,name,age)联合索引后，查询语句的执行计划</b>
    </div>
    <br>
</center>

<p>可以看到，Extra字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p>
<p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要权衡的决定。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你介绍了MySQL里面order by语句的几种算法流程。</p>
<p>在开发系统的时候，你总是不可避免地会使用到order by语句。你心里要清楚每个语句的排序逻辑是怎么实现的，还要能够分析出在最坏情况下，每个语句的执行对系统资源的消耗，这样才能做到下笔如有神，不犯低级错误。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>假设你的表里面已经有了city_name(city, name)这个联合索引，然后你要查杭州和苏州两个城市中所有的市民的姓名，并且按名字排序，显示前100条记录。如果SQL查询语句是这么写的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city <span class="keyword">in</span> (<span class="string">&#x27;杭州&#x27;</span>,&quot;苏州&quot;) <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>那么，这个语句执行的时候会有排序过程吗，为什么？</p>
<p>如果业务端代码由你来开发，需要实现一个在数据库端不需要排序的方案，你会怎么实现呢？</p>
<p>进一步地，如果有分页需求，要显示第101页，也就是说语句最后要改成 “limit 10000,100”， 你的实现方法又会是什么呢？</p>
<p>你可以把你的思考和观点写在留言区里，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，当MySQL去更新一行，但是要修改的值跟原来的值是相同的，这时候MySQL会真的去执行一次修改吗？还是看到值相同就直接返回呢？</p>
<p>这是第一次我们课后问题的三个选项都有同学选的，所以我要和你需要详细说明一下。</p>
<p>第一个选项是，MySQL读出数据，发现值与原来相同，不更新，直接返回，执行结束。这里我们可以用一个锁实验来确认。</p>
<p>假设，当前表t里的值是(1,2)。</p>
<p><img src="https://static001.geekbang.org/resource/image/6d/90/6d9d8837560d01b57d252c470157ea90.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图12 锁验证方式</b>
    </div>
    <br>
</center>

<p>session B的update 语句被blocked了，加锁这个动作是InnoDB才能做的，所以排除选项1。</p>
<p>第二个选项是，MySQL调用了InnoDB引擎提供的接口，但是引擎发现值与原来相同，不更新，直接返回。有没有这种可能呢？这里我用一个可见性实验来确认。</p>
<p>假设当前表里的值是(1,2)。</p>
<p><img src="https://static001.geekbang.org/resource/image/44/96/441682b64a3f5dd50f35b12ca4b87c96.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图13 可见性验证方式</b>
    </div>
    <br>
</center>

<p>session A的第二个select 语句是一致性读（快照读)，它是不能看见session B的更新的。</p>
<p>现在它返回的是(1,3)，表示它看见了某个新的版本，这个版本只能是session A自己的update语句做更新的时候生成。（如果你对这个逻辑有疑惑的话，可以回顾下第8篇文章<a href="https://time.geekbang.org/column/article/70562">《事务到底是隔离的还是不隔离的？》</a>中的相关内容）</p>
<p>所以，我们上期思考题的答案应该是选项3，即：InnoDB认真执行了“把这个值修改成(1,2)”这个操作，该加锁的加锁，该更新的更新。</p>
<p>然后你会说，MySQL怎么这么笨，就不会更新前判断一下值是不是相同吗？如果判断一下，不就不用浪费InnoDB操作，多去更新一次了？</p>
<p>其实MySQL是确认了的。只是在这个语句里面，MySQL认为读出来的值，只有一个确定的 (id&#x3D;1), 而要写的是(a&#x3D;3)，只从这两个信息是看不出来“不需要修改”的。</p>
<p>作为验证，你可以看一下下面这个例子。</p>
<p><img src="https://static001.geekbang.org/resource/image/63/c1/63dd6df32dacdb827d256e5acb9837c1.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图14 可见性验证方式--对照</b>
    </div>
    <br>
</center>

<p><strong>补充说明：</strong></p>
<p>上面我们的验证结果都是在binlog_format&#x3D;statement格式下进行的。</p>
<p>@didiren 补充了一个case， 如果是binlog_format&#x3D;row 并且binlog_row_image&#x3D;FULL的时候，由于MySQL需要在binlog里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来了。</p>
<p>根据上面说的规则，“既然读了数据，就会判断”， 因此在这时候，select * from t where id&#x3D;1，结果就是“返回 (1,2)”。</p>
<p>同理，如果是binlog_row_image&#x3D;NOBLOB, 会读出除blob 外的所有字段，在我们这个例子里，结果还是“返回 (1,2)”。</p>
<p>对应的代码如图15所示。这是MySQL 5.6版本引入的，在此之前我没有看过。所以，特此说明。</p>
<p><img src="https://static001.geekbang.org/resource/image/d4/89/d413b9235d56c62f9829750a68b06b89.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图15 binlog_row_image=FULL读字段逻辑</b>
    </div>
    <br>
</center>

<p>类似的，@mahonebags 同学提到了timestamp字段的问题。结论是：如果表中有timestamp字段而且设置了自动更新的话，那么更新“别的字段”的时候，MySQL会读入所有涉及的字段，这样通过判断，就会发现不需要修改。</p>
<p>这两个点我会在后面讲更新性能的文章中再展开。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@Gavin 、@melon、@阿建 等同学提到了锁验证法；<br>@郭江伟 同学提到了两个点，都非常好，有去实际验证。结论是这样的：<br>第一，hexdump看出来没改应该是WAL机制生效了，要过一会儿，或者把库shutdown看看。<br>第二，binlog没写是MySQL Server层知道行的值没变，所以故意不写的，这个是在row格式下的策略。你可以把binlog_format 改成statement再验证下。</p>
</blockquote>
<p><strong>(1)无条件查询如果只有order by create_time,即便create_time上有索引,也不会使用到。</strong><br>因为优化器认为走二级索引再去回表成本比全表扫描排序更高。<br>所以选择走全表扫描,然后根据老师讲的两种方式选择一种来排序</p>
<p><strong>(2)无条件查询但是是order by create_time limit m.如果m值较小,是可以走索引的.</strong><br>因为优化器认为根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比全表扫描小,则选择走二级索引。<br>即便没有二级索引,mysql针对order by limit也做了优化,采用堆排序。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>21 | 为什么我只改一行的语句，锁这么多</title>
    <url>/posts/19432f99.html</url>
    <content><![CDATA[<p>在上一篇文章中，我和你介绍了间隙锁和next-key lock的概念，但是并没有说明加锁规则。间隙锁的概念理解起来确实有点儿难，尤其在配合上行锁以后，很容易在判断是否会出现锁等待的问题上犯错。</p>
<span id="more"></span>

<p>所以今天，我们就先从这个加锁规则开始吧。</p>
<p>首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，<strong>这个规则有以下两条前提说明：</strong></p>
<ol>
<li>MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即5.x系列&lt;&#x3D;5.7.24，8.0系列 &lt;&#x3D;8.0.13。</li>
<li>如果大家在验证中有发现bad case的话，请提出来，我会再补充进这篇文章，使得一起学习本专栏的所有同学都能受益。</li>
</ol>
<p>因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。</p>
<p><strong>我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol>
<li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p>我还是以上篇文章的表t为例，和你解释一下这些规则。表t的建表语句和初始化语句如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>接下来的例子基本都是配合着图片说明的，所以我建议你可以对照着文稿看，有些例子可能会“毁三观”，也建议你读完文章后亲手实践一下。</p>
<h1 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h1><p>第一个例子是关于等值条件操作间隙：</p>
<p><img src="https://static001.geekbang.org/resource/image/58/6c/585dfa8d0dd71171a6fa16bed4ba816c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 等值查询的间隙锁</b>
    </div>
    <br>
</center>

<p>由于表t中没有id&#x3D;7的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<ol>
<li>根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</li>
<li>同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</li>
</ol>
<p>所以，session B要往这个间隙里面插入id&#x3D;8的记录会被锁住，但是session C修改id&#x3D;10这行是可以的。</p>
<h1 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h1><p>第二个例子是关于覆盖索引上的锁：</p>
<p><img src="https://static001.geekbang.org/resource/image/46/65/465990fe8f6b418ca3f9992bd1bb5465.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 只加在非唯一索引上的锁</b>
    </div>
    <br>
</center>

<p>看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。</p>
<p>这里session A要给索引c上c&#x3D;5的这一行加上读锁。</p>
<ol>
<li>根据原则1，加锁单位是next-key lock，因此会给(0,5]加上next-key lock。</li>
<li>要注意c是普通索引，因此仅访问c&#x3D;5这一条记录是不能马上停下来的，需要向右遍历，查到c&#x3D;10才放弃。根据原则2，访问到的都要加锁，因此要给(5,10]加next-key lock。</li>
<li>但是同时这个符合优化2：等值判断，向右遍历，最后一个值不满足c&#x3D;5这个等值条件，因此退化成间隙锁(5,10)。</li>
<li>根据原则2 ，<strong>只有访问到的对象才会加锁</strong>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么session B的update语句可以执行完成。</li>
</ol>
<p>但session C要插入一个(7,7,7)的记录，就会被session A的间隙锁(5,10)锁住。</p>
<p>需要注意，在这个例子中，lock in share mode只锁覆盖索引，但是如果是for update就不一样了。 执行 for update时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
<p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将session A的查询语句改成select d from t where c&#x3D;5 lock in share mode。你可以自己验证一下效果。</p>
<h1 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h1><p>第三个例子是关于范围查询的。</p>
<p>举例之前，你可以先思考一下这个问题：对于我们这个表t，下面这两条查询语句，加锁范围相同吗？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>你可能会想，id定义为int类型，这两个语句就是等价的吧？其实，它们并不完全等价。</p>
<p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让session A执行第二个查询语句，来看看加锁效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/30/80/30b839bf941f109b04f1a36c302aea80.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 主键索引上范围查询的锁</b>
    </div>
    <br>
</center>

<p>现在我们就用前面提到的加锁规则，来分析一下session A 会加什么锁呢？</p>
<ol>
<li>开始执行的时候，要找到第一个id&#x3D;10的行，因此本该是next-key lock(5,10]。 根据优化1， 主键id上的等值条件，退化成行锁，只加了id&#x3D;10这一行的行锁。</li>
<li>范围查找就往后继续找，找到id&#x3D;15这一行停下来，因此需要加next-key lock(10,15]。</li>
</ol>
<p>所以，session A这时候锁的范围就是主键索引上，行锁id&#x3D;10和next-key lock(10,15]。这样，session B和session C的结果你就能理解了。</p>
<p>这里你需要注意一点，首次session A定位查找id&#x3D;10的行的时候，是当做等值查询来判断的，而向右扫描到id&#x3D;15的时候，用的是范围查询判断。</p>
<h1 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h1><p>接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。</p>
<p>需要注意的是，与案例三不同的是，案例四中查询语句的where部分用的是字段c。</p>
<p><img src="https://static001.geekbang.org/resource/image/73/7a/7381475e9e951628c9fc907f5a57697a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 非唯一索引范围锁</b>
    </div>
    <br>
</center>

<p>这次session A用字段c来判断，加锁规则跟案例三唯一的不同是：在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p>
<p>所以从结果上来看，sesson B要插入（8,8,8)的这个insert语句时就被堵住了。</p>
<p>这里需要扫描到c&#x3D;15才停止扫描，是合理的，因为InnoDB要扫到c&#x3D;15，才知道不需要继续往后找了。</p>
<h1 id="案例五：唯一索引范围锁bug"><a href="#案例五：唯一索引范围锁bug" class="headerlink" title="案例五：唯一索引范围锁bug"></a>案例五：唯一索引范围锁bug</h1><p>前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中bug的案例。</p>
<p><img src="https://static001.geekbang.org/resource/image/b1/6d/b105f8c4633e8d3a84e6422b1b1a316d.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 唯一索引范围锁的bug</b>
    </div>
    <br>
</center>

<p>session A是一个范围查询，按照原则1的话，应该是索引id上只加(10,15]这个next-key lock，并且因为id是唯一键，所以循环判断到id&#x3D;15这一行就应该停止了。</p>
<p>但是实现上，InnoDB会往前扫描到第一个不满足条件的行为止，也就是id&#x3D;20。而且由于这是个范围扫描，因此索引id上的(15,20]这个next-key lock也会被锁上。</p>
<p>所以你看到了，session B要更新id&#x3D;20这一行，是会被锁住的。同样地，session C要插入id&#x3D;16的一行，也会被锁住。</p>
<p>照理说，这里锁住id&#x3D;20这一行的行为，其实是没有必要的。因为扫描到id&#x3D;15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个bug。</p>
<p>我也曾找社区的专家讨论过，官方bug系统上也有提到，但是并未被verified。所以，认为这是bug这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。</p>
<h1 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h1><p>接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表t插入一条新记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>新插入的这一行c&#x3D;10，也就是说现在表里有两个c&#x3D;10的行。那么，这时候索引c上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。</p>
<p><img src="https://static001.geekbang.org/resource/image/c1/59/c1fda36c1502606eb5be3908011ba159.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 非唯一索引等值的例子</b>
    </div>
    <br>
</center>

<p>可以看到，虽然有两个c&#x3D;10，但是它们的主键值id是不同的（分别是10和30），因此这两个c&#x3D;10的记录之间，也是有间隙的。</p>
<p>图中我画出了索引c上的主键id。为了跟间隙锁的开区间形式进行区别，我用(c&#x3D;10,id&#x3D;30)这样的形式，来表示索引上的一行。</p>
<p>现在，我们来看一下案例六。</p>
<p>这次我们用delete语句来验证。注意，delete语句加锁的逻辑，其实跟select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p>
<p><img src="https://static001.geekbang.org/resource/image/b5/78/b55fb0a1cac3500b60e1cf9779d2da78.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 delete 示例</b>
    </div>
    <br>
</center>

<p>这时，session A在遍历的时候，先访问第一个c&#x3D;10的记录。同样地，根据原则1，这里加的是(c&#x3D;5,id&#x3D;5)到(c&#x3D;10,id&#x3D;10)这个next-key lock。</p>
<p>然后，session A向右查找，直到碰到(c&#x3D;15,id&#x3D;15)这一行，循环才结束。根据优化2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成(c&#x3D;10,id&#x3D;10) 到 (c&#x3D;15,id&#x3D;15)的间隙锁。</p>
<p>也就是说，这个delete语句在索引c上的加锁范围，就是下图中蓝色区域覆盖的部分。<br><img src="https://static001.geekbang.org/resource/image/bb/24/bb0ad92483d71f0dcaeeef278f89cb24.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 delete加锁效果示例</b>
    </div>
    <br>
</center>

<p>这个蓝色区域左右两边都是虚线，表示开区间，即(c&#x3D;5,id&#x3D;5)和(c&#x3D;15,id&#x3D;15)这两行上都没有锁。</p>
<h1 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h1><p>例子6也有一个对照案例，场景如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/af/2e/afc3a08ae7a254b3251e41b2a6dae02e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 limit 语句加锁</b>
    </div>
    <br>
</center>

<p>这个例子里，session A的delete语句加了 limit 2。你知道表t里c&#x3D;10的记录其实只有两条，因此加不加limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B的insert语句执行通过了，跟案例六的结果不同。</p>
<p>这是因为，案例七里的delete语句明确加了limit 2的限制，因此在遍历到(c&#x3D;10, id&#x3D;30)这一行之后，满足条件的语句已经有两条，循环就结束了。</p>
<p>因此，索引c上的加锁范围就变成了从（c&#x3D;5,id&#x3D;5)到（c&#x3D;10,id&#x3D;30)这个前开后闭区间，如下图所示：<br><img src="https://static001.geekbang.org/resource/image/e5/d5/e5408ed94b3d44985073255db63bd0d5.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图10 带limit 2的加锁效果</b>
    </div>
    <br>
</center>

<p>可以看到，(c&#x3D;10,id&#x3D;30）之后的这个间隙并没有在加锁范围里，因此insert语句插入c&#x3D;12是可以执行成功的。</p>
<p>这个例子对我们实践的指导意义就是，<strong>在删除数据的时候尽量加limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h1 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h1><p>前面的例子中，我们在分析的时候，是按照next-key lock的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock实际上是间隙锁和行锁加起来的结果。</p>
<p>你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：</p>
<p><img src="https://static001.geekbang.org/resource/image/7b/06/7b911a4c995706e8aa2dd96ff0f36506.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图11 案例八的操作序列</b>
    </div>
    <br>
</center>

<p>现在，我们按时间顺序来分析一下为什么是这样的结果。</p>
<ol>
<li>session A 启动事务后执行查询语句加lock in share mode，在索引c上加了next-key lock(5,10] 和间隙锁(10,15)；</li>
<li>session B 的update语句也要在索引c上加next-key lock(5,10] ，进入锁等待；</li>
<li>然后session A要再插入(8,8,8)这一行，被session B的间隙锁锁住。由于出现了死锁，InnoDB让session B回滚。</li>
</ol>
<p>你可能会问，session B的next-key lock不是还没申请成功吗？</p>
<p>其实是这样的，session B的“加next-key lock(5,10] ”操作，实际上分成了两步，先是加(5,10)的间隙锁，加锁成功；然后加c&#x3D;10的行锁，这时候才被锁住的。</p>
<p>也就是说，我们在分析加锁规则的时候可以用next-key lock来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这里我再次说明一下，我们上面的所有案例都是在可重复读隔离级别(repeatable-read)下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。</p>
<p>在最后的案例中，你可以清楚地知道next-key lock实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别(read-committed)的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。</p>
<p>其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。</p>
<p>另外，在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。</p>
<p>也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。</p>
<p>不过，我希望你学过今天的课程以后，可以对next-key lock的概念有更清晰的认识，并且会用加锁规则去判断语句的加锁范围。</p>
<p>在业务需要使用可重复读隔离级别的时候，能够更细致地设计操作数据库的语句，解决幻读问题的同时，最大限度地提升系统并行处理事务的能力。</p>
<p>经过这篇文章的介绍，你再看一下上一篇文章最后的思考题，再来尝试分析一次。</p>
<p>我把题目重新描述和简化一下：还是我们在文章开头初始化的表t，里面有6条记录，图12的语句序列中，为什么session B的insert操作，会被锁住呢？<br><img src="https://static001.geekbang.org/resource/image/3a/1e/3a7578e104612a188a2d574eaa3bd81e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图12 锁分析思考题</b>
    </div>
    <br>
</center>

<p>另外，如果你有兴趣多做一些实验的话，可以设计好语句序列，在执行之前先自己分析一下，然后实际地验证结果是否跟你的分析一致。</p>
<p>对于那些你自己无法解释的结果，可以发到评论区里，后面我争取挑一些有趣的案例在文章中分析。</p>
<p>你可以把你关于思考题的分析写在留言区，也可以分享你自己设计的锁验证方案，我会在下一篇文章的末尾选取有趣的评论跟大家分享。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h2 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h2><p>上期的问题，我在本期继续作为了课后思考题，所以会在下篇文章再一起公布“答案”。</p>
<p>这里，我展开回答一下评论区几位同学的问题。</p>
<ul>
<li>@令狐少侠 说，以前一直认为间隙锁只在二级索引上有。现在你知道了，有间隙的地方就可能有间隙锁。</li>
<li>@浪里白条 同学问，如果是varchar类型，加锁规则是什么样的。<br>回答：实际上在判断间隙的时候，varchar和int是一样的，排好序以后，相邻两个值之间就有间隙。</li>
<li>有几位同学提到说，上一篇文章自己验证的结果跟案例一不同，就是在session A执行完这两个语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">/*Q1*/</span></span><br></pre></td></tr></table></figure>

<p>以后，session B 的update 和session C的insert 都会被堵住。这是不是跟文章的结论矛盾？</p>
<p>其实不是的，这个例子用的是反证假设，就是假设不堵住，会出现问题；然后，推导出session A需要锁整个表所有的行和所有间隙。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>23 | MySQL是怎么保证数据不丢的</title>
    <url>/posts/da0b9032.html</url>
    <content><![CDATA[<p>今天这篇文章，我会继续和你介绍在业务高峰期临时提升性能的方法。从文章标题“MySQL是怎么保证数据不丢的？”，你就可以看出来，今天我和你介绍的方法，跟数据的可靠性有关。</p>
<span id="more"></span>

<p>在专栏前面文章和答疑篇中，我都着重介绍了WAL机制（你可以再回顾下<a href="https://time.geekbang.org/column/article/68633">第2篇</a>、<a href="https://time.geekbang.org/column/article/70848">第9篇</a>、<a href="https://time.geekbang.org/column/article/71806">第12篇</a>和<a href="https://time.geekbang.org/column/article/73161">第15篇</a>文章中的相关内容），得到的结论是：只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。</p>
<p>评论区有同学又继续追问，redo log的写入流程是怎么样的，如何保证redo log真实地写入了磁盘。那么今天，我们就再一起看看MySQL写入binlog和redo log的流程。</p>
<h1 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h1><p>其实，binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<p>一个事务的binlog是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了binlog cache的保存问题。</p>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数 binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中，并清空binlog cache。状态如图1所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 binlog写盘状态</b>
    </div>
    <br>
</center>

<p>可以看到，每个线程有自己binlog cache，但是共用同一份binlog文件。</p>
<ul>
<li>图中的write，指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占磁盘的IOPS。</li>
</ul>
<p>write 和fsync的时机，是由参数sync_binlog控制的：</p>
<ol>
<li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li>
<li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li>
<li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li>
</ol>
<p>因此，在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成0，比较常见的是将其设置为100~1000中的某个数值。</p>
<p>但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p>
<h1 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h1><p>接下来，我们再说说redo log的写入机制。</p>
<p>在专栏的<a href="https://time.geekbang.org/column/article/73161">第15篇答疑文章</a>中，我给你介绍了redo log buffer。事务在执行过程中，生成的redo log是要先写到redo log buffer的。</p>
<p>然后就有同学问了，redo log buffer里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p>
<p>答案是，不需要。</p>
<p>如果事务执行期间MySQL发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p>
<p>那么，另外一个问题是，事务还没提交的时候，redo log buffer中的部分日志有没有可能被持久化到磁盘呢？</p>
<p>答案是，确实会有。</p>
<p>这个问题，要从redo log可能存在的三种状态说起。这三种状态，对应的就是图2 中的三个颜色块。</p>
<p><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 MySQL redo log存储状态</b>
    </div>
    <br>
</center>

<p>这三种状态分别是：</p>
<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，就是图中的红色部分；</li>
<li>写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面，也就是图中的黄色部分；</li>
<li>持久化到磁盘，对应的是hard disk，也就是图中的绿色部分。</li>
</ol>
<p>日志写到redo log buffer是很快的，wirte到page cache也差不多，但是持久化到磁盘的速度就慢多了。</p>
<p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，它有三种可能取值：</p>
<ol>
<li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li>
<li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li>
<li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li>
</ol>
<p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p>
<p>注意，事务执行中间过程的redo log也是直接写在redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p>
<p>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中。</p>
<ol>
<li><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>注意，由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，也就是只留在了文件系统的page cache。</li>
<li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>假设一个事务A执行到一半，已经写了一些redo log到buffer中，这时候有另外一个线程的事务B提交，如果innodb_flush_log_at_trx_commit设置的是1，那么按照这个参数的逻辑，事务B要把redo log buffer里的日志全部持久化到磁盘。这时候，就会带上事务A在redo log buffer里的日志一起持久化到磁盘。</li>
</ol>
<p>这里需要说明的是，我们介绍两阶段提交的时候说过，时序上redo log先prepare， 再写binlog，最后再把redo log commit。</p>
<p>如果把innodb_flush_log_at_trx_commit设置成1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于prepare 的redo log，再加上binlog来恢复的。（如果你印象有点儿模糊了，可以再回顾下<a href="https://time.geekbang.org/column/article/73161">第15篇文章</a>中的相关内容）。</p>
<p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p>
<p>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p>
<p>这时候，你可能有一个疑问，这意味着我从MySQL看到的TPS是每秒两万的话，每秒就会写四万次磁盘。但是，我用工具测试出来，磁盘能力也就两万左右，怎么能实现两万的TPS？</p>
<p>解释这个问题，就要用到组提交（group commit）机制了。</p>
<p>这里，我需要先和你介绍日志逻辑序列号（log sequence number，LSN）的概念。LSN是单调递增的，用来对应redo log的一个个写入点。每次写入长度为length的redo log， LSN的值就会加上length。</p>
<p>LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。关于LSN和redo log、checkpoint的关系，我会在后面的文章中详细展开。</p>
<p>如图3所示，是三个并发事务(trx1, trx2, trx3)在prepare 阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120 和160。</p>
<p><img src="https://static001.geekbang.org/resource/image/93/cc/933fdc052c6339de2aa3bf3f65b188cc.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 redo log 组提交</b>
    </div>
    <br>
</center>

<p>从图中可以看到，</p>
<ol>
<li>trx1是第一个到达的，会被选为这组的 leader；</li>
<li>等trx1要开始写盘的时候，这个组里面已经有了三个事务，这时候LSN也变成了160；</li>
<li>trx1去写盘的时候，带的就是LSN&#x3D;160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li>
<li>这时候trx2和trx3就可以直接返回了。</li>
</ol>
<p>所以，一次组提交里面，组员越多，节约磁盘IOPS的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p>
<p>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p>
<p>为了让一次fsync带的组员更多，MySQL有一个很有趣的优化：拖时间。在介绍两阶段提交的时候，我曾经给你画了一个图，现在我把它截过来。</p>
<p><img src="https://static001.geekbang.org/resource/image/98/51/98b3b4ff7b36d6d72e38029b86870551.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 两阶段提交</b>
    </div>
    <br>
</center>

<p>图中，我把“写binlog”当成一个动作。但实际上，写binlog是分成两步的：</p>
<ol>
<li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li>
<li>调用fsync持久化。</li>
</ol>
<p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后。也就是说，上面的图变成了这样：</p>
<p><img src="https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 两阶段提交细化</b>
    </div>
    <br>
</center>

<p>这么一来，binlog也可以组提交了。在执行图5中第4步把binlog fsync到磁盘时，如果有多个事务的binlog已经写完了，也是一起持久化的，这样也可以减少IOPS的消耗。</p>
<p>不过通常情况下第3步执行得会很快，所以binlog的write和fsync间的间隔时间短，导致能集合到一起持久化的binlog比较少，因此binlog的组提交的效果通常不如redo log的效果那么好。</p>
<p>如果你想提升binlog组提交的效果，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count来实现。</p>
<ol>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li>
</ol>
<p>这两个条件是或的关系，也就是说只要有一个满足条件就会调用fsync。</p>
<p>所以，当binlog_group_commit_sync_delay设置为0的时候，binlog_group_commit_sync_no_delay_count也无效了。</p>
<p>之前有同学在评论区问到，WAL机制是减少磁盘写，可是每次提交事务都要写redo log和binlog，这磁盘读写次数也没变少呀？</p>
<p>现在你就能理解了，WAL机制主要得益于两个方面：</p>
<ol>
<li>redo log 和 binlog都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li>
</ol>
<p>分析到这里，我们再来回答这个问题：<strong>如果你的MySQL现在出现了性能瓶颈，而且瓶颈在IO上，可以通过哪些方法来提升性能呢？</strong></p>
<p>针对这个问题，可以考虑以下三种方法：</p>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将sync_binlog 设置为大于1的值（比较常见是100~1000）。这样做的风险是，主机掉电时会丢binlog日志。</li>
<li>将innodb_flush_log_at_trx_commit设置为2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
<p>我不建议你把innodb_flush_log_at_trx_commit 设置成0。因为把这个参数设置成0，表示redo log只保存在内存中，这样的话MySQL本身异常重启也会丢数据，风险太大。而redo log写到文件系统的page cache的速度也是很快的，所以将这个参数设置成2跟设置成0其实性能差不多，但这样做MySQL异常重启时就不会丢数据了，相比之下风险会更小。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在专栏的<a href="https://time.geekbang.org/column/article/68633">第2篇</a>和<a href="https://time.geekbang.org/column/article/73161">第15篇</a>文章中，我和你分析了，如果redo log和binlog是完整的，MySQL是如何保证crash-safe的。今天这篇文章，我着重和你介绍的是MySQL是“怎么保证redo log和binlog是完整的”。</p>
<p>希望这三篇文章串起来的内容，能够让你对crash-safe这个概念有更清晰的理解。</p>
<p>之前的第15篇答疑文章发布之后，有同学继续留言问到了一些跟日志相关的问题，这里为了方便你回顾、学习，我再集中回答一次这些问题。</p>
<p><strong>问题1：</strong> 执行一个update语句以后，我再去执行hexdump命令直接查看ibd文件内容，为什么没有看到数据有改变呢？</p>
<p>回答：这可能是因为WAL机制的原因。update语句执行完成后，InnoDB只保证写完了redo log、内存，可能还没来得及将数据写到磁盘。</p>
<p><strong>问题2：</strong> 为什么binlog cache是每个线程自己维护的，而redo log buffer是全局共用的？</p>
<p>回答：MySQL这么设计的主要原因是，binlog是不能“被打断的”。一个事务的binlog必须连续写，因此要整个事务完成后，再一起写到文件里。</p>
<p>而redo log并没有这个要求，中间有生成的日志可以写到redo log buffer中。redo log buffer中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>
<p><strong>问题3：</strong> 事务执行期间，还没到提交阶段，如果发生crash的话，redo log肯定丢了，这会不会导致主备不一致呢？</p>
<p>回答：不会。因为这时候binlog 也还在binlog cache里，没发给备库。crash以后redo log和binlog都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p>
<p><strong>问题4：</strong> 如果binlog写完盘以后发生crash，这时候还没给客户端答复就重启了。等客户端再重连进来，发现事务已经提交成功了，这是不是bug？</p>
<p>回答：不是。</p>
<p>你可以设想一下更极端的情况，整个事务都提交成功了，redo log commit完成了，备库也收到binlog并执行了。但是主库和客户端网络断开了，导致事务成功的包返回不回去，这时候客户端也会收到“网络断开”的异常。这种也只能算是事务成功的，不能认为是bug。</p>
<p>实际上数据库的crash-safe保证的是：</p>
<ol>
<li>如果客户端收到事务成功的消息，事务就一定持久化了；</li>
<li>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；</li>
<li>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。</li>
</ol>
<p>最后，又到了课后问题时间。</p>
<p>今天我留给你的思考题是：你的生产库设置的是“双1”吗？ 如果平时是的话，你有在什么场景下改成过“非双1”吗？你的这个操作又是基于什么决定的？</p>
<p>另外，我们都知道这些设置可能有损，如果发生了异常，你的止损方案是什么？</p>
<p>你可以把你的理解或者经验写在留言区，我会在下一篇文章的末尾选取有趣的评论和你一起分享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上篇文章最后，想要你分享的是线上“救火”的经验。</p>
<p>@Long 同学，在留言中提到了几个很好的场景。</p>
<ul>
<li>其中第3个问题，“如果一个数据库是被客户端的压力打满导致无法响应的，重启数据库是没用的。”，说明他很好地思考了。<br>这个问题是因为重启之后，业务请求还会再发。而且由于是重启，buffer pool被清空，可能会导致语句执行得更慢。</li>
<li>他提到的第4个问题也很典型。有时候一个表上会出现多个单字段索引（而且往往这是因为运维工程师对索引原理不够清晰做的设计），这样就可能出现优化器选择索引合并算法的现象。但实际上，索引合并算法的效率并不好。而通过将其中的一个索引改成联合索引的方法，是一个很好的应对方案。</li>
</ul>
<p>还有其他几个同学提到的问题场景，也很好，很值得你一看。</p>
<blockquote>
<p>@Max 同学提到一个很好的例子：客户端程序的连接器，连接完成后会做一些诸如show columns的操作，在短连接模式下这个影响就非常大了。<br>这个提醒我们，在review项目的时候，不止要review我们自己业务的代码，也要review连接器的行为。一般做法就是在测试环境，把general_log打开，用业务行为触发连接，然后通过general log分析连接器的行为。</p>
</blockquote>
<blockquote>
<p>@Manjusaka 同学的留言中，第二点提得非常好：如果你的数据库请求模式直接对应于客户请求，这往往是一个危险的设计。因为客户行为不可控，可能突然因为你们公司的一个运营推广，压力暴增，这样很容易把数据库打挂。<br>在设计模型里面设计一层，专门负责管理请求和数据库服务资源，对于比较重要和大流量的业务，是一个好的设计方向。</p>
</blockquote>
<blockquote>
<p>@Vincent 同学提了一个好问题，用文中提到的DDL方案，会导致binlog里面少了这个DDL语句，后续影响备份恢复的功能。由于需要另一个知识点（主备同步协议），我放在后面的文章中说明。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>24 | MySQL是怎么保证主备一致的</title>
    <url>/posts/a4056f8a.html</url>
    <content><![CDATA[<p>在前面的文章中，我不止一次地和你提到了binlog，大家知道binlog可以用来归档，也可以用来做主备同步，但它的内容是什么样的呢？为什么备库执行了binlog就可以跟主库保持一致了呢？今天我就正式地和你介绍一下它。</p>
<span id="more"></span>

<p>毫不夸张地说，MySQL能够成为现下最流行的开源数据库，binlog功不可没。</p>
<p>在最开始，MySQL是以容易学习和方便的高可用架构，被开发人员青睐的。而它的几乎所有的高可用架构，都直接依赖于binlog。虽然这些高可用架构已经呈现出越来越复杂的趋势，但都是从最基本的一主一备演化过来的。</p>
<p>今天这篇文章我主要为你介绍主备的基本原理。理解了背后的设计原理，你也可以从业务开发的角度，来借鉴这些设计思想。</p>
<h1 id="MySQL主备的基本原理"><a href="#MySQL主备的基本原理" class="headerlink" title="MySQL主备的基本原理"></a>MySQL主备的基本原理</h1><p>如图1所示就是基本的主备切换流程。</p>
<p><img src="https://static001.geekbang.org/resource/image/fd/10/fd75a2b37ae6ca709b7f16fe060c2c10.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 1 MySQL主备切换流程</b>
    </div>
    <br>
</center>

<p>在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。这样可以保持节点B和A的数据是相同的。</p>
<p>当需要切换的时候，就切成状态2。这时候客户端读写访问的都是节点B，而节点A是B的备库。</p>
<p>在状态1中，虽然节点B没有被直接访问，但是我依然建议你把节点B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用readonly状态，来判断节点的角色。</li>
</ol>
<p>你可能会问，我把备库设置成只读了，还怎么跟主库保持同步更新呢？</p>
<p>这个问题，你不用担心。因为readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p>
<p>接下来，我们再看看<strong>节点A到B这条线的内部流程是什么样的</strong>。图2中画出的就是一个update语句在节点A执行，然后同步到节点B的完整流程图。</p>
<p><img src="https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 主备流程图</b>
    </div>
    <br>
</center>

<p>图2中，包含了我在上一篇文章中讲到的binlog和redo log的写入机制相关的内容，可以看到：主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。</p>
<p>备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。</li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</li>
<li>备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<p>这里需要说明，后来由于多线程复制方案的引入，sql_thread演化成为了多个线程，跟我们今天要介绍的原理没有直接关系，暂且不展开。</p>
<p>分析完了这个长连接的逻辑，我们再来看一个问题：binlog里面到底是什么内容，为什么备库拿过去可以直接执行。</p>
<h1 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h1><p>我在<a href="https://time.geekbang.org/column/article/73161">第15篇答疑文章</a>中，和你提到过binlog有两种格式，一种是statement，一种是row。可能你在其他资料上还会看到有第三种格式，叫作mixed，其实它就是前两种格式的混合。</p>
<p>为了便于描述binlog的这三种格式间的区别，我创建了一个表，并初始化几行数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `t_modified`(`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;2018-11-13&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;2018-11-12&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="string">&#x27;2018-11-11&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">4</span>,<span class="string">&#x27;2018-11-10&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="string">&#x27;2018-11-09&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要在表中删除一行数据的话，我们来看看这个delete语句的binlog是怎么记录的。</p>
<p>注意，下面这个语句包含注释，如果你用MySQL客户端来做这个实验的话，要记得加-c参数，否则客户端会自动去掉注释。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="comment">/*comment*/</span>  <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;=</span><span class="string">&#x27;2018-11-10&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当binlog_format&#x3D;statement时，binlog里面记录的就是SQL语句的原文。你可以用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;master.000001&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>命令看binlog中的内容。</p>
<p><img src="https://static001.geekbang.org/resource/image/b9/31/b9818f73cd7d38a96ddcb75350b52931.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 statement格式 binlog 示例</b>
    </div>
    <br>
</center>

<p>现在，我们来看一下图3的输出结果。</p>
<ul>
<li>第一行SET @@SESSION.GTID_NEXT&#x3D;’ANONYMOUS’你可以先忽略，后面文章我们会在介绍主备切换的时候再提到；</li>
<li>第二行是一个BEGIN，跟第四行的commit对应，表示中间是一个事务；</li>
<li>第三行就是真实执行的语句了。可以看到，在真实执行的delete命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是MySQL根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到test库的表t。<br>use ‘test’命令之后的delete 语句，就是我们输入的SQL原文了。可以看到，binlog“忠实”地记录了SQL命令，甚至连注释也一并记录了。</li>
<li>最后一行是一个COMMIT。你可以看到里面写着xid&#x3D;61。你还记得这个XID是做什么用的吗？如果记忆模糊了，可以再回顾一下<a href="https://time.geekbang.org/column/article/73161">第15篇文章</a>中的相关内容。</li>
</ul>
<p>为了说明statement 和 row格式的区别，我们来看一下这条delete命令的执行效果图：</p>
<p><img src="https://static001.geekbang.org/resource/image/96/2b/96c2be9c0fcbff66883118526b26652b.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 delete执行warnings</b>
    </div>
    <br>
</center>

<p>可以看到，运行这条delete命令产生了一个warning，原因是当前binlog设置的是statement格式，并且语句中有limit，所以这个命令可能是unsafe的。</p>
<p>为什么这么说呢？这是因为delete 带limit，很可能会出现主备数据不一致的情况。比如上面这个例子：</p>
<ol>
<li>如果delete语句使用的是索引a，那么会根据索引a找到第一个满足条件的行，也就是说删除的是a&#x3D;4这一行；</li>
<li>但如果使用的是索引t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是a&#x3D;5这一行。</li>
</ol>
<p>由于statement格式下，记录到binlog里的是语句原文，因此可能会出现这样一种情况：在主库执行这条SQL语句的时候，用的是索引a；而在备库执行这条SQL语句的时候，却使用了索引t_modified。因此，MySQL认为这样写是有风险的。</p>
<p>那么，如果我把binlog的格式改为binlog_format&#x3D;‘row’， 是不是就没有这个问题了呢？我们先来看看这时候binog中的内容吧。</p>
<p><img src="https://static001.geekbang.org/resource/image/d6/26/d67a38db154afff610ae3bb64e266826.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b></b>
    </div>
    <br>
</center>

<p>图5 row格式binlog 示例可以看到，与statement格式的binlog相比，前后的BEGIN和COMMIT是一样的。但是，row格式的binlog里没有了SQL语句的原文，而是替换成了两个event：Table_map和Delete_rows。</p>
<ol>
<li>Table_map event，用于说明接下来要操作的表是test库的表t;</li>
<li>Delete_rows event，用于定义删除的行为。</li>
</ol>
<p>其实，我们通过图5是看不到详细信息的，还需要借助mysqlbinlog工具，用下面这个命令解析和查看binlog中的内容。因为图5中的信息显示，这个事务的binlog是从8900这个位置开始的，所以可以用start-position参数来指定从这个位置的日志开始解析。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog  <span class="operator">-</span>vv data<span class="operator">/</span>master<span class="number">.000001</span> <span class="comment">--start-position=8900;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 row格式binlog 示例的详细信息</b>
    </div>
    <br>
</center>

<p>从这个图中，我们可以看到以下几个信息：</p>
<ul>
<li>server id 1，表示这个事务是在server_id&#x3D;1的这个库上执行的。</li>
<li>每个event都有CRC32的值，这是因为我把参数binlog_checksum设置成了CRC32。</li>
<li>Table_map event跟在图5中看到的相同，显示了接下来要打开的表，map到数字226。现在我们这条SQL语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的Table_map event、都会map到一个单独的数字，用于区分对不同表的操作。</li>
<li>我们在mysqlbinlog的命令中，使用了-vv参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1&#x3D;4、 @2&#x3D;4这些值）。</li>
<li>binlog_row_image的默认配置是FULL，因此Delete_event里面，包含了删掉的行的所有字段的值。如果把binlog_row_image设置为MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录id&#x3D;4这个信息。</li>
<li>最后的Xid event，用于表示事务被正确地提交了。</li>
</ul>
<p>你可以看到，当binlog_format使用row格式的时候，binlog里面记录了真实删除行的主键id，这样binlog传到备库去的时候，就肯定会删除id&#x3D;4的行，不会有主备删除不同行的问题。</p>
<h1 id="为什么会有mixed格式的binlog？"><a href="#为什么会有mixed格式的binlog？" class="headerlink" title="为什么会有mixed格式的binlog？"></a>为什么会有mixed格式的binlog？</h1><p>基于上面的信息，我们来讨论一个问题：<strong>为什么会有mixed这种binlog格式的存在场景？</strong>推论过程是这样的：</p>
<ul>
<li>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。</li>
<li>但row格式的缺点是，很占空间。比如你用一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果用row格式的binlog，就要把这10万条记录都写到binlog中。这样做，不仅会占用更大的空间，同时写binlog也要耗费IO资源，影响执行速度。</li>
<li>所以，MySQL就取了个折中方案，也就是有了mixed格式的binlog。mixed格式的意思是，MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。</li>
</ul>
<p>也就是说，mixed格式可以利用statment格式的优点，同时又避免了数据不一致的风险。</p>
<p>因此，如果你的线上MySQL设置的binlog格式是statement的话，那基本上就可以认为这是一个不合理的设置。你至少应该把binlog的格式设置为mixed。</p>
<p>比如我们这个例子，设置为mixed后，就会记录为row格式；而如果执行的语句去掉limit 1，就会记录为statement格式。</p>
<p>当然我要说的是，现在越来越多的场景要求把MySQL的binlog格式设置成row。这么做的理由有很多，我来给你举一个可以直接看出来的好处：<strong>恢复数据</strong>。</p>
<p>接下来，我们就分别从delete、insert和update这三种SQL语句的角度，来看看数据恢复的问题。</p>
<p>通过图6你可以看出来，即使我执行的是delete语句，row格式的binlog也会把被删掉的行的整行信息保存起来。所以，如果你在执行完一条delete语句以后，发现删错数据了，可以直接把binlog中记录的delete语句转成insert，把被错删的数据插入回去就可以恢复了。</p>
<p>如果你是执行错了insert语句呢？那就更直接了。row格式下，insert语句的binlog里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把insert语句转成delete语句，删除掉这被误插入的一行数据就可以了。</p>
<p>如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了update语句的话，只需要把这个event前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</p>
<p>其实，由delete、insert或者update语句导致的数据操作错误，需要恢复到操作之前状态的情况，也时有发生。MariaDB的<a href="https://mariadb.com/kb/en/library/flashback/">Flashback</a>工具就是基于上面介绍的原理来回滚数据的。</p>
<p>虽然mixed格式的binlog现在已经用得不多了，但这里我还是要再借用一下mixed格式来说明一个问题，来看一下这条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>, now());</span><br></pre></td></tr></table></figure>

<p>如果我们把binlog格式设置为mixed，你觉得MySQL会把它记录为row格式还是statement格式呢？</p>
<p>先不要着急说结果，我们一起来看一下这条语句执行的效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/01/ef/0150301698979255a6f27711c35e9eef.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 mixed格式和now()</b>
    </div>
    <br>
</center>

<p>可以看到，MySQL用的居然是statement格式。你一定会奇怪，如果这个binlog过了1分钟才传给备库的话，那主备的数据不就不一致了吗？</p>
<p>接下来，我们再用mysqlbinlog工具来看看：</p>
<p><img src="https://static001.geekbang.org/resource/image/1a/41/1ad3a4c4b9a71955edba5195757dd041.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 TIMESTAMP 命令</b>
    </div>
    <br>
</center>

<p>从图中的结果可以看到，原来binlog在记录event的时候，多记了一条命令：SET TIMESTAMP&#x3D;1546103491。它用 SET TIMESTAMP命令约定了接下来的now()函数的返回时间。</p>
<p>因此，不论这个binlog是1分钟之后被备库执行，还是3天后用来恢复这个库的备份，这个insert语句插入的行，值都是固定的。也就是说，通过这条SET TIMESTAMP命令，MySQL就确保了主备数据的一致性。</p>
<p>我之前看过有人在重放binlog数据的时候，是这么做的：用mysqlbinlog解析出日志，然后把里面的statement语句直接拷贝出来执行。</p>
<p>你现在知道了，这个方法是有风险的。因为有些语句的执行结果是依赖于上下文命令的，直接执行的结果很可能是错误的。</p>
<p>所以，用binlog来恢复数据的标准做法是，用 mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行。类似下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog master<span class="number">.000001</span>  <span class="comment">--start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br></pre></td></tr></table></figure>

<p>这个命令的意思是，将 master.000001 文件里面从第2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p>
<h1 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h1><p>通过上面对MySQL中binlog基本内容的理解，你现在可以知道，binlog的特性确保了在备库执行相同的binlog，可以得到与主库相同的状态。</p>
<p>因此，我们可以认为正常情况下主备的数据是一致的。也就是说，图1中A、B两个节点的内容是一致的。其实，图1中我画的是M-S结构，但实际生产上使用比较多的是双M结构，也就是图9所示的主备切换流程。</p>
<p><img src="https://static001.geekbang.org/resource/image/20/56/20ad4e163115198dc6cf372d5116c956.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 9 MySQL主备切换流程--双M结构</b>
    </div>
    <br>
</center>

<p>对比图9和图1，你可以发现，双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p>
<p>但是，双M结构还有一个问题需要解决。</p>
<p>业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新语句后也会生成binlog。（我建议你把参数log_slave_updates设置为on，表示备库执行relay log后生成binlog）。</p>
<p>那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</p>
<p>从上面的图6中可以看到，MySQL在binlog中记录了这个命令第一次执行时所在实例的server id。因此，我们可以用下面的逻辑，来解决两个节点间的循环复制的问题：</p>
<ol>
<li>规定两个库的server id必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<p>按照这个逻辑，如果我们设置了双M结构，日志的执行流就会变成这样：</p>
<ol>
<li>从节点A更新的事务，binlog里面记的都是A的server id；</li>
<li>传到节点B执行一次以后，节点B生成的binlog 的server id也是A的server id；</li>
<li>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我给你介绍了MySQL binlog的格式和一些基本机制，是后面我要介绍的读写分离等系列文章的背景知识，希望你可以认真消化理解。</p>
<p>binlog在MySQL的各种高可用方案上扮演了重要角色。今天介绍的可以说是所有MySQL高可用方案的基础。在这之上演化出了诸如多节点、半同步、MySQL group replication等相对复杂的方案。</p>
<p>我也跟你介绍了MySQL不同格式binlog的优缺点，和设计者的思考。希望你在做系统开发时候，也能借鉴这些设计思想。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>说到循环复制问题的时候，我们说MySQL通过判断server id的方式，断掉死循环。但是，这个机制其实并不完备，在某些场景下，还是有可能出现死循环。</p>
<p>你能构造出一个这样的场景吗？又应该怎么解决呢？</p>
<p>你可以把你的设计和分析写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我留给你的问题是，你在什么时候会把线上生产库设置成“非双1”。我目前知道的场景，有以下这些：</p>
<ol>
<li>业务高峰期。一般如果有预知的高峰期，DBA会有预案，把主库设置成“非双1”。</li>
<li>备库延迟，为了让备库尽快赶上主库。@永恒记忆和@Second Sight提到了这个场景。</li>
<li>用备份恢复主库的副本，应用binlog的过程，这个跟上一种场景类似。</li>
<li>批量导入数据的时候。</li>
</ol>
<p>一般情况下，把生产库改成“非双1”配置，是设置innodb_flush_logs_at_trx_commit&#x3D;2、sync_binlog&#x3D;1000。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@way 同学提到了一个有趣的现象，由于从库设置了 binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count导致一直延迟的情况。我们在主库设置这两个参数，是为了减少binlog的写盘压力。备库这么设置，尤其在“快要追上”的时候，就反而会受这两个参数的拖累。一般追主备就用“非双1”（追上记得改回来）。</p>
</blockquote>
<blockquote>
<p>@一大只 同学验证了在sync_binlog&#x3D;0的情况下，设置sync_delay和sync_no_delay_count的现象，点赞这种发现边界的意识和手动验证的好习惯。是这样的：sync_delay和sync_no_delay_count的逻辑先走，因此该等还是会等。等到满足了这两个条件之一，就进入sync_binlog阶段。这时候如果判断sync_binlog&#x3D;0，就直接跳过，还是不调fsync。</p>
</blockquote>
<blockquote>
<p>@锅子 同学提到，设置sync_binlog&#x3D;0的时候，还是可以看到binlog文件马上做了修改。这个是对的，我们说“写到了page cache”，就是文件系统的page cache。而你用ls命令看到的就是文件系统返回的结果。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>25 | MySQL是怎么保证高可用的</title>
    <url>/posts/a48e906d.html</url>
    <content><![CDATA[<p>在上一篇文章中，我和你介绍了binlog的基本内容，在一个主备关系中，每个备库接收主库的binlog并执行。</p>
<p>正常情况下，只要主库执行更新生成的所有binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。</p>
<p>但是，MySQL要提供高可用能力，只有最终一致性是不够的。</p>
<span id="more"></span>

<p>为什么这么说呢？今天我就着重和你分析一下。</p>
<p>这里，我再放一次上一篇文章中讲到的双M结构的主备切换流程图。</p>
<p><img src="https://static001.geekbang.org/resource/image/89/cc/89290bbcf454ff9a3dc5de42a85a69cc.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 1 MySQL主备切换流程--双M结构</b>
    </div>
    <br>
</center>

<h1 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h1><p>主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。</p>
<p>接下来，我们先一起看看主动切换的场景。</p>
<p>在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即“同步延迟”。与数据同步有关的时间点主要包括以下三个：</p>
<ol>
<li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li>
<li>之后传给备库B，我们把备库B接收完这个binlog的时刻记为T2;</li>
<li>备库B执行完成这个事务，我们把这个时刻记为T3。</li>
</ol>
<p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。</p>
<p>你可以在备库上执行show slave status命令，它的返回结果里面会显示seconds_behind_master，用于表示当前备库延迟了多少秒。</p>
<p>seconds_behind_master的计算方法是这样的：</p>
<ol>
<li>每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到seconds_behind_master。</li>
</ol>
<p>可以看到，其实seconds_behind_master这个参数计算的就是T3-T1。所以，我们可以用seconds_behind_master来作为主备延迟的值，这个值的时间精度是秒。</p>
<p>你可能会问，如果主备库机器的系统时间设置不一致，会不会导致主备延迟的值不准？</p>
<p>其实不会的。因为，备库连接到主库的时候，会通过执行SELECT UNIX_TIMESTAMP()函数来获得当前主库的系统时间。如果这时候发现主库的系统时间与自己不一致，备库在执行seconds_behind_master计算的时候会自动扣掉这个差值。</p>
<p>需要说明的是，在网络正常的时候，日志从主库传给备库所需的时间是很短的，即T2-T1的值是非常小的。也就是说，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p>
<p>所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产binlog的速度要慢。接下来，我就和你一起分析下，这可能是由哪些原因导致的。</p>
<h1 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h1><p><strong>首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</strong></p>
<p>一般情况下，有人这么部署时的想法是，反正备库没有请求，所以可以用差一点儿的机器。或者，他们会把20个主库放在4台机器上，而把备库集中在一台机器上。</p>
<p>其实我们都知道，更新请求对IOPS的压力，在主库和备库上是无差别的。所以，做这种部署时，一般都会将备库设置为“非双1”的模式。</p>
<p>但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。</p>
<p>当然，这种部署现在比较少了。因为主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况。</p>
<p>追问1：但是，做了对称部署以后，还可能会有延迟。这是为什么呢？</p>
<p>这就是<strong>第二种常见的可能了，即备库的压力大</strong>。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。</p>
<p>我真就见过不少这样的情况。由于主库直接影响业务，大家使用起来会比较克制，反而忽视了备库的压力控制。结果就是，备库上的查询耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p>
<p>这种情况，我们一般可以这么处理：</p>
<ol>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
<p>其中，一主多从的方式大都会被采用。因为作为数据库系统，还必须保证有定期全量备份的能力。而从库，就很适合用来做备份。</p>
<blockquote>
<p>备注：这里需要说明一下，从库和备库在概念上其实差不多。在我们这个专栏里，为了方便描述，我把会在HA过程中被选成新主库的，称为备库，其他的称为从库。</p>
</blockquote>
<p>追问2：采用了一主多从，保证备库的压力不会超过主库，还有什么情况可能导致主备延迟吗？</p>
<p><strong>这就是第三种可能了，即大事务。</strong></p>
<p>大事务这种情况很好理解。因为主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟。</p>
<p>不知道你所在公司的DBA有没有跟你这么说过：不要<strong>一次性地用delete语句删除太多数据</strong>。其实，这就是一个典型的大事务场景。</p>
<p>比如，一些归档类的数据，平时没有注意删除历史数据，等到空间快满了，业务开发人员要一次性地删掉大量历史数据。同时，又因为要避免在高峰期操作会影响业务（至少有这个意识还是很不错的），所以会在晚上执行这些大量数据的删除操作。</p>
<p>结果，负责的DBA同学半夜就会收到延迟报警。然后，DBA团队就要求你后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p>
<p><strong>另一种典型的大事务场景，就是大表DDL。</strong> 这个场景，我在前面的文章中介绍过。处理方案就是，计划内的DDL，建议使用gh-ost方案（这里，你可以再回顾下第13篇文章<a href="https://time.geekbang.org/column/article/72388">《为什么表数据删掉一半，表文件大小不变？》</a>中的相关内容）。</p>
<p>追问3：如果主库上也不做大事务了，还有什么原因会导致主备延迟吗？</p>
<p>造成主备延迟还有一个大方向的原因，就是<strong>备库的并行复制能力</strong>。这个话题，我会留在下一篇文章再和你详细介绍。</p>
<p>其实还是有不少其他情况会导致主备延迟，如果你还碰到过其他场景，欢迎你在评论区给我留言，我来和你一起分析、讨论。</p>
<p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p>
<h1 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h1><p>在图1的双M结构下，从状态1到状态2切换的详细过程是这样的：</p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li>
<li>把主库A改成只读状态，即把readonly设置为true；</li>
<li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li>
<li>把备库B改成可读写状态，也就是把readonly 设置为false；</li>
<li>把业务请求切到备库B。</li>
</ol>
<p>这个切换流程，一般是由专门的HA系统来完成的，我们暂时称之为可靠性优先流程。</p>
<p><img src="https://static001.geekbang.org/resource/image/54/4a/54f4c7c31e6f0f807c2ab77f78c8844a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 MySQL可靠性优先主备切换流程</b>
    </div>
    <br>
</center>

<p>备注：图中的SBM，是seconds_behind_master参数的简写。</p>
<p>可以看到，这个切换流程中是有不可用时间的。因为在步骤2之后，主库A和备库B都处于readonly状态，也就是说这时系统处于不可写状态，直到步骤5完成后才能恢复。</p>
<p>在这个不可用状态中，比较耗费时间的是步骤3，可能需要耗费好几秒的时间。这也是为什么需要在步骤1先做判断，确保seconds_behind_master的值足够小。</p>
<p>试想如果一开始主备延迟就长达30分钟，而不先做判断直接切换的话，系统的不可用时间就会长达30分钟，这种情况一般业务都是不可接受的。</p>
<p>当然，系统的不可用时间，是由这个数据可靠性优先的策略决定的。你也可以选择可用性优先的策略，来把这个不可用时间几乎降为0。</p>
<h1 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h1><p>如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。</p>
<p>我们把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p>
<p>接下来，我就和你分享一个可用性优先流程产生数据不一致的例子。假设有一个表 t：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这个表定义了一个自增主键id，初始化数据后，主库和备库上都是3行数据。接下来，业务人员要继续在表t上执行两条插入语句的命令，依次是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到5秒。在插入一条c&#x3D;4的语句后，发起了主备切换。</p>
<p>图3是 <strong>可用性优先策略，且binlog_format&#x3D;mixed</strong> 时的切换流程和数据结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/37/3a/3786bd6ad37faa34aca25bf1a1d8af3a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 可用性优先策略，且binlog_format=mixed</b>
    </div>
    <br>
</center>

<p>现在，我们一起分析下这个切换流程：</p>
<ol>
<li>步骤2中，主库A执行完insert语句，插入了一行数据（4,4），之后开始进行主备切换。</li>
<li>步骤3中，由于主备之间有5秒的延迟，所以备库B还没来得及应用“插入c&#x3D;4”这个中转日志，就开始接收客户端“插入 c&#x3D;5”的命令。</li>
<li>步骤4中，备库B插入了一行数据（4,5），并且把这个binlog发给主库A。</li>
<li>步骤5中，备库B执行“插入c&#x3D;4”这个中转日志，插入了一行数据（5,4）。而直接在备库B执行的“插入c&#x3D;5”这个语句，传到主库A，就插入了一行新数据（5,5）。</li>
</ol>
<p>最后的结果就是，主库A和备库B上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p>
<p>那么，如果我还是用<strong>可用性优先策略，但设置binlog_format&#x3D;row</strong>，情况又会怎样呢？</p>
<p>因为row格式在记录binlog的时候，会记录新插入的行的所有字段值，所以最后只会有一行不一致。而且，两边的主备同步的应用线程会报错duplicate key error并停止。也就是说，这种情况下，备库B的(5,4)和主库A的(5,5)这两行数据，都不会被对方执行。</p>
<p>图4中我画出了详细过程，你可以自己再分析一下。</p>
<p><img src="https://static001.geekbang.org/resource/image/b8/43/b8d2229b2b40dd087fd3b111d1bdda43.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 可用性优先策略，且binlog_format=row</b>
    </div>
    <br>
</center>

<p>从上面的分析中，你可以看到一些结论：</p>
<ol>
<li>使用row格式的binlog时，数据不一致的问题更容易被发现。而使用mixed或者statement格式的binlog时，数据很可能悄悄地就不一致了。如果你过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li>
<li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，我都建议你使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li>
</ol>
<p>但事无绝对，<strong>有没有哪种情况数据的可用性优先级更高呢？</strong></p>
<p>答案是，有的。</p>
<p>我曾经碰到过这样的一个场景：</p>
<ul>
<li>有一个库的作用是记录操作日志。这时候，如果数据不一致可以通过binlog来修补，而这个短暂的不一致也不会引发业务问题。</li>
<li>同时，业务系统依赖于这个日志写入逻辑，如果这个库不可写，会导致线上的业务操作无法执行。</li>
</ul>
<p>这时候，你可能就需要选择先强行切换，事后再补数据的策略。</p>
<p>当然，事后复盘的时候，我们想到了一个改进措施就是，让业务逻辑不要依赖于这类日志的写入。也就是说，日志写入这个逻辑模块应该可以降级，比如写到本地文件，或者写到另外一个临时库里面。</p>
<p>这样的话，这种场景就又可以使用可靠性优先策略了。</p>
<p>接下来我们再看看，<strong>按照可靠性优先的思路，异常切换会是什么效果？</strong></p>
<p>假设，主库A和备库B间的主备延迟是30分钟，这时候主库A掉电了，HA系统要切换B作为主库。我们在主动切换的时候，可以等到主备延迟小于5秒的时候再启动切换，但这时候已经别无选择了。</p>
<p><img src="https://static001.geekbang.org/resource/image/55/8b/553b7fc2d0dce3ec78bb595e1806eb8b.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 可靠性优先策略，主库不可用</b>
    </div>
    <br>
</center>

<p>采用可靠性优先策略的话，你就必须得等到备库B的seconds_behind_master&#x3D;0之后，才能切换。但现在的情况比刚刚更严重，并不是系统只读、不可写的问题了，而是系统处于完全不可用的状态。因为，主库A掉电后，我们的连接还没有切到备库B。</p>
<p>你可能会问，那能不能直接切换到备库B，但是保持B只读呢？</p>
<p>这样也不行。</p>
<p>因为，这段时间内，中转日志还没有应用完成，如果直接发起主备切换，客户端查询看不到之前执行完成的事务，会认为有“数据丢失”。</p>
<p>虽然随着中转日志的继续应用，这些数据会恢复回来，但是对于一些业务来说，查询到“暂时丢失数据的状态”也是不能被接受的。</p>
<p>聊到这里你就知道了，在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我先和你介绍了MySQL高可用系统的基础，就是主备切换逻辑。紧接着，我又和你讨论了几种会导致主备延迟的情况，以及相应的改进方向。</p>
<p>然后，由于主备延迟的存在，切换策略就有不同的选择。所以，我又和你一起分析了可靠性优先和可用性优先策略的区别。</p>
<p>在实际的应用中，我更建议使用可靠性优先的策略。毕竟保证数据准确，应该是数据库服务的底线。在这个基础上，通过减少主备延迟，提升系统的可用性。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>一般现在的数据库运维系统都有备库延迟监控，其实就是在备库上执行 show slave status，采集seconds_behind_master的值。</p>
<p>假设，现在你看到你维护的一个备库，它的延迟监控的图像类似图6，是一个45°斜向上的线段，你觉得可能是什么原因导致呢？你又会怎么去确认这个原因呢？</p>
<p><img src="https://static001.geekbang.org/resource/image/cf/71/cf5ea52aa3b26ef56c567125197fa171.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 备库延迟</b>
    </div>
    <br>
</center>

<p>你可以把你的分析写在评论区，我会在下一篇文章的末尾跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期我留给你的问题是，什么情况下双M结构会出现循环复制。</p>
<p>一种场景是，在一个主库更新事务后，用命令set global server_id&#x3D;x修改了server_id。等日志再传回来的时候，发现server_id跟自己的server_id不同，就只能执行了。</p>
<p>另一种场景是，有三个节点的时候，如图7所示，trx1是在节点 B执行的，因此binlog上的server_id就是B，binlog传给节点 A，然后A和A’搭建了双M结构，就会出现循环复制。</p>
<p><img src="https://static001.geekbang.org/resource/image/f9/71/f968192ce2f436c939dd702b8f409771.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 三节点循环复制</b>
    </div>
    <br>
</center>

<p>这种三节点复制的场景，做数据库迁移的时候会出现。</p>
<p>如果出现了循环复制，可以在A或者A’上，执行如下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span> IGNORE_SERVER_IDS<span class="operator">=</span>(server_id_of_B);</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>

<p>这样这个节点收到日志后就不会再执行。过一段时间后，再执行下面的命令把这个值改回来。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">stop slave；</span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span> IGNORE_SERVER_IDS<span class="operator">=</span>();</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>

<p>评论区留言点赞板：</p>
<blockquote>
<p>@一大只、@HuaMax 同学提到了第一个复现方法；</p>
</blockquote>
<blockquote>
<p>@Jonh同学提到了IGNORE_SERVER_IDS这个解决方法；</p>
</blockquote>
<blockquote>
<p>@React 提到，如果主备设置不同的步长，备库是不是可以设置为可读写。我的建议是，只要这个节点设计内就不会有业务直接在上面执行更新，就建议设置为readonly。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>26 | 备库为什么会延迟好几个小时</title>
    <url>/posts/990ff3bb.html</url>
    <content><![CDATA[<p>在上一篇文章中，我和你介绍了几种可能导致备库延迟的原因。你会发现，这些场景里，不论是偶发性的查询压力，还是备份，对备库延迟的影响一般是分钟级的，而且在备库恢复正常以后都能够追上来。</p>
<span id="more"></span>

<p>但是，如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，备库很可能永远都追不上主库的节奏。</p>
<p>这就涉及到今天我要给你介绍的话题：备库并行复制能力。</p>
<p>为了便于你理解，我们再一起看一下第24篇文章<a href="https://time.geekbang.org/column/article/76446">《MySQL是怎么保证主备一致的？》</a>的主备流程图。</p>
<p><img src="https://static001.geekbang.org/resource/image/1a/ef/1a85a3bac30a32438bfd8862e5a34eef.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 主备流程图</b>
    </div>
    <br>
</center>

<p>谈到主备的并行复制能力，我们要关注的是图中黑色的两个箭头。一个箭头代表了客户端写入主库，另一箭头代表的是备库上sql_thread执行中转日志（relay log）。如果用箭头的粗细来代表并行度的话，那么真实情况就如图1所示，第一个箭头要明显粗于第二个箭头。</p>
<p>在主库上，影响并发度的原因就是各种锁了。由于InnoDB引擎支持行锁，除了所有并发事务都在更新同一行（热点行）这种极端场景外，它对业务并发度的支持还是很友好的。所以，你在性能测试的时候会发现，并发压测线程32就比单线程时，总体吞吐量高。</p>
<p>而日志在备库上的执行，就是图中备库上sql_thread更新数据(DATA)的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成主备延迟。</p>
<p>在官方的5.6版本之前，MySQL只支持单线程复制，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。</p>
<p>从单线程复制到最新版本的多线程复制，中间的演化经历了好几个版本。接下来，我就跟你说说MySQL多线程复制的演进过程。</p>
<p>其实说到底，所有的多线程复制机制，都是要把图1中只有一个线程的sql_thread，拆成多个线程，也就是都符合下面的这个模型：</p>
<p><img src="https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 多线程模型</b>
    </div>
    <br>
</center>

<p>图2中，coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数slave_parallel_workers决定的。根据我的经验，把这个值设置为8~16之间最好（32核物理机的情况），毕竟备库还有可能要提供读查询，不能把CPU都吃光了。</p>
<p>接下来，你需要先思考一个问题：事务能不能按照轮询的方式分发给各个worker，也就是第一个事务分给worker_1，第二个事务发给worker_2呢？</p>
<p>其实是不行的。因为，事务被分发给worker以后，不同的worker就独立执行了。但是，由于CPU的调度策略，很可能第二个事务最终比第一个事务先执行。而如果这时候刚好这两个事务更新的是同一行，也就意味着，同一行上的两个事务，在主库和备库上的执行顺序相反，会导致主备不一致的问题。</p>
<p>接下来，请你再设想一下另外一个问题：同一个事务的多个更新语句，能不能分给不同的worker来执行呢？</p>
<p>答案是，也不行。举个例子，一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务“更新了一半的结果”，破坏了事务逻辑的原子性。</p>
<p>所以，coordinator在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li>
<li>同一个事务不能被拆开，必须放到同一个worker中。</li>
</ol>
<p>各个版本的多线程复制，都遵循了这两条基本原则。接下来，我们就看看各个版本的并行复制策略。</p>
<h1 id="MySQL-5-5版本的并行复制策略"><a href="#MySQL-5-5版本的并行复制策略" class="headerlink" title="MySQL 5.5版本的并行复制策略"></a>MySQL 5.5版本的并行复制策略</h1><p>官方MySQL 5.5版本是不支持并行复制的。但是，在2012年的时候，我自己服务的业务出现了严重的主备延迟，原因就是备库只有单线程复制。然后，我就先后写了两个版本的并行策略。</p>
<p>这里，我给你介绍一下这两个版本的并行策略，即按表分发策略和按行分发策略，以帮助你理解MySQL官方版本并行复制策略的迭代。</p>
<h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个worker不会更新同一行。</p>
<p>当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图3所示，就是按表分发的规则。</p>
<p><img src="https://static001.geekbang.org/resource/image/8b/76/8b6976fedd6e644022d4026581fb8d76.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 按表并行复制程模型</b>
    </div>
    <br>
</center>

<p>可以看到，每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表。</p>
<p>在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这个表会被从hash表中去掉。</p>
<p>图3中，hash_table_1表示，现在worker_1的“待执行事务队列”里，有4个事务涉及到db1.t1表，有1个事务涉及到db2.t2表；hash_table_2表示，现在worker_2中有一个事务会更新到表t3的数据。</p>
<p>假设在图中的情况下，coordinator从中转日志中读入一个新事务T，这个事务修改的行涉及到表t1和t3。</p>
<p>现在我们用事务T的分配流程，来看一下分配规则。</p>
<ol>
<li>由于事务T中涉及修改表t1，而worker_1队列中有事务在修改表t1，事务T和队列中的某个事务要修改同一个表的数据，这种情况我们说事务T和worker_1是冲突的。</li>
<li>按照这个逻辑，顺序判断事务T和每个worker队列的冲突关系，会发现事务T跟worker_2也冲突。</li>
<li>事务T跟多于一个worker冲突，coordinator线程就进入等待。</li>
<li>每个worker继续执行，同时修改hash_table。假设hash_table_2里面涉及到修改表t3的事务先执行完成，就会从hash_table_2中把db1.t3这一项去掉。</li>
<li>这样coordinator会发现跟事务T冲突的worker只有worker_1了，因此就把它分配给worker_1。</li>
<li>coordinator继续读下一个中转日志，继续分配事务。</li>
</ol>
<p>也就是说，每个事务在分发的时候，跟所有worker的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</li>
<li>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关系的worker只剩下1个；</li>
<li>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的worker。</li>
</ol>
<p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个worker中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求binlog格式必须是row。</p>
<p>这时候，我们判断一个事务T和worker是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个worker，分配一个hash表。只是要实现按行分发，这时候的key，就必须是“库名+表名+唯一键的值”。</p>
<p>但是，这个“唯一键”只有主键id还是不够的，我们还需要考虑下面这种场景，表t1中除了主键，还有唯一索引a：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>假设，接下来我们要在主库执行这两个事务：</p>
<p><img src="https://static001.geekbang.org/resource/image/f1/78/f19916e27b8ff28e87ed3ad9f5473378.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 唯一键冲突示例</b>
    </div>
    <br>
</center>

<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的worker，就有可能session B的语句先执行。这时候id&#x3D;1的行的a的值还是1，就会报唯一键冲突。</p>
<p>因此，基于行的策略，事务hash表中还需要考虑唯一键，即key应该是“库名+表名+索引a的名字+a的值”。</p>
<p>比如，在上面这个例子中，我要在表t1上执行update t1 set a&#x3D;1 where id&#x3D;2语句，在binlog里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p>
<p>因此，coordinator在解析这个语句的binlog的时候，这个事务的hash表就有三个项:</p>
<ol>
<li>key&#x3D;hash_func(db1+t1+“PRIMARY”+2), value&#x3D;2; 这里value&#x3D;2是因为修改前后的行id值不变，出现了两次。</li>
<li>key&#x3D;hash_func(db1+t1+“a”+2), value&#x3D;1，表示会影响到这个表a&#x3D;2的行。</li>
<li>key&#x3D;hash_func(db1+t1+“a”+1), value&#x3D;1，表示会影响到这个表a&#x3D;1的行。</li>
</ol>
<p>可见，<strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong>你可能也发现了，这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从binlog里面解析出表名、主键值和唯一索引的值。也就是说，主库的binlog格式必须是row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在binlog中，这样冲突检测就不准确。</li>
</ol>
<p>但，好在这三条约束规则，本来就是DBA之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p>
<p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存。比如一个语句要删除100万行数据，这时候hash表就要记录100万个项。</li>
<li>耗费CPU。解析binlog，然后计算hash值，对于大事务，这个成本还是很高的。</li>
</ol>
<p>所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过10万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p>
<ol>
<li>coordinator暂时先hold住这个事务；</li>
<li>等待所有worker都执行完成，变成空队列；</li>
<li>coordinator直接执行这个事务；</li>
<li>恢复并行模式。</li>
</ol>
<p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p>
<h1 id="MySQL-5-6版本的并行复制策略"><a href="#MySQL-5-6版本的并行复制策略" class="headerlink" title="MySQL 5.6版本的并行复制策略"></a>MySQL 5.6版本的并行复制策略</h1><p>官方MySQL5.6版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的hash表里，key就是数据库名。</p>
<p>这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好。</p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造hash值的时候很快，只需要库名；而且一个实例上DB数也不会很多，不会出现需要构造100万个项这种情况。</li>
<li>不要求binlog的格式。因为statement格式的binlog也可以很容易拿到库名。</li>
</ol>
<p>但是，如果你的主库上的表都放在同一个DB里面，这个策略就没有效果了；或者如果不同DB的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p>
<p>理论上你可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p>
<h1 id="MariaDB的并行复制策略"><a href="#MariaDB的并行复制策略" class="headerlink" title="MariaDB的并行复制策略"></a>MariaDB的并行复制策略</h1><p>在<a href="https://time.geekbang.org/column/article/76161">第23篇文章</a>中，我给你介绍了redo log组提交(group commit)优化， 而MariaDB的并行复制策略利用的就是这个特性：</p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
</ol>
<p>在实现上，MariaDB是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1；</li>
<li>commit_id直接写到binlog里面；</li>
<li>传到备库应用的时候，相同commit_id的事务分发到多个worker执行；</li>
<li>这一组全部执行完成后，coordinator再去取下一批。</li>
</ol>
<p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析binlog，并拆分到worker”上。而MariaDB的这个策略，目标是“模拟主库的并行模式”。</p>
<p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>如图5所示，假设了三组事务在主库的执行情况，你可以看到在trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/8f/c3/8fec5fb48d6095aecc80016826efbfc3.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 主库并行事务</b>
    </div>
    <br>
</center>

<p>而按照MariaDB的并行复制策略，备库上的执行效果如图6所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/8a/22/8ac3799c1ff2f9833619a1624ca3e622.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 MariaDB 并行复制，备库并行效果</b>
    </div>
    <br>
</center>

<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p>
<p>另外，这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有一个worker线程在工作，是对资源的浪费。</p>
<p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p>
<h1 id="MySQL-5-7的并行复制策略"><a href="#MySQL-5-7的并行复制策略" class="headerlink" title="MySQL 5.7的并行复制策略"></a>MySQL 5.7的并行复制策略</h1><p>在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave-parallel-type来控制并行复制策略：</p>
<ol>
<li>配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</li>
</ol>
<p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p>
<p>答案是，不能。</p>
<p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的worker，就会出现备库跟主库不一致的情况。</p>
<p>而上面提到的MariaDB这个策略的核心，是“所有处于commit”状态的事务可以并行。事务处于commit状态，表示已经通过了锁冲突的检验了。</p>
<p>这时候，你可以再回顾一下两阶段提交，我把前面<a href="https://time.geekbang.org/column/article/76161">第23篇文章</a>中介绍过的两阶段提交过程图贴过来。</p>
<p><img src="https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 两阶段提交细化过程图</b>
    </div>
    <br>
</center>

<p>其实，不用等到commit阶段，只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了。</p>
<p>因此，MySQL 5.7并行复制策略的思想是：</p>
<ol>
<li>同时处于prepare状态的事务，在备库执行时是可以并行的；</li>
<li>处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<p>我在第23篇文章，讲binlog的组提交的时候，介绍过两个参数：</p>
<ol>
<li>binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync;</li>
<li>binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync。</li>
</ol>
<p>这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL 5.7的并行复制策略里，它们可以用来制造更多的“同时处于prepare阶段的事务”。这样就增加了备库复制的并行度。</p>
<p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在MySQL 5.7处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p>
<h1 id="MySQL-5-7-22的并行复制策略"><a href="#MySQL-5-7-22的并行复制策略" class="headerlink" title="MySQL 5.7.22的并行复制策略"></a>MySQL 5.7.22的并行复制策略</h1><p>在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于WRITESET的并行复制。</p>
<p>相应地，新增了一个参数binlog-transaction-dependency-tracking，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p>
<ol>
<li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。</li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合writeset。如果两个事务没有操作相同的行，也就是说它们的writeset没有交集，就可以并行。</li>
<li>WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ol>
<p>当然为了唯一标识，这个hash值是通过“库名+表名+索引名+值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert语句对应的writeset就要多增加一个hash值。</p>
<p>你可能看出来了，这跟我们前面介绍的基于MySQL 5.5版本的按行分发的策略是差不多的。不过，MySQL官方的这个实现还是有很大的优势：</p>
<ol>
<li>writeset是在主库生成后直接写入到binlog里面的，这样在备库执行的时候，不需要解析binlog内容（event里的行数据），节省了很多计算量；</li>
<li>不需要把整个事务的binlog都扫一遍才能决定分发到哪个worker，更省内存；</li>
<li>由于备库的分发策略不依赖于binlog内容，所以binlog是statement格式也是可以的。</li>
</ol>
<p>因此，MySQL 5.7.22的并行复制策略在通用性上还是有保证的。</p>
<p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET策略也是没法并行的，也会暂时退化为单线程模型。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在今天这篇文章中，我和你介绍了MySQL的各种多线程复制策略。</p>
<p>为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值越来越大。</p>
<p>在介绍完每个并行复制策略后，我还和你分享了不同策略的优缺点：</p>
<ul>
<li>如果你是DBA，就需要根据不同的业务场景，选择不同的策略；</li>
<li>如果是你业务开发人员，也希望你能从中获取灵感用到平时的开发工作中。</li>
</ul>
<p>从这些分析中，你也会发现大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。因此，在平时的开发工作中，我建议你尽量减少大事务操作，把大事务拆成小事务。</p>
<p>官方MySQL5.7版本新增的备库并行策略，修改了binlog的内容，也就是说binlog协议并不是向上兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>假设一个MySQL 5.7.22版本的主库，单线程插入了很多数据，过了3个小时后，我们要给这个主库搭建一个相同版本的备库。</p>
<p>这时候，你为了更快地让备库追上主库，要开并行复制。在binlog-transaction-dependency-tracking参数的COMMIT_ORDER、WRITESET和WRITE_SESSION这三个取值中，你会选择哪一个呢？</p>
<p>你选择的原因是什么？如果设置另外两个参数，你认为会出现什么现象呢？</p>
<p>你可以把你的答案和分析写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，什么情况下，备库的主备延迟会表现为一个45度的线段？评论区有不少同学的回复都说到了重点：备库的同步在这段时间完全被堵住了。</p>
<p>产生这种现象典型的场景主要包括两种：</p>
<ul>
<li>一种是大事务（包括大表DDL、一个事务操作很多行）；</li>
<li>还有一种情况比较隐蔽，就是备库起了一个长事务，比如</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>然后就不动了。</p>
<p>这时候主库对表t做了一个加字段操作，即使这个表很小，这个DDL在备库应用的时候也会被堵住，也不能看到这个现象。</p>
<p>评论区还有同学说是不是主库多线程、从库单线程，备库跟不上主库的更新节奏导致的？今天这篇文章，我们刚好讲的是并行复制。所以，你知道了，这种情况会导致主备延迟，但不会表现为这种标准的呈45度的直线。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@易翔 、 @万勇、@老杨同志 等同学的回复都提到了我们上面说的场景；</p>
</blockquote>
<blockquote>
<p>@Max 同学提了一个很不错的问题。主备关系里面，备库主动连接，之后的binlog发送是主库主动推送的。之所以这么设计也是为了效率和实时性考虑，毕竟靠备库轮询，会有时间差。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>27 | 主库出问题了，从库怎么办</title>
    <url>/posts/e94eb81.html</url>
    <content><![CDATA[<p>在前面的第<a href="https://time.geekbang.org/column/article/76446">24</a>、<a href="https://time.geekbang.org/column/article/76795">25</a>和<a href="https://time.geekbang.org/column/article/77083">26</a>篇文章中，我和你介绍了MySQL主备复制的基础结构，但这些都是一主一备的结构。</p>
<p>大多数的互联网应用场景都是读多写少，因此你负责的业务，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，就要涉及到接下来两篇文章要讨论的架构：一主多从。</p>
<span id="more"></span>

<p>今天这篇文章，我们就先聊聊一主多从的切换正确性。然后，我们在下一篇文章中再聊聊解决一主多从的查询逻辑正确性的方法。</p>
<p>如图1所示，就是一个基本的一主多从结构。</p>
<p><img src="https://static001.geekbang.org/resource/image/aa/79/aadb3b956d1ffc13ac46515a7d619e79.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 一主多从基本结构</b>
    </div>
    <br>
</center>

<p>图中，虚线箭头表示的是主备关系，也就是A和A’互为主备， 从库B、C、D指向的是主库A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
<p>今天我们要讨论的就是，在一主多从架构下，主库故障后的主备切换问题。</p>
<p>如图2所示，就是主库发生故障，主备切换后的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/00/53/0014f97423bd75235a9187f492fb2453.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 一主多从基本结构--主备切换</b>
    </div>
    <br>
</center>

<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库B、C、D也要改接到A’。正是由于多了从库B、C、D重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<p>接下来，我们再一起看看一个切换系统会怎么完成一主多从的主备切换过程。</p>
<h1 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h1><p>这里，我们需要先来回顾一个知识点。</p>
<p>当我们把节点B设置成节点A’的从库的时候，需要执行一条change master命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST<span class="operator">=</span>$host_name </span><br><span class="line">MASTER_PORT<span class="operator">=</span>$port </span><br><span class="line">MASTER_USER<span class="operator">=</span>$user_name </span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span>$password </span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span>$master_log_name </span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>$master_log_pos</span><br></pre></td></tr></table></figure>

<p>这条命令有这么6个参数：</p>
<ul>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER和MASTER_PASSWORD四个参数，分别代表了主库A’的IP、端口、用户名和密码。</li>
<li>最后两个参数MASTER_LOG_FILE和MASTER_LOG_POS表示，要从主库的master_log_name文件的master_log_pos这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ul>
<p>那么，这里就有一个问题了，节点B要设置成A’的从库，就要执行change master命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？</p>
<p>原来节点B是A的从库，本地记录的也是A的位点。但是相同的日志，A的位点和A’的位点是不同的。因此，从库B要切换的时候，就需要先经过“找同步位点”这个逻辑。</p>
<p>这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？</p>
<p>我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。</p>
<p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库B上已经执行过的事务。</p>
<p>一种取同步位点的方法是这样的：</p>
<ol>
<li>等待新主库A’把中转日志（relay log）全部同步完成；</li>
<li>在A’上执行show master status命令，得到当前A’上最新的File 和 Position；</li>
<li>取原主库A故障的时刻T；</li>
<li>用mysqlbinlog工具解析A’的File，得到T时刻的位点。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog File --stop-datetime=T --start-datetime=T</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/34/dd/3471dfe4aebcccfaec0523a08cdd0ddd.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 mysqlbinlog 部分输出结果</b>
    </div>
    <br>
</center>

<p>图中，end_log_pos后面的值“123”，表示的就是A’这个实例，在T时刻写入新的binlog的位置。然后，我们就可以把123这个值作为$master_log_pos ，用在节点B的change master命令里。</p>
<p>当然这个值并不精确。为什么呢？</p>
<p>你可以设想有这么一种情况，假设在T这个时刻，主库A已经执行完成了一个insert 语句插入了一行数据R，并且已经将binlog传给了A’和B，然后在传完的瞬间主库A的主机就掉电了。</p>
<p>那么，这时候系统的状态是这样的：</p>
<ol>
<li>在从库B上，由于同步了binlog， R这一行已经存在；</li>
<li>在新主库A’上， R这一行也已经存在，日志是写在123这个位置之后的；</li>
<li>我们在从库B上执行change master命令，指向A’的File文件的123位置，就会把插入R这一行数据的binlog又同步到从库B去执行。</li>
</ol>
<p>这时候，从库B的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p>
<p>所以，<strong>通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</strong></p>
<p><strong>一种做法是</strong>，主动跳过一个事务。跳过命令的写法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>

<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库B刚开始接到新主库A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
<p><strong>另外一种方式是，</strong> 通过设置slave_skip_errors参数，直接设置跳过指定的错误。</p>
<p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ul>
<li>1062错误是插入数据时唯一键冲突；</li>
<li>1032错误是删除数据时找不到行。</li>
</ul>
<p>因此，我们可以把slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p>
<p>这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p>
<p>这个背景是，我们很清楚在主备切换过程中，直接跳过1032和1062这两类错误是无损的，所以才可以这么设置slave_skip_errors参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p>
<h1 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h1><p>通过sql_slave_skip_counter跳过事务和通过slave_skip_errors忽略错误的方法，虽然都最终可以建立从库B和新主库A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6版本引入了GTID，彻底解决了这个困难。</p>
<p>那么，GTID到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍一下。</p>
<p>GTID的全称是Global Transaction Identifier，也就是全局事务ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GTID<span class="operator">=</span>server_uuid:gno</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>server_uuid是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li>
<li>gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务，并加1。</li>
</ul>
<p>这里我需要和你说明一下，在MySQL的官方文档里，GTID格式是这么定义的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GTID<span class="operator">=</span>source_id:transaction_id</span><br></pre></td></tr></table></figure>

<p>这里的source_id就是server_uuid；而后面的这个transaction_id，我觉得容易造成误导，所以我改成了gno。为什么说使用transaction_id容易造成误解呢？</p>
<p>因为，在MySQL里面我们说transaction_id就是指事务id，事务id是在事务执行过程中分配的，如果这个事务回滚了，事务id也会递增，而gno是在事务提交的时候才会分配。</p>
<p>从效果上看，GTID往往是连续的，因此我们用gno来表示更容易理解。</p>
<p>GTID模式的启动也很简单，我们只需要在启动一个MySQL实例的时候，加上参数gtid_mode&#x3D;on和enforce_gtid_consistency&#x3D;on就可以了。</p>
<p>在GTID模式下，每个事务都会跟一个GTID一一对应。这个GTID有两种生成方式，而使用哪种方式取决于session变量gtid_next的值。</p>
<ol>
<li>如果gtid_next&#x3D;automatic，代表使用默认值。这时，MySQL就会把server_uuid:gno分配给这个事务。<br>a. 记录binlog的时候，先记录一行 SET @@SESSION.GTID_NEXT&#x3D;‘server_uuid:gno’;<br>b. 把这个GTID加入本实例的GTID集合。</li>
<li>如果gtid_next是一个指定的GTID的值，比如通过set gtid_next&#x3D;’current_gtid’指定为current_gtid，那么就有两种可能：<br>a. 如果current_gtid已经存在于实例的GTID集合中，接下来执行的这个事务会直接被系统忽略；<br>b. 如果current_gtid没有存在于实例的GTID集合中，就将这个current_gtid分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的GTID，因此gno也不用加1。</li>
</ol>
<p>注意，一个current_gtid只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行set 命令，把gtid_next设置成另外一个gtid或者automatic。</p>
<p>这样，每个MySQL实例都维护了一个GTID集合，用来对应“这个实例执行过的所有事务”。</p>
<p>这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明GTID的基本用法。</p>
<p>我们在实例X中创建一个表t。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/28/c2/28a5cab0079fb12fd5abecd92b3324c2.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 初始化数据的binlog</b>
    </div>
    <br>
</center>

<p>可以看到，事务的BEGIN之前有一条SET @@SESSION.GTID_NEXT命令。这时，如果实例X有从库，那么将CREATE TABLE和insert语句的binlog同步过去执行的话，执行事务之前就会先执行这两个SET命令， 这样被加入从库的GTID集合的，就是图中的这两个GTID。</p>
<p>假设，现在这个实例X是另外一个实例Y的从库，并且此时在实例Y上执行了下面这条插入语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>并且，这条语句在实例Y上的GTID是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p>
<p>那么，实例X作为Y的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例X的同步线程停止。这时，我们应该怎么处理呢？</p>
<p>处理方法就是，你可以执行下面的这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span><span class="string">&#x27;aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10&#x27;</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span>automatic;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>

<p>其中，前三条语句的作用，是通过提交一个空事务，把这个GTID加到实例X的GTID集合中。如图5所示，就是执行完这个空事务之后的show master status的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/c8/57/c8d3299ece7d583a3ecd1557851ed157.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 show master status结果</b>
    </div>
    <br>
</center>

<p>可以看到实例X的Executed_Gtid_set里面，已经加入了这个GTID。</p>
<p>这样，我再执行start slave命令让同步线程执行起来的时候，虽然实例X上还是会继续执行实例Y传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例X的GTID集合中了，所以实例X就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p>
<p>在上面的这个语句序列中，start slave命令之前还有一句set gtid_next&#x3D;automatic。这句话的作用是“恢复GTID的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配gno&#x3D;3。</p>
<h1 id="基于GTID的主备切换"><a href="#基于GTID的主备切换" class="headerlink" title="基于GTID的主备切换"></a>基于GTID的主备切换</h1><p>现在，我们已经理解GTID的概念，再一起来看看基于GTID的主备复制的用法。</p>
<p>在GTID模式下，备库B要设置为新主库A’的从库的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST<span class="operator">=</span>$host_name </span><br><span class="line">MASTER_PORT<span class="operator">=</span>$port </span><br><span class="line">MASTER_USER<span class="operator">=</span>$user_name </span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span>$password </span><br><span class="line">master_auto_position<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>其中，master_auto_position&#x3D;1就表示这个主备关系使用的是GTID协议。可以看到，前面让我们头疼不已的MASTER_LOG_FILE和MASTER_LOG_POS参数，已经不需要指定了。</p>
<p>我们把现在这个时刻，实例A’的GTID集合记为set_a，实例B的GTID集合记为set_b。接下来，我们就看看现在的主备切换逻辑。</p>
<p>我们在实例B上执行start slave命令，取binlog的逻辑是这样的：</p>
<ol>
<li>实例B指定主库A’，基于主备协议建立连接。</li>
<li>实例B把set_b发给主库A’。</li>
<li>实例A’算出set_a与set_b的差集，也就是所有存在于set_a，但是不存在于set_b的GITD的集合，判断A’本地是否包含了这个差集需要的所有binlog事务。<br>a. 如果不包含，表示A’已经把实例B需要的binlog给删掉了，直接返回错误；<br>b. 如果确认全部包含，A’从自己的binlog文件里面，找出第一个不在set_b的事务，发给B；</li>
<li>之后就从这个事务开始，往后读文件，按顺序取binlog发给B去执行。</li>
</ol>
<p>其实，这个逻辑里面包含了一个设计思想：在基于GTID的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例B需要的日志已经不存在，A’就拒绝把日志发给B。</p>
<p>这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p>
<p>基于上面的介绍，我们再来看看引入GTID后，一主多从的切换场景下，主备切换是如何实现的。</p>
<p>由于不需要找位点了，所以从库B、C、D只需要分别执行change master命令指向实例A’即可。</p>
<p>其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例A’内部就已经自动完成了。但由于这个工作是自动的，所以对HA系统的开发人员来说，非常友好。</p>
<p>之后这个系统就由新主库A’写入，主库A’的自己生成的binlog中的GTID集合格式是：server_uuid_of_A’:1-M。</p>
<p>如果之前从库B的GTID集合格式是 server_uuid_of_A:1-N， 那么切换之后GTID集合的格式就变成了server_uuid_of_A:1-N, server_uuid_of_A’:1-M。</p>
<p>当然，主库A’之前也是A的备库，因此主库A’和从库B的GTID集合是一样的。这就达到了我们预期。</p>
<h1 id="GTID和在线DDL"><a href="#GTID和在线DDL" class="headerlink" title="GTID和在线DDL"></a>GTID和在线DDL</h1><p>接下来，我再举个例子帮你理解GTID。</p>
<p>之前在第22篇文章<a href="https://time.geekbang.org/column/article/75746">《MySQL有哪些“饮鸩止渴”提高性能的方法？》</a>中，我和你提到业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。</p>
<p>当时我说，在双M结构下，备库执行的DDL语句也会传给主库，为了避免传回后对主库造成影响，要通过set sql_log_bin&#x3D;off关掉binlog。</p>
<p>评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是binlog并没有记录下这一个更新，是不是会导致数据和日志不一致？</p>
<p>这个问题提得非常好。当时，我在留言的回复中就引用了GTID来说明。今天，我再和你展开说明一下。</p>
<p>假设，这两个互为主备关系的库还是实例X和实例Y，且当前主库是X，并且都打开了GTID模式。这时的主备切换流程可以变成下面这样：</p>
<ul>
<li>在实例X上执行stop slave。</li>
<li>在实例Y上执行DDL语句。注意，这里并不需要关闭binlog。</li>
<li>执行完成后，查出这个DDL语句对应的GTID，并记为 server_uuid_of_Y:gno。</li>
<li>到实例X上执行以下语句序列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> GTID_NEXT<span class="operator">=</span>&quot;server_uuid_of_Y:gno&quot;;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next<span class="operator">=</span>automatic;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>

<p>这样做的目的在于，既可以让实例Y的更新有binlog记录，同时也可以确保不会在实例X上执行这条更新。</p>
<ul>
<li>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在今天这篇文章中，我先和你介绍了一主多从的主备切换流程。在这个过程中，从库找新主库的位点是一个痛点。由此，我们引出了MySQL 5.6版本引入的GTID模式，介绍了GTID的基本概念和用法。</p>
<p>可以看到，在GTID模式下，一主多从切换就非常方便了。</p>
<p>因此，如果你使用的MySQL版本支持GTID的话，我都建议你尽量使用GTID模式来做一主多从的切换。</p>
<p>在下一篇文章中，我们还能看到GTID模式在读写分离场景的应用。</p>
<p>最后，又到了我们的思考题时间。</p>
<p>你在GTID模式下设置主从关系的时候，从库执行start slave命令后，主库发现需要的binlog已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p>
<p>你可以把你的方法写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上一篇文章最后，我给你留的问题是，如果主库都是单线程压力模式，在从库追主库的过程中，binlog-transaction-dependency-tracking 应该选用什么参数？</p>
<p>这个问题的答案是，应该将这个参数设置为WRITESET。</p>
<p>由于主库是单线程压力模式，所以每个事务的commit_id都不同，那么设置为COMMIT_ORDER模式的话，从库也只能单线程执行。</p>
<p>同样地，由于WRITESET_SESSION模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。</p>
<p>所以，应该将binlog-transaction-dependency-tracking 设置为WRITESET。</p>
<p><strong>评论区留言点赞板：</strong></p>
<blockquote>
<p>@慧鑫coming 问了一个好问题，对同一行作更新的几个事务，如果commit_id相同，是不是在备库并行执行的时候会导致数据不一致？这个问题的答案是更新同一行的事务是不可能同时进入commit状态的。<br>@老杨同志 对这个问题给出了更详细的回答，大家可以去看一下。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>29 | 如何判断一个数据库是不是出问题了</title>
    <url>/posts/80fd8be0.html</url>
    <content><![CDATA[<p>我在第<a href="https://time.geekbang.org/column/article/76795">25</a>和<a href="https://time.geekbang.org/column/article/77427">27</a>篇文章中，和你介绍了主备切换流程。通过这些内容的讲解，你应该已经很清楚了：在一主一备的双M架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。</p>
<p>主备切换有两种场景，一种是主动切换，一种是被动切换。而其中被动切换，往往是因为主库出问题了，由HA系统发起的。</p>
<span id="more"></span>

<p>这也就引出了我们今天要讨论的问题：怎么判断一个主库出问题了？</p>
<p>你一定会说，这很简单啊，连上MySQL，执行个select 1就好了。但是select 1成功返回了，就表示主库没问题吗？</p>
<h1 id="select-1判断"><a href="#select-1判断" class="headerlink" title="select 1判断"></a>select 1判断</h1><p>实际上，select 1成功返回，只能说明这个库的进程还在，并不能说明主库没问题。现在，我们来看一下这个场景。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_thread_concurrency<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/35/55/35076dd3d0a0d44d22b76d2a29885255.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 查询blocked</b>
    </div>
    <br>
</center>

<p>我们设置innodb_thread_concurrency参数的目的是，控制InnoDB的并发线程上限。也就是说，一旦并发线程数达到这个值，InnoDB在接收到新请求的时候，就会进入等待状态，直到有线程退出。</p>
<p>这里，我把innodb_thread_concurrency设置成3，表示InnoDB只允许3个线程并行执行。而在我们的例子中，前三个session 中的sleep(100)，使得这三个语句都处于“执行”状态，以此来模拟大查询。</p>
<p>你看到了， session D里面，select 1是能执行成功的，但是查询表t的语句会被堵住。也就是说，如果这时候我们用select 1来检测实例是否正常的话，是检测不出问题的。</p>
<p>在InnoDB中，innodb_thread_concurrency这个参数的默认值是0，表示不限制并发线程数量。但是，不限制并发线程数肯定是不行的。因为，一个机器的CPU核数有限，线程全冲进来，上下文切换的成本就会太高。</p>
<p>所以，通常情况下，我们建议把innodb_thread_concurrency设置为64~128之间的值。这时，你一定会有疑问，并发线程上限数设置为128够干啥，线上的并发连接数动不动就上千了。</p>
<p>产生这个疑问的原因，是搞混了<strong>并发连接和并发查询。</strong></p>
<p>并发连接和并发查询，并不是同一个概念。你在show processlist的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。</p>
<p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是CPU杀手。这也是为什么我们需要设置innodb_thread_concurrency参数的原因。</p>
<p>然后，你可能还会想起我们在<a href="https://time.geekbang.org/column/article/70215">第7篇文章</a>中讲到的热点更新和死锁检测的时候，如果把innodb_thread_concurrency设置为128的话，那么出现同一行热点更新的问题时，是不是很快就把128消耗完了，这样整个系统是不是就挂了呢？</p>
<p>实际上，<strong>在线程进入锁等待以后，并发线程的计数会减一</strong>，也就是说等行锁（也包括间隙锁）的线程是不算在128里面的。</p>
<p>MySQL这样设计是非常有意义的。因为，进入锁等待的线程已经不吃CPU了；更重要的是，必须这么设计，才能避免整个系统锁死。</p>
<p>为什么呢？假设处于锁等待的线程也占并发线程的计数，你可以设想一下这个场景：</p>
<ol>
<li>线程1执行begin; update t set c&#x3D;c+1 where id&#x3D;1, 启动了事务trx1， 然后保持这个状态。这时候，线程处于空闲状态，不算在并发线程里面。</li>
<li>线程2到线程129都执行 update t set c&#x3D;c+1 where id&#x3D;1; 由于等行锁，进入等待状态。这样就有128个线程处于等待状态；</li>
<li>如果处于锁等待状态的线程计数不减一，InnoDB就会认为线程数用满了，会阻止其他语句进入引擎执行，这样线程1不能提交事务。而另外的128个线程又处于锁等待状态，整个系统就堵住了。</li>
</ol>
<p>下图2显示的就是这个状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/32/1d/3206ea18b8a24b546515b1b95dc4a11d.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 系统锁死状态（假设等行锁的语句占用并发计数）</b>
    </div>
    <br>
</center>

<p>这时候InnoDB不能响应任何请求，整个系统被锁死。而且，由于所有线程都处于等待状态，此时占用的CPU却是0，而这明显不合理。所以，我们说InnoDB在设计时，遇到进程进入锁等待的情况时，将并发线程的计数减1的设计，是合理而且是必要的。</p>
<p>虽然说等锁的线程不算在并发线程计数里，但如果它在真正地执行查询，就比如我们上面例子中前三个事务中的select sleep(100) from t，还是要算进并发线程的计数的。</p>
<p>在这个例子中，同时在执行的语句超过了设置的innodb_thread_concurrency的值，这时候系统其实已经不行了，但是通过select 1来检测系统，会认为系统还是正常的。</p>
<p>因此，我们使用select 1的判断逻辑要修改一下。</p>
<h1 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h1><p>为了能够检测InnoDB并发线程数过多导致的系统不可用情况，我们需要找一个访问InnoDB的场景。一般的做法是，在系统库（mysql库）里创建一个表，比如命名为health_check，里面只放一行数据，然后定期执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check;</span><br></pre></td></tr></table></figure>

<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p>
<p>但是，我们马上还会碰到下一个问题，即：空间满了以后，这种方法又会变得不好使。</p>
<p>我们知道，更新事务要写binlog，而一旦binlog所在磁盘的空间占用率达到100%，那么所有的更新语句和事务提交的commit语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>
<p>因此，我们还是把这条监控语句再改进一下。接下来，我们就看看把查询语句改成更新语句后的效果。</p>
<h1 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h1><p>既然要更新，就要放个有意义的字段，常见做法是放一个timestamp字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure>

<p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p>
<p>但，备库的检测也是要写binlog的。由于我们一般会把数据库A和B的主备关系设计为双M结构，所以在备库B上执行的检测命令，也要发回给主库A。</p>
<p>但是，如果主库A和备库B都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来mysql.health_check 这个表就不能只有一行数据了。</p>
<p>为了让主备之间的更新不产生冲突，我们可以在mysql.health_check表上存入多行数据，并用A、B的server_id做主键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `health_check` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(id, t_modified) <span class="keyword">values</span> (@<span class="variable">@server_id</span>, now()) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></table></figure>

<p>由于MySQL规定了主库和备库的server_id必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p>
<p>更新判断是一个相对比较常用的方案了，不过依然存在一些问题。其中，“判定慢”一直是让DBA头疼的问题。</p>
<p>你一定会疑惑，<strong>更新语句，如果失败或者超时，就可以发起主备切换了，为什么还会有判定慢的问题呢？</strong></p>
<p>其实，这里涉及到的是服务器IO资源分配的问题。</p>
<p>首先，所有的检测逻辑都需要一个超时时间N。执行一条update语句，超过N秒后还不返回，就认为系统不可用。</p>
<p>你可以设想一个日志盘的IO利用率已经是100%的场景。这时候，整个系统响应非常慢，已经需要做主备切换了。</p>
<p>但是你要知道，IO利用率100%表示系统的IO是在工作的，每个请求都有机会获得IO资源，执行自己的任务。而我们的检测使用的update命令，需要的资源很少，所以可能在拿到IO资源的时候就可以提交成功，并且在超时时间N秒未到达之前就返回给了检测系统。</p>
<p>检测系统一看，update命令没有超时，于是就得到了“系统正常”的结论。</p>
<p>也就是说，这时候在业务系统上正常的SQL语句已经执行得很慢了，但是DBA上去一看，HA系统还在正常工作，并且认为主库现在处于可用状态。</p>
<p>之所以会出现这个现象，根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。</p>
<p>因为，外部检测都需要定时轮询，所以系统可能已经出问题了，但是却需要等到下一个检测发起执行语句的时候，我们才有可能发现问题。而且，如果你的运气不够好的话，可能第一次轮询还不能发现，这就会导致切换慢的问题。</p>
<p>所以，接下来我要再和你介绍一种在MySQL内部发现数据库问题的方法。</p>
<h1 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h1><p>针对磁盘利用率这个问题，如果MySQL可以告诉我们，内部每一次IO请求的时间，那我们判断数据库是否出问题的方法就可靠得多了。</p>
<p>其实，MySQL 5.6版本以后提供的performance_schema库，就在file_summary_by_event_name表里统计了每次IO请求的时间。</p>
<p>file_summary_by_event_name表里有很多行数据，我们先来看看event_name&#x3D;’wait&#x2F;io&#x2F;file&#x2F;innodb&#x2F;innodb_log_file’这一行。</p>
<p><img src="https://static001.geekbang.org/resource/image/75/dd/752ccfe43b4eab155be17401838c62dd.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 performance_schema.file_summary_by_event_name的一行</b>
    </div>
    <br>
</center>

<p>图中这一行表示统计的是redo log的写入时间，第一列EVENT_NAME 表示统计的类型。</p>
<p>接下来的三组数据，显示的是redo log操作的时间统计。</p>
<p>第一组五列，是所有IO类型的统计。其中，COUNT_STAR是所有IO的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p>
<p>第二组六列，是读操作的统计。最后一列SUM_NUMBER_OF_BYTES_READ统计的是，总共从redo log里读了多少个字节。</p>
<p>第三组六列，统计的是写操作。</p>
<p>最后的第四组数据，是对其他类型数据的统计。在redo log里，你可以认为它们就是对fsync的统计。</p>
<p>在performance_schema库的file_summary_by_event_name表里，binlog对应的是event_name &#x3D; “wait&#x2F;io&#x2F;file&#x2F;sql&#x2F;binlog”这一行。各个字段的统计逻辑，与redo log的各个字段完全相同。这里，我就不再赘述了。</p>
<p>因为我们每一次操作数据库，performance_schema都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗的。</p>
<p>我的测试结果是，如果打开所有的performance_schema项，性能大概会下降10%左右。所以，我建议你只打开自己需要的项进行统计。你可以通过下面的方法打开或者关闭某个具体项的统计。</p>
<p>如果要打开redo log的时间监控，你可以执行这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> setup_instruments <span class="keyword">set</span> ENABLED<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span>, Timed<span class="operator">=</span><span class="string">&#x27;YES&#x27;</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%wait/io/file/innodb/innodb_log_file%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>假设，现在你已经开启了redo log和binlog这两个统计信息，那要怎么把这个信息用在实例状态诊断上呢？</p>
<p>很简单，你可以通过MAX_TIMER的值来判断数据库是否出问题了。比如，你可以设定阈值，单次IO请求时间超过200毫秒属于异常，然后使用类似下面这条语句作为检测逻辑。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> event_name,MAX_TIMER_WAIT  <span class="keyword">FROM</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name <span class="keyword">in</span> (<span class="string">&#x27;wait/io/file/innodb/innodb_log_file&#x27;</span>,<span class="string">&#x27;wait/io/file/sql/binlog&#x27;</span>) <span class="keyword">and</span> MAX_TIMER_WAIT<span class="operator">&gt;</span><span class="number">200</span><span class="operator">*</span><span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure>

<p>发现异常后，取到你需要的信息，再通过下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">truncate</span> <span class="keyword">table</span> performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure>

<p>把之前的统计信息清空。这样如果后面的监控中，再次出现这个异常，就可以加入监控累积值了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你介绍了检测一个MySQL实例健康状态的几种方法，以及各种方法存在的问题和演进的逻辑。</p>
<p>你看完后可能会觉得，select 1这样的方法是不是已经被淘汰了呢，但实际上使用非常广泛的MHA（Master High Availability），默认使用的就是这个方法。</p>
<p>MHA中的另一个可选方法是只做连接，就是 “如果连接成功就认为主库没问题”。不过据我所知，选择这个方法的很少。</p>
<p>其实，每个改进的方案，都会增加额外损耗，并不能用“对错”做直接判断，需要你根据业务实际情况去做权衡。</p>
<p>我个人比较倾向的方案，是优先考虑update系统表，然后再配合增加检测performance_schema的信息。</p>
<p>最后，又到了我们的思考题时间。</p>
<p>今天，我想问你的是：业务系统一般也有高可用的需求，在你开发和维护过的服务中，你是怎么判断服务有没有出问题的呢？</p>
<p>你可以把你用到的方法和分析写在留言区，我会在下一篇文章中选取有趣的方案一起来分享和分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，如果使用GTID等位点的方案做读写分离，在对大表做DDL的时候会怎么样。</p>
<p>假设，这条语句在主库上要执行10分钟，提交后传到备库就要10分钟（典型的大事务）。那么，在主库DDL之后再提交的事务的GTID，去备库查的时候，就会等10分钟才出现。</p>
<p>这样，这个读写分离机制在这10分钟之内都会超时，然后走主库。</p>
<p>这种预期内的操作，应该在业务低峰期的时候，确保主库能够支持所有业务查询，然后把读请求都切到主库，再在主库上做DDL。等备库延迟追上以后，再把读请求切回备库。</p>
<p>通过这个思考题，我主要想让关注的是，大事务对等位点方案的影响。</p>
<p>当然了，使用gh-ost方案来解决这个问题也是不错的选择。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@曾剑、@max 同学提到的备库先做，再切主库的方法也是可以的。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>28 | 读写分离有哪些坑</title>
    <url>/posts/fe19078.html</url>
    <content><![CDATA[<p>在上一篇文章中，我和你介绍了一主多从的结构以及切换流程。今天我们就继续聊聊一主多从架构的应用场景：读写分离，以及怎么处理主备延迟导致的读写分离问题。</p>
<span id="more"></span>

<p>我们在上一篇文章中提到的一主多从的结构，其实就是读写分离的基本结构了。这里，我再把这张图贴过来，方便你理解。</p>
<p><img src="https://static001.geekbang.org/resource/image/13/aa/1334b9c08b8fd837832fdb2d82e6b0aa.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 读写分离基本结构</b>
    </div>
    <br>
</center>

<p>读写分离的主要目标就是分摊主库的压力。图1中的结构是客户端（client）主动做负载均衡，这种模式下一般会把数据库的连接信息放在客户端的连接层。也就是说，由客户端来选择后端数据库进行查询。</p>
<p>还有一种架构是，在MySQL和客户端之间有一个中间代理层proxy，客户端只连接proxy， 由proxy根据请求类型和上下文决定请求的分发路由。</p>
<p><img src="https://static001.geekbang.org/resource/image/06/18/065ef246c59019effc8384967d774318.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 带proxy的读写分离架构</b>
    </div>
    <br>
</center>接下来，我们就看一下客户端直连和带proxy的读写分离架构，各有哪些特点。


<ol>
<li>客户端直连方案，因为少了一层proxy转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。<br>你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带proxy的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由proxy完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy也需要有高可用架构。因此，带proxy架构的整体就相对比较复杂。</li>
</ol>
<p>理解了这两种方案的优劣，具体选择哪个方案就取决于数据库团队提供的能力了。但目前看，趋势是往带proxy的架构方向发展的。</p>
<p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p><strong>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</strong></p>
<p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能100%避免的。</p>
<p>不论哪种结构，客户端都希望查询从库的数据结果，跟查主库的数据结果是一样的。</p>
<p>接下来，我们就来讨论怎么处理过期读问题。</p>
<p>这里，我先把文章中涉及到的处理过期读的方案汇总在这里，以帮助你更好地理解和掌握全文的知识脉络。这些方案包括：</p>
<ul>
<li>强制走主库方案；</li>
<li>sleep方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合semi-sync方案；</li>
<li>等主库位点方案；</li>
<li>等GTID方案。</li>
</ul>
<h1 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h1><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p>
<ol>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ol>
<p>你可能会说，这个方案是不是有点畏难和取巧的意思，但其实这个方案是用得最多的。</p>
<p>当然，这个方案最大的问题在于，有时候你会碰到“所有查询都不能是过期读”的需求，比如一些金融类的业务。这样的话，你就要放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性。</p>
<p>因此接下来，我们来讨论的话题是：可以支持读写分离的场景下，有哪些解决过期读的方案，并分析各个方案的优缺点。</p>
<h1 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h1><p>主库更新后，读从库之前先sleep一下。具体的方案就是，类似于执行一条select sleep(1)命令。</p>
<p>这个方案的假设是，大多数情况下主备延迟在1秒之内，做一个sleep可以有很大概率拿到最新的数据。</p>
<p>这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接在发起查询时先执行一条sleep语句，用户体验很不友好啊。</p>
<p>但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。</p>
<p>以卖家发布商品为例，商品发布后，用Ajax（Asynchronous JavaScript + XML，异步JavaScript和XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。</p>
<p>这样，卖家就可以通过这个显示，来确认产品已经发布成功了。等到卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了sleep的目的，进而也就解决了过期读的问题。</p>
<p>也就是说，这个sleep方案确实解决了类似场景下的过期读问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：</p>
<ol>
<li>如果这个查询请求本来0.5秒就可以在从库上拿到正确结果，也会等1秒；</li>
<li>如果延迟超过1秒，还是会出现过期读。</li>
</ol>
<p>看到这里，你是不是有一种“你是不是在逗我”的感觉，这个改进方案虽然可以解决类似Ajax场景下的过期读问题，但还是怎么看都不靠谱儿。别着急，接下来我就和你介绍一些更准确的方案。</p>
<h1 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h1><p>要确保备库无延迟，通常有三种做法。</p>
<p>通过前面的<a href="https://time.geekbang.org/column/article/76795">第25篇</a>文章，我们知道show slave status结果里的seconds_behind_master参数的值，可以用来衡量主备延迟时间的长短。</p>
<p>所以<strong>第一种确保主备无延迟的方法是，</strong> 每次从库执行查询请求前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p>
<p>seconds_behind_master的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和GTID的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p>
<p>如图3所示，是一个show slave status结果的部分截图。</p>
<p><img src="https://static001.geekbang.org/resource/image/00/c1/00110923007513e865d7f43a124887c1.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 show slave status结果</b>
    </div>
    <br>
</center>

<p>现在，我们就通过这个结果，来看看具体如何通过对比位点和GTID来确保主备无延迟。</p>
<p><strong>第二种方法，</strong> 对比位点确保主备无延迟：</p>
<ul>
<li>Master_Log_File和Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_File和Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果Master_Log_File和Relay_Master_Log_File、Read_Master_Log_Pos和Exec_Master_Log_Pos这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<p><strong>第三种方法，</strong> 对比GTID集合确保主备无延迟：</p>
<ul>
<li>Auto_Position&#x3D;1 ，表示这对主备关系使用了GTID协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的GTID集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的GTID集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比GTID这两种方法，都要比判断seconds_behind_master是否为0更准确。</p>
<p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于sleep方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p>
<p>我们现在一起来回顾下，一个事务的binlog在主备库之间的状态：</p>
<ol>
<li>主库执行完成，写入binlog，并反馈给客户端；</li>
<li>binlog被从主库发送给备库，备库收到；</li>
<li>在备库执行binlog完成。</li>
</ol>
<p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从binlog在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
<p>如图4所示就是这样的一个状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/55/9e/557445207b57d6c0f2747509d7d6619e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 备库还没收到trx3</b>
    </div>
    <br>
</center>

<p>这时，主库上执行完成了三个事务trx1、trx2和trx3，其中：</p>
<ol>
<li>trx1和trx2已经传到从库，并且已经执行完成了；</li>
<li>trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li>
</ol>
<p>如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到trx3的。严格地说，就是出现了过期读。</p>
<p>那么，这个问题有没有办法解决呢？</p>
<h1 id="配合semi-sync"><a href="#配合semi-sync" class="headerlink" title="配合semi-sync"></a>配合semi-sync</h1><p>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。</p>
<p>semi-sync做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把binlog发给从库；</li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li>
<li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果启用了semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p>在<a href="https://time.geekbang.org/column/article/76795">第25篇文章</a>的评论区，有同学问到：如果主库掉电的时候，有些binlog还来不及发给从库，会不会导致系统数据丢失？</p>
<p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但semi-sync就可以解决这个问题。</p>
<p>这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p>
<p>但是，semi-sync+位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ol>
<li>如果查询是落在这个响应了ack的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ol>
<p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者GTID集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p>
<p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p>
<p>为什么这么说呢？我们来看一下这个时序图。</p>
<p><img src="https://static001.geekbang.org/resource/image/9c/09/9cf54f3e91dc8f7b8947d7d8e384aa09.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 主备持续延迟一个事务</b>
    </div>
    <br>
</center>

<p>图5所示，就是等待位点方案的一个bad case。图中备库B下的虚线框，分别表示relaylog和binlog中的事务。可以看到，图5中从状态1 到状态4，一直处于延迟一个事务的状态。</p>
<p>备库B一直到状态4都和主库A存在延迟，如果用上面必须等到无延迟才能查询的方案，select语句直到状态4都不能被执行。</p>
<p>但是，其实客户端是在发完trx1更新后发起的select语句，我们只需要确保trx1已经执行完成就可以执行select语句了。也就是说，如果在状态3执行查询请求，得到的就是预期结果了。</p>
<p>到这里，我们小结一下，semi-sync配合判断主备无延迟的方案，存在两个问题：</p>
<ol>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ol>
<p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p>
<h1 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h1><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure>

<p>这条命令的逻辑如下：</p>
<ol>
<li>它是在从库执行的；</li>
<li>参数file和pos指的是主库上的文件名和位置；</li>
<li>timeout可选，设置为正整数N表示这个函数最多等待N秒。</li>
</ol>
<p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p>
<p>当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：</p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回NULL；</li>
<li>如果等待超过N秒，就返回-1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。</li>
</ol>
<p>对于图5中先执行trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p>
<ol>
<li>trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行select master_pos_wait(File, Position, 1)；</li>
<li>如果返回值是&gt;&#x3D;0的正整数，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p>我把上面这个流程画出来。</p>
<p><img src="https://static001.geekbang.org/resource/image/b2/57/b20ae91ea46803df1b63ed683e1de357.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 master_pos_wait方案</b>
    </div>
    <br>
</center>

<p>这里我们假设，这条select查询最多在从库上等待1秒。那么，如果1秒内master_pos_wait返回一个大于等于0的整数，就确保了从库上执行的这个查询结果一定包含了trx1的数据。</p>
<p>步骤5到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p>
<p>你可能会说，如果所有的从库都延迟超过1秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p>
<p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p>
<h1 id="GTID方案"><a href="#GTID方案" class="headerlink" title="GTID方案"></a>GTID方案</h1><p>如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。</p>
<p>MySQL中同样提供了一个类似的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这条命令的逻辑是：</p>
<ol>
<li>等待，直到这个库执行的事务中包含传入的gtid_set，返回0；</li>
<li>超时返回1。</li>
</ol>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行show master status。而MySQL 5.7.6版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，这样等GTID的方案就可以减少一次查询。</p>
<p>这时，等GTID的执行流程就变成了：</p>
<ol>
<li>trx1事务更新完成后，从返回包直接获取这个事务的GTID，记为gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li>
<li>如果返回值是0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ol>
<p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p>
<p>我把这个流程图画出来。</p>
<p><img src="https://static001.geekbang.org/resource/image/d5/39/d521de8017297aff59db2f68170ee739.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 wait_for_executed_gtid_set方案</b>
    </div>
    <br>
</center>

<p>在上面的第一步中，trx1事务更新完成后，从返回包直接获取这个事务的GTID。问题是，怎么能够让MySQL在执行事务后，返回包中带上GTID呢？</p>
<p>你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可。</p>
<p>在专栏的<a href="https://time.geekbang.org/column/article/68319">第一篇文章</a>中，我介绍mysql_reset_connection的时候，评论区有同学留言问这类接口应该怎么使用。</p>
<p>这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的API(<a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html</a>)。</p>
<p>比如，为了让客户端在事务提交后，返回的GITD能够在客户端显示出来，我对MySQL客户端代码做了点修改，如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/97/63/973bdd8741f830acebe005cbf37a7663.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 显示更新事务的GTID--代码</b>
    </div>
    <br>
</center>

<p>这样，就可以看到语句执行完成，显示出GITD的值。</p>
<p><img src="https://static001.geekbang.org/resource/image/25/fe/253106d31d9d97aaa2846b2015f593fe.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 显示更新事务的GTID--效果</b>
    </div>
    <br>
</center>

<p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用mysql_session_track_get_first这个函数。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在今天这篇文章中，我跟你介绍了一主多从做读写分离时，可能碰到过期读的原因，以及几种应对的方案。</p>
<p>这几种方案中，有的方案看上去是做了妥协，有的方案看上去不那么靠谱儿，但都是有实际应用场景的，你需要根据业务需求选择。</p>
<p>即使是最后等待位点和等待GTID这两个方案，虽然看上去比较靠谱儿，但仍然存在需要权衡的情况。如果所有的从库都延迟，那么请求就会全部落到主库上，这时候会不会由于压力突然增大，把主库打挂了呢？</p>
<p>其实，在实际应用中，这几个方案是可以混合使用的。</p>
<p>比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等GTID或等位点的方案。</p>
<p>但话说回来，过期读在本质上是由一写多读导致的。在实际应用中，可能会有别的不需要等待就可以水平扩展的数据库方案，但这往往是用牺牲写性能换来的，也就是需要在读性能和写性能中取权衡。</p>
<p>最后 ，我给你留下一个问题吧。</p>
<p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p>
<p>你可以把你的分析和方案设计写在评论区，我会在下一篇文章跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期给你留的问题是，在GTID模式下，如果一个新的从库接上主库，但是需要的binlog已经没了，要怎么做？</p>
<p>@某、人同学给了很详细的分析，我把他的回答略做修改贴过来。</p>
<ol>
<li>如果业务允许主从不一致的情况，那么可以在主库上先执行show global variables like ‘gtid_purged’，得到主库已经删除的GTID集合，假设是gtid_purged1；然后先在从库上执行reset master，再执行set global gtid_purged &#x3D;‘gtid_purged1’；最后执行start slave，就会从主库现存的binlog开始同步。binlog缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li>
<li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li>
<li>如果有其他的从库保留有全量的binlog的话，可以把新的从库先接到这个保留了全量binlog的从库，追上日志以后，如果有需要，再接回主库。</li>
<li>如果binlog有备份的情况，可以先在从库上应用缺失的binlog，然后再执行start slave。</li>
</ol>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@悟空 同学级联实验，验证了seconds_behind_master的计算逻辑。</p>
</blockquote>
<blockquote>
<p>@_CountingStars 问了一个好问题：MySQL是怎么快速定位binlog里面的某一个GTID位置的？答案是，在binlog文件头部的Previous_gtids可以解决这个问题。</p>
</blockquote>
<blockquote>
<p>@王朋飞 同学问了一个好问题，sql_slave_skip_counter跳过的是一个event，由于MySQL总不能执行一半的事务，所以既然跳过了一个event，就会跳到这个事务的末尾，因此set global sql_slave_skip_counter&#x3D;1;start slave是可以跳过整个事务的。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>30 | 答疑文章（二）：用动态的观点看加锁</title>
    <url>/posts/5532280e.html</url>
    <content><![CDATA[<p>在第<a href="https://time.geekbang.org/column/article/75173">20</a>和<a href="https://time.geekbang.org/column/article/75659">21</a>篇文章中，我和你介绍了InnoDB的间隙锁、next-key lock，以及加锁规则。在这两篇文章的评论区，出现了很多高质量的留言。我觉得通过分析这些问题，可以帮助你加深对加锁规则的理解。</p>
<p>所以，我就从中挑选了几个有代表性的问题，构成了今天这篇答疑文章的主题，即：用动态的观点看加锁。</p>
<span id="more"></span>

<p><strong>为了方便你理解，我们再一起复习一下加锁规则。这个规则中，包含了两个“原则”、两个“优化”和一个“bug”：</strong></p>
<ul>
<li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<p>接下来，我们的讨论还是基于下面这个表t：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h1 id="不等号条件里的等值查询"><a href="#不等号条件里的等值查询" class="headerlink" title="不等号条件里的等值查询"></a>不等号条件里的等值查询</h1><p>有同学对“等值查询”提出了疑问：等值查询和“遍历”有什么区别？为什么我们文章的例子里面，where条件是不等号，这个过程里也有等值查询？</p>
<p>我们一起来看下这个例子，分析一下这条查询语句的加锁范围：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">9</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>利用上面的加锁规则，我们知道这个语句的加锁范围是主键索引上的 (0,5]、(5,10]和(10, 15)。也就是说，id&#x3D;15这一行，并没有被加上行锁。为什么呢？</p>
<p>我们说加锁单位是next-key lock，都是前开后闭区间，但是这里用到了优化2，即索引上的等值查询，向右遍历的时候id&#x3D;15不满足条件，所以next-key lock退化为了间隙锁 (10, 15)。</p>
<p>但是，我们的查询语句中where条件是大于号和小于号，这里的“等值查询”又是从哪里来的呢？</p>
<p>要知道，加锁动作是发生在语句执行过程中的，所以你在分析加锁行为的时候，要从索引上的数据结构开始。这里，我再把这个过程拆解一下。</p>
<p>如图1所示，是这个表的索引id的示意图。</p>
<p><img src="https://static001.geekbang.org/resource/image/ac/bb/ac1aa07860c565b907b32c5f75c4f2bb.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 索引id示意图</b>
    </div>
    <br>
</center>

<ol>
<li>首先这个查询语句的语义是order by id desc，要拿到满足条件的所有行，优化器必须先找到“第一个id&lt;12的值”。</li>
<li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到id&#x3D;12的这个值，只是最终没找到，但找到了(10,15)这个间隙。</li>
<li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到id&#x3D;5这一行，所以会加一个next-key lock (0,5]。</li>
</ol>
<p>也就是说，在执行过程中，通过树搜索的方式定位记录的时候，用的是“等值查询”的方法。</p>
<h1 id="等值查询的过程"><a href="#等值查询的过程" class="headerlink" title="等值查询的过程"></a>等值查询的过程</h1><p>与上面这个例子对应的，是@发条橙子同学提出的问题：下面这个语句的加锁范围是什么？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>这条查询语句里用的是in，我们先来看这条语句的explain结果。<br><img src="https://static001.geekbang.org/resource/image/8a/b3/8a089159c82c1458b26e2756583347b3.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 in语句的explain结果</b>
    </div>
    <br>
</center>

<p>可以看到，这条in语句使用了索引c并且rows&#x3D;3，说明这三个值都是通过B+树搜索定位的。</p>
<p>在查找c&#x3D;5的时候，先锁住了(0,5]。但是因为c不是唯一索引，为了确认还有没有别的记录c&#x3D;5，就要向右遍历，找到c&#x3D;10才确认没有了，这个过程满足优化2，所以加了间隙锁(5,10)。</p>
<p>同样的，执行c&#x3D;10这个逻辑的时候，加锁的范围是(5,10] 和 (10,15)；执行c&#x3D;20这个逻辑的时候，加锁的范围是(15,20] 和 (20,25)。</p>
<p>通过这个分析，我们可以知道，这条语句在索引c上加的三个记录锁的顺序是：先加c&#x3D;5的记录锁，再加c&#x3D;10的记录锁，最后加c&#x3D;20的记录锁。</p>
<p>你可能会说，这个加锁范围，不就是从(5,25)中去掉c&#x3D;15的行锁吗？为什么这么麻烦地分段说呢？</p>
<p>因为我要跟你强调这个过程：这些锁是“在执行过程中一个一个加的”，而不是一次性加上去的。</p>
<p>理解了这个加锁过程之后，我们就可以来分析下面例子中的死锁问题了。</p>
<p>如果同时有另外一个语句，是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>此时的加锁范围，又是什么呢？</p>
<p>我们现在都知道间隙锁是不互锁的，但是这两条语句都会在索引c上的c&#x3D;5、10、20这三行记录上加记录锁。</p>
<p>这里你需要注意一下，由于语句里面是order by c desc， 这三个记录锁的加锁顺序，是先锁c&#x3D;20，然后c&#x3D;10，最后是c&#x3D;5。</p>
<p>也就是说，这两条语句要加锁相同的资源，但是加锁顺序相反。当这两条语句并发执行的时候，就可能出现死锁。</p>
<p>关于死锁的信息，MySQL只保留了最后一个死锁的现场，但这个现场还是不完备的。</p>
<p>有同学在评论区留言到，希望我能展开一下怎么看死锁。现在，我就来简单分析一下上面这个例子的死锁现场。</p>
<h1 id="怎么看死锁？"><a href="#怎么看死锁？" class="headerlink" title="怎么看死锁？"></a>怎么看死锁？</h1><p>图3是在出现死锁后，执行show engine innodb status命令得到的部分输出。这个命令会输出很多信息，有一节LATESTDETECTED DEADLOCK，就是记录的最后一次死锁信息。<br><img src="https://static001.geekbang.org/resource/image/a7/f6/a7dccb91bc17d12746703eb194775cf6.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 死锁现场</b>
    </div>
    <br>
</center>

<p>我们来看看这图中的几个关键信息。</p>
<ol>
<li>这个结果分成三部分：<ul>
<li>(1) TRANSACTION，是第一个事务的信息；</li>
<li>(2) TRANSACTION，是第二个事务的信息；</li>
<li>WE ROLL BACK TRANSACTION (1)，是最终的处理结果，表示回滚了第一个事务。</li>
</ul>
</li>
<li>第一个事务的信息中：<ul>
<li>WAITING FOR THIS LOCK TO BE GRANTED，表示的是这个事务在等待的锁信息；</li>
<li>index c of table <code>test</code>.<code>t</code>，说明在等的是表t的索引c上面的锁；</li>
<li>lock mode S waiting 表示这个语句要自己加一个读锁，当前的状态是等待中；</li>
<li>Record lock说明这是一个记录锁；</li>
<li>n_fields 2表示这个记录是两列，也就是字段c和主键字段id；</li>
<li>0: len 4; hex 0000000a; asc ;;是第一个字段，也就是c。值是十六进制a，也就是10；</li>
<li>1: len 4; hex 0000000a; asc ;;是第二个字段，也就是主键id，值也是10；</li>
<li>这两行里面的asc表示的是，接下来要打印出值里面的“可打印字符”，但10不是可打印字符，因此就显示空格。</li>
<li>第一个事务信息就只显示出了等锁的状态，在等待(c&#x3D;10,id&#x3D;10)这一行的锁。</li>
<li>当然你是知道的，既然出现死锁了，就表示这个事务也占有别的锁，但是没有显示出来。别着急，我们从第二个事务的信息中推导出来。</li>
</ul>
</li>
<li>第二个事务显示的信息要多一些：<ul>
<li>“ HOLDS THE LOCK(S)”用来显示这个事务持有哪些锁；</li>
<li>index c of table <code>test</code>.<code>t</code> 表示锁是在表t的索引c上；</li>
<li>hex 0000000a和hex 00000014表示这个事务持有c&#x3D;10和c&#x3D;20这两个记录锁；</li>
<li>WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c&#x3D;5,id&#x3D;5)这个记录锁。</li>
</ul>
</li>
</ol>
<p>从上面这些信息中，我们就知道：</p>
<ol>
<li>“lock in share mode”的这条语句，持有c&#x3D;5的记录锁，在等c&#x3D;10的锁；</li>
<li>“for update”这个语句，持有c&#x3D;20和c&#x3D;10的记录锁，在等c&#x3D;5的记录锁。</li>
</ol>
<p>因此导致了死锁。这里，我们可以得到两个结论：</p>
<ol>
<li>由于锁是一个个加的，要避免死锁，对同一组资源，要按照尽量相同的顺序访问；</li>
<li>在发生死锁的时刻，for update 这条语句占有的资源更多，回滚成本更大，所以InnoDB选择了回滚成本更小的lock in share mode语句，来回滚。</li>
</ol>
<h1 id="怎么看锁等待？"><a href="#怎么看锁等待？" class="headerlink" title="怎么看锁等待？"></a>怎么看锁等待？</h1><p>看完死锁，我们再来看一个锁等待的例子。</p>
<p>在第21篇文章的评论区，@Geek_9ca34e 同学做了一个有趣验证，我把复现步骤列出来：</p>
<p><img src="https://static001.geekbang.org/resource/image/af/75/af3602b81aeb49e33577ba372d220a75.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 delete导致间隙变化</b>
    </div>
    <br>
</center>

<p>可以看到，由于session A并没有锁住c&#x3D;10这个记录，所以session B删除id&#x3D;10这一行是可以的。但是之后，session B再想insert id&#x3D;10这一行回去就不行了。</p>
<p>现在我们一起看一下此时show engine innodb status的结果，看看能不能给我们一些提示。锁信息是在这个命令输出结果的TRANSACTIONS这一节。你可以在文稿中看到这张图片<br><img src="https://static001.geekbang.org/resource/image/c3/a6/c3744fb7b61df2a5b45b8eb1f2a853a6.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 5 锁等待信息</b>
    </div>
    <br>
</center>

<p>我们来看几个关键信息。</p>
<ol>
<li>index PRIMARY of table <code>test</code>.<code>t</code> ，表示这个语句被锁住是因为表t主键上的某个锁。</li>
<li>lock_mode X locks gap before rec insert intention waiting 这里有几个信息：<ul>
<li>insert intention表示当前线程准备插入一个记录，这是一个插入意向锁。为了便于理解，你可以认为它就是这个插入动作本身。</li>
<li>gap before rec 表示这是一个间隙锁，而不是记录锁。</li>
</ul>
</li>
<li>那么这个gap是在哪个记录之前的呢？接下来的0~4这5行的内容就是这个记录的信息。</li>
<li>n_fields 5也表示了，这一个记录有5列：<ul>
<li>0: len 4; hex 0000000f; asc ;;第一列是主键id字段，十六进制f就是id&#x3D;15。所以，这时我们就知道了，这个间隙就是id&#x3D;15之前的，因为id&#x3D;10已经不存在了，它表示的就是(5,15)。</li>
<li>1: len 6; hex 000000000513; asc ;;第二列是长度为6字节的事务id，表示最后修改这一行的是trx id为1299的事务。</li>
<li>2: len 7; hex b0000001250134; asc % 4;; 第三列长度为7字节的回滚段信息。可以看到，这里的acs后面有显示内容(%和4)，这是因为刚好这个字节是可打印字符。</li>
<li>后面两列是c和d的值，都是15。</li>
</ul>
</li>
</ol>
<p>因此，我们就知道了，由于delete操作把id&#x3D;10这一行删掉了，原来的两个间隙(5,10)、(10,15）变成了一个(5,15)。</p>
<p>说到这里，你可以联合起来再思考一下这两个现象之间的关联：</p>
<ol>
<li>session A执行完select语句后，什么都没做，但它加锁的范围突然“变大”了；</li>
<li>第21篇文章的课后思考题，当我们执行select * from t where c&gt;&#x3D;15 and c&lt;&#x3D;20 order by c desc lock in share mode; 向左扫描到c&#x3D;10的时候，要把(5, 10]锁起来。</li>
</ol>
<p>也就是说，所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p>
<h1 id="update的例子"><a href="#update的例子" class="headerlink" title="update的例子"></a>update的例子</h1><p>看过了insert和delete的加锁例子，我们再来看一个update语句的案例。在留言区中@信信 同学做了这个试验：</p>
<p><img src="https://static001.geekbang.org/resource/image/61/a7/61c1ceea7b59201649c2514c9db864a7.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 6 update 的例子</b>
    </div>
    <br>
</center>

<p>你可以自己分析一下，session A的加锁范围是索引c上的 (5,10]、(10,15]、(15,20]、(20,25]和(25,suprenum]。</p>
<p>之后session B的第一个update语句，要把c&#x3D;5改成c&#x3D;1，你可以理解为两步：</p>
<ol>
<li>插入(c&#x3D;1, id&#x3D;5)这个记录；</li>
<li>删除(c&#x3D;5, id&#x3D;5)这个记录。</li>
</ol>
<p>按照我们上一节说的，索引c上(5,10)间隙是由这个间隙右边的记录，也就是c&#x3D;10定义的。所以通过这个操作，session A的加锁范围变成了图7所示的样子：<br><img src="https://static001.geekbang.org/resource/image/d2/e9/d2f6a0c46dd8d12f6a90dacc466d53e9.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 7 session B修改后， session A的加锁范围</b>
    </div>
    <br>
</center>

<p>好，接下来session B要执行 update t set c &#x3D; 5 where c &#x3D; 1这个语句了，一样地可以拆成两步：</p>
<ol>
<li>插入(c&#x3D;5, id&#x3D;5)这个记录；</li>
<li>删除(c&#x3D;1, id&#x3D;5)这个记录。</li>
</ol>
<p>第一步试图在已经加了间隙锁的(1,10)中插入数据，所以就被堵住了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我用前面<a href="https://time.geekbang.org/column/article/75173">第20</a>和<a href="https://time.geekbang.org/column/article/75659">第21篇</a>文章评论区的几个问题，再次跟你复习了加锁规则。并且，我和你重点说明了，分析加锁范围时，一定要配合语句执行逻辑来进行。</p>
<p>在我看来，每个想认真了解MySQL原理的同学，应该都要能够做到：通过explain的结果，就能够脑补出一个SQL语句的执行流程。达到这样的程度，才算是对索引组织表、索引、锁的概念有了比较清晰的认识。你同样也可以用这个方法，来验证自己对这些知识点的掌握程度。</p>
<p>在分析这些加锁规则的过程中，我也顺便跟你介绍了怎么看show engine innodb status输出结果中的事务信息和死锁信息，希望这些内容对你以后分析现场能有所帮助。</p>
<p>老规矩，即便是答疑文章，我也还是要留一个课后问题给你的。</p>
<p>上面我们提到一个很重要的点：所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。</p>
<p>那么，一个空表有间隙吗？这个间隙是由谁定义的？你怎么验证这个结论呢？</p>
<p>你可以把你关于分析和验证方法写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后留给的问题，是分享一下你关于业务监控的处理经验。</p>
<p>在这篇文章的评论区，很多同学都分享了不错的经验。这里，我就选择几个比较典型的留言，和你分享吧：</p>
<ul>
<li>@老杨同志 回答得很详细。他的主要思路就是关于服务状态和服务质量的监控。其中，服务状态的监控，一般都可以用外部系统来实现；而服务的质量的监控，就要通过接口的响应时间来统计。</li>
<li>@Ryoma 同学，提到服务中使用了healthCheck来检测，其实跟我们文中提到的select 1的模式类似。</li>
<li>@强哥 同学，按照监控的对象，将监控分成了基础监控、服务监控和业务监控，并分享了每种监控需要关注的对象。</li>
</ul>
<p>这些都是很好的经验，你也可以根据具体的业务场景借鉴适合自己的方案。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>31 | 误删数据后除了跑路，还能怎么办</title>
    <url>/posts/b19b9f2.html</url>
    <content><![CDATA[<p>今天我要和你讨论的是一个沉重的话题：误删数据。</p>
<p>在前面几篇文章中，我们介绍了MySQL的高可用架构。当然，传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p>
<span id="more"></span>

<p>虽然我们之前遇到的大多数的数据被删，都是运维同学或者DBA背锅的。但实际上，只要有数据操作权限的同学，都有可能踩到误删数据这条线。</p>
<p>今天我们就来聊聊误删数据前后，我们可以做些什么，减少误删数据的风险，和由误删数据带来的损失。</p>
<p>为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p>
<ol>
<li>使用delete语句误删数据行；</li>
<li>使用drop table或者truncate table语句误删数据表；</li>
<li>使用drop database语句误删数据库；</li>
<li>使用rm命令误删整个MySQL实例。</li>
</ol>
<h1 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h1><p>在<a href="https://time.geekbang.org/column/article/76446">第24篇文章</a>中，我们提到如果是使用delete语句误删了数据行，可以用Flashback工具通过闪回把数据恢复回来。</p>
<p>Flashback恢复数据的原理，是修改binlog的内容，拿回原库重放。而能够使用这个方案的前提是，需要确保binlog_format&#x3D;row 和 binlog_row_image&#x3D;FULL。</p>
<p>具体恢复数据时，对单个事务做如下处理：</p>
<ol>
<li>对于insert语句，对应的binlog event类型是Write_rows event，把它改成Delete_rows event即可；</li>
<li>同理，对于delete语句，也是将Delete_rows event改为Write_rows event；</li>
<li>而如果是Update_rows的话，binlog里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li>
</ol>
<p>如果误操作不是一个，而是多个，会怎么样呢？比如下面三个事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(A)<span class="keyword">delete</span> ...</span><br><span class="line">(B)<span class="keyword">insert</span> ...</span><br><span class="line">(C)<span class="keyword">update</span> ...</span><br></pre></td></tr></table></figure>

<p>现在要把数据库恢复回这三个事务操作之前的状态，用Flashback工具解析binlog后，写回主库的命令是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(reverse C)<span class="keyword">update</span> ...</span><br><span class="line">(reverse B)<span class="keyword">delete</span> ...</span><br><span class="line">(reverse A)<span class="keyword">insert</span> ...</span><br></pre></td></tr></table></figure>

<p>也就是说，如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p>
<p><strong>需要说明的是，我不建议你直接在主库上执行这些操作。</strong></p>
<p>恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p>
<p>为什么要这么做呢？</p>
<p>这是因为，一个在执行线上逻辑的主库，数据状态的变更往往是有关联的。可能由于发现数据问题的时间晚了一点儿，就导致已经在之前误操作的基础上，业务代码逻辑又继续修改了其他数据。所以，如果这时候单独恢复这几行数据，而又未经确认的话，就可能会出现对数据的二次破坏。</p>
<p>当然，<strong>我们不止要说误删数据的事后处理办法，更重要是要做到事前预防</strong>。我有以下两个建议：</p>
<ol>
<li>把sql_safe_updates参数设置为on。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li>
<li>代码上线前，必须经过SQL审计。</li>
</ol>
<p>你可能会说，设置了sql_safe_updates&#x3D;on，如果我真的要把一个小表的数据全部删掉，应该怎么办呢？</p>
<p>如果你确定这个删除操作没问题的话，可以在delete语句中加上where条件，比如where id&gt;&#x3D;0。</p>
<p>但是，delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，你应该优先考虑使用truncate table或者drop table命令。</p>
<p>使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。为什么呢？</p>
<p>这是因为，即使我们配置了binlog_format&#x3D;row，执行这三个命令时，记录的binlog还是statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。</p>
<p>那么，如果我们真的是使用这几条命令误删数据了，又该怎么办呢？</p>
<h1 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库&#x2F;表"></a>误删库&#x2F;表</h1><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份binlog。</p>
<p>在这两个条件都具备的情况下，假如有人中午12点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天0点；</li>
<li>用备份恢复出一个临时库；</li>
<li>从日志备份里面，取出凌晨0点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<p>这个流程的示意图如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/2f/db/2fafd0b75286e0163f432f85428ff8db.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 数据恢复流程-mysqlbinlog方法</b>
    </div>
    <br>
</center>

<p>关于这个过程，我需要和你说明如下几点：</p>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用mysqlbinlog命令时，加上一个–database参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li>
<li>在应用日志的时候，需要跳过12点误操作的那个语句的binlog：<ul>
<li>如果原实例没有使用GTID模式，只能在应用到包含12点的binlog文件的时候，先用–stop-position参数执行到误操作之前的日志，然后再用–start-position从误操作之后的日志继续执行；</li>
<li>如果实例使用了GTID模式，就方便多了。假设误操作命令的GTID是gtid1，那么只需要执行set gtid_next&#x3D;gtid1;begin;commit; 先把这个GTID加到临时实例的GTID集合，之后按顺序执行binlog的时候，就会自动跳过误操作的语句。</li>
</ul>
</li>
</ol>
<p>不过，即使这样，使用mysqlbinlog方法恢复数据还是不够快，主要原因有两个：</p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是mysqlbinlog工具并不能指定只解析一个表的日志；</li>
<li>用mysqlbinlog解析出日志应用，应用日志的过程就只能是单线程。我们在<a href="https://time.geekbang.org/column/article/77083">第26篇文章</a>中介绍的那些并行复制的方法，在这里都用不上。</li>
</ol>
<p><strong>一种加速的方法是，</strong> 在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p>
<ol>
<li>在start slave之前，先通过执行﻿<br>﻿change replication filter replicate_do_table &#x3D; (tbl_name) 命令，就可以让临时库只同步误操作的表；</li>
<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li>
</ol>
<p>这个过程的示意图如下所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/65/f1/65bb04929b8235fb677c7a78b5bd67f1.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 数据恢复流程-master-slave方法</b>
    </div>
    <br>
</center>

<p>可以看到，图中binlog备份系统到线上备库有一条虚线，是指如果由于时间太久，备库上已经删除了临时实例需要的binlog的话，我们可以从binlog备份系统中找到需要的binlog，再放回备库中。</p>
<p>假设，我们发现当前临时实例需要的binlog是从master.000005开始的，但是在备库上执行show binlogs 显示的最小的binlog文件是master.000007，意味着少了两个binlog文件。这时，我们就需要去binlog备份系统中找到这两个文件。</p>
<p>把之前删掉的binlog放回备库的操作步骤，是这样的：</p>
<ol>
<li>从备份系统下载master.000005和master.000006这两个文件，放到备库的日志目录下；</li>
<li>打开日志目录下的master.index文件，在文件开头加入两行，内容分别是 “.&#x2F;master.000005”和“.&#x2F;master.000006”;</li>
<li>重启备库，目的是要让备库重新识别这两个日志文件；</li>
<li>现在这个备库上就有了临时库需要的所有binlog了，建立主备关系，就可以正常同步了。</li>
</ol>
<p>不论是把mysqlbinlog工具解析出的binlog文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用binlog的方式。</p>
<p>也就是说，这两个方案都要求备份系统定期备份全量日志，而且需要确保binlog在被从本地删除之前已经做了备份。</p>
<p>但是，一个系统不可能备份无限的日志，你还需要根据成本和磁盘空间资源，设定一个日志保留的天数。如果你的DBA团队告诉你，可以保证把某个实例恢复到半个月内的任意时间点，这就表示备份系统保留的日志时间就至少是半个月。</p>
<p>另外，我建议你不论使用上述哪种方式，都要把这个数据恢复功能做成自动化工具，并且经常拿出来演练。为什么这么说呢？</p>
<p>这里的原因，主要包括两个方面：</p>
<ol>
<li>虽然“发生这种事，大家都不想的”，但是万一出现了误删事件，能够快速恢复数据，将损失降到最小，也应该不用跑路了。</li>
<li>而如果临时再手忙脚乱地手动操作，最后又误操作了，对业务造成了二次伤害，那就说不过去了。</li>
</ol>
<h1 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h1><p>虽然我们可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。</p>
<p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第6天发生误操作，那就需要恢复6天的日志，这个恢复时间可能是要按天来计算的。</p>
<p>那么，我们有什么方法可以缩短恢复数据需要的时间呢？</p>
<p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑<strong>搭建延迟复制的备库。</strong>这个功能是MySQL 5.6版本引入的。</p>
<p>一般的主备复制结构存在的问题是，如果主库上有个表被误删了，这个命令很快也会被发给所有从库，进而导致所有从库的数据表也都一起被误删了。</p>
<p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY &#x3D; N命令，可以指定这个备库持续保持跟主库有N秒的延迟。</p>
<p>比如你把N设置为3600，这就代表了如果主库上有数据被误删了，并且在1小时内发现了这个误操作命令，这个命令就还没有在这个延迟复制的备库执行。这时候到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p>
<p>这样的话，你就随时可以得到一个，只需要最多再追1小时，就可以恢复出数据的临时实例，也就缩短了整个数据恢复需要的时间。</p>
<h1 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库&#x2F;表的方法"></a>预防误删库&#x2F;表的方法</h1><p>虽然常在河边走，很难不湿鞋，但终究还是可以找到一些方法来避免的。所以这里，我也会给你一些减少误删操作风险的建议。</p>
<p>第一条建议是，账号分离。这样做的目的是，避免写错命令。比如：</p>
<ul>
<li>我们只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需求的话，也可以通过开发管理系统得到支持。</li>
<li>即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>
</ul>
<p>第二条建议是，制定操作规范。这样做的目的，是避免写错要删除的表名。比如：</p>
<ul>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>
<li>改表名的时候，要求给表名加固定的后缀（比如加_to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>
</ul>
<h1 id="rm删除数据"><a href="#rm删除数据" class="headerlink" title="rm删除数据"></a>rm删除数据</h1><p>其实，对于一个有高可用机制的MySQL集群来说，最不怕的就是rm删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>
<p>这时，你要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p>
<p>当然了，现在不止是DBA有自动化系统，SA（系统管理员）也有自动化系统，所以也许一个批量下线机器的操作，会让你整个MySQL集群的所有节点都全军覆没。</p>
<p>应对这种情况，我的建议只能是说尽量把你的备份跨机房，或者最好是跨城市保存。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你讨论了误删数据的几种可能，以及误删后的处理方法。</p>
<p>但，我要强调的是，预防远比处理的意义来得大。</p>
<p>另外，在MySQL的集群方案中，会时不时地用到备份来恢复实例，因此定期检查备份的有效性也很有必要。</p>
<p>如果你是业务开发同学，你可以用show grants命令查看账户的权限，如果权限过大，可以建议DBA同学给你分配权限低一些的账号；你也可以评估业务的重要性，和DBA商量备份的周期、是否有必要创建延迟复制的备库等等。</p>
<p>数据和服务的可靠性不止是运维团队的工作，最终是各个环节一起保障的结果。</p>
<p>今天的课后话题是，回忆下你亲身经历过的误删数据事件吧，你用了什么方法来恢复数据呢？你在这个过程中得到的经验又是什么呢？</p>
<p>你可以把你的经历和经验写在留言区，我会在下一篇文章的末尾选取有趣的评论和你一起讨论。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章给你留的问题，是关于空表的间隙的定义。</p>
<p>一个空表就只有一个间隙。比如，在空表上执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询语句加锁的范围就是next-key lock (-∞, supremum]。</p>
<p>验证方法的话，你可以使用下面的操作序列。你可以在图4中看到显示的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/12/65/12eb6a38c347203f60df72ecaea95565.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 复现空表的next-key lock</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/53/9f/531b6556ffc82c6b02f9a010a3ceb09f.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 show engine innodb status 部分结果</b>
    </div>
    <br>
</center>

<p>评论区留言点赞板：</p>
<blockquote>
<p>@老杨同志 给出了正确的分析和SQL语句验证方法；<br>@库淘淘 指出了show engine innodb status验证结论。</p>
</blockquote>
<p>赞这些思考和反馈。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
<hr>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>32 | 为什么还有kill不掉的语句</title>
    <url>/posts/8b01c4eb.html</url>
    <content><![CDATA[<p>在MySQL中有两个kill命令：一个是kill query +线程id，表示终止这个线程中正在执行的语句；一个是kill connection +线程id，这里connection可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</p>
<p>不知道你在使用MySQL的时候，有没有遇到过这样的现象：使用了kill命令，却没能断开这个连接。再执行show processlist命令，看到这条语句的Command列显示的是Killed。</p>
<span id="more"></span>

<p>你一定会奇怪，显示为Killed是什么意思，不是应该直接在show processlist的结果里看不到这个线程了吗？</p>
<p>今天，我们就来讨论一下这个问题。</p>
<p>其实大多数情况下，kill query&#x2F;connection命令是有效的。比如，执行一个查询的过程中，发现执行时间太久，要放弃继续查询，这时我们就可以用kill query命令，终止这条查询语句。</p>
<p>还有一种情况是，语句处于锁等待的时候，直接使用kill命令也是有效的。我们一起来看下这个例子：</p>
<p><img src="https://static001.geekbang.org/resource/image/17/d0/17f88dc70c3fbe06a7738a0ac01db4d0.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 kill query 成功的例子</b>
    </div>
    <br>
</center>

<p>可以看到，session C 执行kill query以后，session B几乎同时就提示了语句被中断。这，就是我们预期的结果。</p>
<h1 id="收到-kill-以后，线程做什么？"><a href="#收到-kill-以后，线程做什么？" class="headerlink" title="收到 kill 以后，线程做什么？"></a>收到 kill 以后，线程做什么？</h1><p>但是，这里你要停下来想一下：session B是直接终止掉线程，什么都不管就直接退出吗？显然，这是不行的。</p>
<p>我在<a href="https://time.geekbang.org/column/article/69862">第6篇文章</a>中讲过，当对一个表做增删改查操作时，会在表上加MDL读锁。所以，session B虽然处于blocked状态，但还是拿着一个MDL读锁的。如果线程被kill的时候，就直接终止，那之后这个MDL读锁就没机会被释放了。</p>
<p>这样看来，kill并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p>
<blockquote>
<p>其实，这跟Linux的kill命令类似，kill -N pid并不是让进程直接停止，而是给进程发一个信号，然后进程处理这个信号，进入终止逻辑。只是对于MySQL的kill命令来说，不需要传信号量参数，就只有“停止”这个命令。</p>
</blockquote>
<p><strong>实现上，当用户执行kill query thread_id_B时，MySQL里处理kill命令的线程做了两件事：</strong></p>
<ol>
<li>把session B的运行状态改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)；</li>
<li>给session B的执行线程发一个信号。</li>
</ol>
<p>为什么要发信号呢？</p>
<p>因为像图1的我们例子里面，session B处于锁等待状态，如果只是把session B的线程状态设置THD::KILL_QUERY，线程B并不知道这个状态变化，还是会继续等待。发一个信号的目的，就是让session B退出等待，来处理这个THD::KILL_QUERY状态。</p>
<p>上面的分析中，隐含了这么三层意思：</p>
<ol>
<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是THD::KILL_QUERY，才开始进入语句终止逻辑；</li>
<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li>
<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li>
</ol>
<p>到这里你就知道了，原来不是“说停就停的”。</p>
<p>接下来，我们<strong>再看一个kill不掉的例子</strong>，也就是我们在前面<a href="https://time.geekbang.org/column/article/78134">第29篇文章</a>中提到的 innodb_thread_concurrency 不够用的例子。</p>
<p>首先，执行set global innodb_thread_concurrency&#x3D;2，将InnoDB的并发线程上限数设置为2；然后，执行下面的序列：</p>
<p><img src="https://static001.geekbang.org/resource/image/32/6e/32e4341409fabfe271db3dd4c4df696e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 kill query 无效的例子</b>
    </div>
    <br>
</center>

<p>可以看到：</p>
<ol>
<li>sesssion C执行的时候被堵住了；</li>
<li>但是session D执行的kill query C命令却没什么效果，</li>
<li>直到session E执行了kill connection命令，才断开了session C的连接，提示“Lost connection to MySQL server during query”，</li>
<li>但是这时候，如果在session E中执行show processlist，你就能看到下面这个图。</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/91/53/915c20e4c11b104d7bcf9d3457304c53.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 kill connection之后的效果</b>
    </div>
    <br>
</center>

<p>这时候，id&#x3D;12这个线程的Commnad列显示的是Killed。也就是说，客户端虽然断开了连接，但实际上服务端上这条语句还在执行过程中。</p>
<p><strong>为什么在执行kill query命令时，这条语句不像第一个例子的update语句一样退出呢？</strong></p>
<p>在实现上，等行锁时，使用的是pthread_cond_timedwait函数，这个等待状态可以被唤醒。但是，在这个例子里，12号线程的等待逻辑是这样的：每10毫秒判断一下是否可以进入InnoDB执行，如果不行，就调用nanosleep函数进入sleep状态。</p>
<p>也就是说，虽然12号线程的状态已经被设置成了KILL_QUERY，但是在这个等待进入InnoDB的循环过程中，并没有去判断线程的状态，因此根本不会进入终止逻辑阶段。</p>
<p>而当session E执行kill connection 命令时，是这么做的，</p>
<ol>
<li>把12号线程状态设置为KILL_CONNECTION；</li>
<li>关掉12号线程的网络连接。因为有这个操作，所以你会看到，这时候session C收到了断开连接的提示。</li>
</ol>
<p>那为什么执行show processlist的时候，会看到Command列显示为killed呢？其实，这就是因为在执行show processlist的时候，有一个特别的逻辑：</p>
<blockquote>
<p> 如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed。</p>
</blockquote>
<p>所以其实，即使是客户端退出了，这个线程的状态仍然是在等待中。那这个线程什么时候会退出呢？</p>
<p>答案是，只有等到满足进入InnoDB的条件后，session C的查询语句继续执行，然后才有可能判断到线程状态已经变成了KILL_QUERY或者KILL_CONNECTION，再进入终止逻辑阶段。</p>
<p>到这里，我们来小结一下。</p>
<p><strong>这个例子是kill无效的第一类情况，即：线程没有执行到判断线程状态的逻辑。</strong> 跟这种情况相同的，还有由于IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态。</p>
<p><strong>另一类情况是，终止逻辑耗时较长。</strong> 这时候，从show processlist结果上看也是Command&#x3D;Killed，需要等到终止逻辑完成，语句才算真正完成。这类情况，比较常见的场景有以下几种：</p>
<ol>
<li>超大事务执行期间被kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li>
<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待IO资源，导致耗时较长。</li>
<li>DDL命令执行到最后阶段，如果被kill，需要删除中间过程的临时文件，也可能受IO资源影响耗时较久。</li>
</ol>
<p>之前有人问过我，如果直接在客户端通过Ctrl+C命令，是不是就可以直接终止线程呢？</p>
<p>答案是，不可以。</p>
<p>这里有一个误解，其实在客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。</p>
<p>而由于MySQL是停等协议，所以这个线程执行的语句还没有返回的时候，再往这个连接里面继续发命令也是没有用的。实际上，执行Ctrl+C的时候，是MySQL客户端另外启动一个连接，然后发送一个kill query 命令。</p>
<p>所以，你可别以为在客户端执行完Ctrl+C就万事大吉了。因为，要kill掉一个线程，还涉及到后端的很多操作。</p>
<h1 id="另外两个关于客户端的误解"><a href="#另外两个关于客户端的误解" class="headerlink" title="另外两个关于客户端的误解"></a>另外两个关于客户端的误解</h1><p>在实际使用中，我也经常会碰到一些同学对客户端的使用有误解。接下来，我们就来看看两个最常见的误解。</p>
<p><strong>第一个误解是：如果库里面的表特别多，连接就会很慢。</strong></p>
<p>有些线上的库，会包含很多表（我见过最多的一个库里有6万个表）。这时候，你就会发现，每次用客户端连接都会卡在下面这个界面上。</p>
<p><img src="https://static001.geekbang.org/resource/image/7e/83/7e4666bfd580505180c77447d1f44c83.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 连接等待</b>
    </div>
    <br>
</center>

<p>而如果db1这个库里表很少的话，连接起来就会很快，可以很快进入输入命令的状态。因此，有同学会认为是表的数目影响了连接性能。</p>
<p>从<a href="https://time.geekbang.org/column/article/68319">第一篇文章</a>你就知道，每个客户端在和服务端建立连接的时候，需要做的事情就是TCP握手、用户校验、获取权限。但这几个操作，显然跟库里面表的个数无关。</p>
<p>但实际上，正如图中的文字提示所说的，当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p>
<ol>
<li>执行show databases；</li>
<li>切到db1库，执行show tables；</li>
<li>把这两个命令的结果用于构建一个本地的哈希表。</li>
</ol>
<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p>
<p>也就是说，<strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p>
<p>图中的提示也说了，如果在连接命令中加上-A，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p>
<p>这里自动补全的效果就是，你在输入库名或者表名的时候，输入前缀，可以使用Tab键自动补全表名或者显示提示。</p>
<p>实际使用中，如果你自动补全功能用得并不多，我建议你每次使用的时候都默认加-A。</p>
<p>其实提示里面没有说，除了加-A以外，加–quick(或者简写为-q)参数，也可以跳过这个阶段。但是，这个<strong>–quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。</strong></p>
<p>你看到这个参数，是不是觉得这应该是一个让服务端加速的参数？但实际上恰恰相反，设置了这个参数可能会降低服务端的性能。为什么这么说呢？</p>
<p>MySQL客户端发送请求后，接收服务端返回结果的方式有两种：</p>
<ol>
<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用API开发，对应的就是mysql_store_result 方法。</li>
<li>另一种是不缓存，读一个处理一个。如果你用API开发，对应的就是mysql_use_result方法。</li>
</ol>
<p>MySQL客户端默认采用第一种方式，而如果加上–quick参数，就会使用第二种不缓存的方式。</p>
<p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。关于服务端的具体行为，我会在下一篇文章再和你展开说明。</p>
<p>那你会说，既然这样，为什么要给这个参数取名叫作quick呢？这是因为使用这个参数可以达到以下三点效果：</p>
<ul>
<li>第一点，就是前面提到的，跳过表名自动补全功能。</li>
<li>第二点，mysql_store_result需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；</li>
<li>第三点，是不会把执行命令记录到本地的命令历史文件。</li>
</ul>
<p>所以你看到了，–quick参数的意思，是让客户端变得更快。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在今天这篇文章中，我首先和你介绍了MySQL中，有些语句和连接“kill不掉”的情况。</p>
<p>这些“kill不掉”的情况，其实是因为发送kill命令的客户端，并没有强行停止目标线程的执行，而只是设置了个状态，并唤醒对应的线程。而被kill的线程，需要执行到判断状态的“埋点”，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。</p>
<p>所以，如果你发现一个线程处于Killed状态，你可以做的事情就是，通过影响系统环境，让这个Killed状态尽快结束。</p>
<p>比如，如果是第一个例子里InnoDB并发度的问题，你就可以临时调大innodb_thread_concurrency的值，或者停掉别的线程，让出位子给这个线程执行。</p>
<p>而如果是回滚逻辑由于受到IO资源限制执行得比较慢，就通过减少系统压力让它加速。</p>
<p>做完这些操作后，其实你已经没有办法再对它做什么了，只能等待流程自己完成。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>如果你碰到一个被killed的事务一直处于回滚状态，你认为是应该直接把MySQL进程强行重启，还是应该让它自己执行完成呢？为什么呢？</p>
<p>你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章末尾，给你留下的问题是，希望你分享一下误删数据的处理经验。</p>
<p><strong>@苍茫 同学提到了一个例子</strong>，我觉得值得跟大家分享一下。运维的同学直接拷贝文本去执行，SQL语句截断，导致数据库执行出错。</p>
<p>从浏览器拷贝文本执行，是一个非常不规范的操作。除了这个例子里面说的SQL语句截断问题，还可能存在乱码问题。</p>
<p>一般这种操作，如果脚本的开发和执行不是同一个人，需要开发同学把脚本放到git上，然后把git地址，以及文件的md5发给运维同学。</p>
<p>这样就要求运维同学在执行命令之前，确认要执行的文件的md5，跟之前开发同学提供的md5相同才能继续执行。</p>
<p>另外，我要特别点赞一下@苍茫 同学复现问题的思路和追查问题的态度。</p>
<p><strong>@linhui0705 同学提到的“四个脚本”的方法，我非常推崇</strong>。这四个脚本分别是：备份脚本、执行脚本、验证脚本和回滚脚本。如果能够坚持做到，即使出现问题，也是可以很快恢复的，一定能降低出现故障的概率。</p>
<p>不过，这个方案最大的敌人是这样的思想：这是个小操作，不需要这么严格。</p>
<p><strong>@Knight²º¹⁸ 给了一个保护文件的方法</strong>，我之前没有用过这种方法，不过这确实是一个不错的思路。</p>
<p>为了数据安全和服务稳定，多做点预防方案的设计讨论，总好过故障处理和事后复盘。方案设计讨论会和故障复盘会，这两种会议的会议室气氛完全不一样。经历过的同学一定懂的。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>33 | 我查这么多数据，会不会把数据库内存打爆</title>
    <url>/posts/1e50aa7c.html</url>
    <content><![CDATA[<p>我经常会被问到这样一个问题：我的主机内存只有100G，现在要对一个200G的大表做全表扫描，会不会把数据库主机的内存用光了？</p>
<span id="more"></span>

<p>这个问题确实值得担心，被系统OOM（out of memory）可不是闹着玩的。但是，反过来想想，逻辑备份的时候，可不就是做整库扫描吗？如果这样就会把内存吃光，逻辑备份不是早就挂了？</p>
<p>所以说，对大表做全表扫描，看来应该是没问题的。但是，这个流程到底是怎么样的呢？</p>
<h1 id="全表扫描对server层的影响"><a href="#全表扫描对server层的影响" class="headerlink" title="全表扫描对server层的影响"></a>全表扫描对server层的影响</h1><p>假设，我们现在要对一个200G的InnoDB表db1. t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p$pwd <span class="operator">-</span>e &quot;select * from db1.t&quot; <span class="operator">&gt;</span> $target_file</span><br></pre></td></tr></table></figure>

<p>你已经知道了，InnoDB的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表t的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p>
<p>那么，这个“结果集”存在哪里呢？</p>
<p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p>
<ol>
<li>获取一行，写到net_buffer中。这块内存的大小是由参数net_buffer_length定义的，默认是16k。</li>
<li>重复获取行，直到net_buffer写满，调用网络接口发出去。</li>
<li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer。</li>
<li>如果发送函数返回EAGAIN或WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li>
</ol>
<p>这个过程对应的流程图如下所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/a0/bd/a027c300d7dde8cea4fad8f34b670ebd.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 查询结果发送流程</b>
    </div>
    <br>
</center>

<p>从这个流程中，你可以看到：</p>
<ol>
<li>一个查询在发送过程中，占用的MySQL内部的内存最大就是net_buffer_length这么大，并不会达到200G；</li>
<li>socket send buffer 也不可能达到200G（默认定义&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_default），如果socket send buffer被写满，就会暂停读数据的流程。</li>
</ol>
<p>也就是说，<strong>MySQL是“边读边发的”</strong>，这个概念很重要。这就意味着，如果客户端接收得慢，会导致MySQL服务端由于结果发不出去，这个事务的执行时间变长。</p>
<p>比如下面这个状态，就是我故意让客户端不去读socket receive buffer中的内容，然后在服务端show processlist看到的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/18/c3/183a704d4495bebbc13c524695b5b6c3.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 服务端发送阻塞</b>
    </div>
    <br>
</center>

<p>如果你看到State的值一直处于<strong>“Sending to client”</strong>，就表示服务器端的网络栈写满了。</p>
<p>我在上一篇文章中曾提到，如果客户端使用–quick参数，会使用mysql_use_result方法。这个方法是读一行处理一行。你可以想象一下，假设有一个业务的逻辑比较复杂，每读一行数据以后要处理的逻辑如果很慢，就会导致客户端要过很久才会去取下一行数据，可能就会出现如图2所示的这种情况。</p>
<p>因此，<strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，我都建议你使用mysql_store_result这个接口，直接把查询结果保存到本地内存。</strong></p>
<p>当然前提是查询返回结果不多。在<a href="https://time.geekbang.org/column/article/78427">第30篇文章</a>评论区，有同学说到自己因为执行了一个大查询导致客户端占用内存近20G，这种情况下就需要改用mysql_use_result接口了。</p>
<p>另一方面，如果你在自己负责维护的MySQL里看到很多个线程都处于“Sending to client”这个状态，就意味着你要让业务开发同学优化查询结果，并评估这么多的返回结果是否合理。</p>
<p>而如果要快速减少处于这个状态的线程的话，将net_buffer_length参数设置为一个更大的值是一个可选方案。</p>
<p>与“Sending to client”长相很类似的一个状态是 <strong>“Sending data”</strong> ，这是一个经常被误会的问题。有同学问我说，在自己维护的实例上看到很多查询语句的状态是“Sending data”，但查看网络也没什么问题啊，为什么Sending data要这么久？</p>
<p>实际上，一个查询语句的状态变化是这样的（注意：这里，我略去了其他无关的状态）：</p>
<ul>
<li>MySQL查询语句进入执行阶段后，首先把状态设置成“Sending data”；</li>
<li>然后，发送执行结果的列相关的信息（meta data) 给客户端；</li>
<li>再继续执行语句的流程；</li>
<li>执行完成后，把状态设置成空字符串。</li>
</ul>
<p>也就是说，“Sending data”并不一定是指“正在发送数据”，而可能是处于执行器过程中的任意阶段。比如，你可以构造一个锁等待的场景，就能看到Sending data状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/76/4b/7640b0d82965bf8b305514f30425424b.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 读全表被锁</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/84/c0/84533515cf36be65582309fbb85e13c0.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 4 Sending data状态</b>
    </div>
    <br>
</center>

<p>可以看到，session B明显是在等锁，状态显示为Sending data。</p>
<p>也就是说，仅当一个线程处于“等待客户端接收结果”的状态，才会显示”Sending to client”；而如果显示成“Sending data”，它的意思只是“正在执行”。</p>
<p>现在你知道了，查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会把内存打爆。</p>
<p>在server层的处理逻辑我们都清楚了，在InnoDB引擎里面又是怎么处理的呢？ 扫描全表会不会对引擎系统造成影响呢？</p>
<h1 id="全表扫描对InnoDB的影响"><a href="#全表扫描对InnoDB的影响" class="headerlink" title="全表扫描对InnoDB的影响"></a>全表扫描对InnoDB的影响</h1><p>在<a href="https://time.geekbang.org/column/article/68633">第2</a>和<a href="https://time.geekbang.org/column/article/73161">第15篇</a>文章中，我介绍WAL机制的时候，和你分析了InnoDB内存的一个作用，是保存更新的结果，再配合redo log，就避免了随机写盘。</p>
<p>内存的数据页是在Buffer Pool (BP)中管理的，在WAL里Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p>
<p>在第2篇文章的评论区有同学问道，由于有WAL机制，当事务提交的时候，磁盘上的数据页是旧的，那如果这时候马上有一个查询要来读这个数据页，是不是要马上把redo log应用到数据页呢？</p>
<p>答案是不需要。因为这时候内存数据页的结果是最新的，直接读内存页就可以了。你看，这时候查询根本不需要读磁盘，直接从内存拿结果，速度是很快的。所以说，Buffer Pool还有加速查询的作用。</p>
<p>而Buffer Pool对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p>
<p>你可以在show engine innodb status结果中，查看一个系统当前的BP命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在99%以上。</p>
<p>执行show engine innodb status ，可以看到“Buffer pool hit rate”字样，显示的就是当前的命中率。比如图5这个命中率，就是99.0%。</p>
<p><img src="https://static001.geekbang.org/resource/image/c7/2e/c70a95ee99826812c292c46de508982e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 show engine innodb status显示内存命中率</b>
    </div>
    <br>
</center>

<p>如果所有查询需要的数据页都能够直接从内存得到，那是最好的，对应的命中率就是100%。但，这在实际生产上是很难做到的。</p>
<p>InnoDB Buffer Pool的大小是由参数 innodb_buffer_pool_size确定的，一般建议设置成可用物理内存的60%~80%。</p>
<p>在大约十年前，单机的数据量是上百个G，而物理内存是几个G；现在虽然很多服务器都能有128G甚至更高的内存，但是单机的数据量却达到了T级别。</p>
<p>所以，innodb_buffer_pool_size小于磁盘的数据量是很常见的。如果一个 Buffer Pool满了，而又要从磁盘读入一个数据页，那肯定是要淘汰一个旧数据页的。</p>
<p>InnoDB内存管理用的是最近最少使用 (Least Recently Used, LRU)算法，这个算法的核心就是淘汰最久未使用的数据。</p>
<p>下图是一个LRU算法的基本模型。</p>
<p><img src="https://static001.geekbang.org/resource/image/e0/65/e0ac92febac50a5d881f1188ea5bfd65.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 基本LRU算法</b>
    </div>
    <br>
</center>

<p>InnoDB管理Buffer Pool的LRU算法，是用链表来实现的。</p>
<ol>
<li>在图6的状态1里，链表头部是P1，表示P1是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</li>
<li>这时候有一个读请求访问P3，因此变成状态2，P3被移到最前面；</li>
<li>状态3表示，这次访问的数据页是不存在于链表中的，所以需要在Buffer Pool中新申请一个数据页Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾Pm这个数据页的内存，存入Px的内容，然后放到链表头部。</li>
<li>从效果上看，就是最久没有被访问的数据页Pm，被淘汰了。</li>
</ol>
<p>这个算法乍一看上去没什么问题，但是如果考虑到要做一个全表扫描，会不会有问题呢？</p>
<p>假设按照这个算法，我们要扫描一个200G的表，而这个表是一个历史数据表，平时没有业务访问它。</p>
<p>那么，按照这个算法扫描的话，就会把当前的Buffer Pool里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说Buffer Pool里面主要放的是这个历史数据表的数据。</p>
<p>对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool的内存命中率急剧下降，磁盘压力增加，SQL语句响应变慢。</p>
<p>所以，InnoDB不能直接使用这个LRU算法。实际上，InnoDB对LRU算法做了改进。</p>
<p><img src="https://static001.geekbang.org/resource/image/25/9e/25e18920dd204cf99eec2d62755fe99e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 7 改进的LRU算法</b>
    </div>
    <br>
</center>

<p>在InnoDB实现上，按照5:3的比例把整个LRU链表分成了young区域和old区域。图中LRU_old指向的就是old区域的第一个位置，是整个链表的5&#x2F;8处。也就是说，靠近链表头部的5&#x2F;8是young区域，靠近链表尾部的3&#x2F;8是old区域。</p>
<p>改进后的LRU算法执行流程变成了下面这样。</p>
<ol>
<li>图7中状态1，要访问数据页P3，由于P3在young区域，因此和优化前的LRU算法一样，将其移到链表头部，变成状态2。</li>
<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页Pm，但是新插入的数据页Px，是放在LRU_old处。</li>
<li>处于old区域的数据页，每次被访问的时候都要做下面这个判断：<ul>
<li>若这个数据页在LRU链表中存在的时间超过了1秒，就把它移动到链表头部；</li>
<li>如果这个数据页在LRU链表中存在的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。</li>
</ul>
</li>
</ol>
<p>这个策略，就是为了处理类似全表扫描的操作量身定制的。还是以刚刚的扫描200G的历史数据表为例，我们看看改进后的LRU算法的操作逻辑：</p>
<ol>
<li>扫描过程中，需要新插入的数据页，都被放到old区域;</li>
<li>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在old区域；</li>
<li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是young区域），很快就会被淘汰出去。</li>
</ol>
<p>可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我用“大查询会不会把内存用光”这个问题，和你介绍了MySQL的查询结果，发送给客户端的过程。</p>
<p>由于MySQL采用的是边算边发的逻辑，因此对于数据量很大的查询结果来说，不会在server端保存完整的结果集。所以，如果客户端读结果不及时，会堵住MySQL的查询过程，但是不会把内存打爆。</p>
<p>而对于InnoDB引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于InnoDB对LRU算法做了改进，冷数据的全表扫描，对Buffer Pool的影响也能做到可控。</p>
<p>当然，我们前面文章有说过，全表扫描还是比较耗费IO资源的，所以业务高峰期还是不能直接在线上主库执行全表扫描的。</p>
<p>最后，我给你留一个思考题吧。</p>
<p>我在文章中说到，如果由于客户端压力太大，迟迟不能接收结果，会导致MySQL无法发送结果而影响语句执行。但，这还不是最糟糕的情况。</p>
<p>你可以设想出由于客户端的性能问题，对数据库影响更严重的例子吗？或者你是否经历过这样的场景？你又是怎么优化的？</p>
<p>你可以把你的经验和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，如果一个事务被kill之后，持续处于回滚状态，从恢复速度的角度看，你是应该重启等它执行结束，还是应该强行重启整个MySQL进程。</p>
<p>因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。</p>
<p>当然，如果这个语句可能会占用别的锁，或者由于占用IO资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。</p>
<p>切换之后别的线程都断开了连接，自动停止执行。接下来还是等它自己执行完成。这个操作属于我们在文章中说到的，减少系统压力，加速终止逻辑。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@HuaMax 的回答中提到了对其他线程的影响；<br>@夹心面包 @Ryoma @曾剑 同学提到了重启后依然继续做回滚操作的逻辑。</p>
</blockquote>
<p>@700：<br>老师，您好。根据文章内容，提炼如下信息：<br>如果你看到 State 的值一直处于“Sending to client”，就表示服务器端的网络栈写满了。<br>如何处理？<br>1)使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。<br>2)优化查询结果，并评估这么多的返回结果是否合理。<br>3)而如果要快速减少处于这个状态的线程的话，将 net_buffer_length 参数设置为一个更大的值是一个可选方案。<br>对于第3)方案不是很懂，“Sending to client” 表示服务器端的网路栈写满了，那不是应该加大 socket send buffer 吗？跟加大 net_buffer_length 有什么关系？net_buffer_length 加再大，但 socket send buffer 很小的话，网络栈不还是处于写满状态？</p>
<p>@作者 回复：<br>好问题👍 很好的思考👍</p>
<p>是这样的，net_buffer_length 的最大值是 1G，这个值比 socket send buffer大（一般是几M）</p>
<p>比如假设一个业务，他的平均查询结果都是10M （当然这个业务有有问题，最终是要通过业务解决）</p>
<p>但是如果我把net_buffer_length 改成10M，就不会有“Sending to client” 的情况。虽然网络栈还是慢慢发的，但是那些没发完的都缓存在net_buffer中，对于执行器来说，都是“已经写出去了”。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>34 | 到底可不可以使用join</title>
    <url>/posts/6cf4ff93.html</url>
    <content><![CDATA[<p>在实际生产中，关于join语句使用的问题，一般会集中在以下两类：</p>
<ol>
<li>我们DBA不让使用join，使用join有什么问题呢？</li>
<li>如果有两个大小不同的表做join，应该用哪个表做驱动表呢？</li>
</ol>
<span id="more"></span>

<p>今天这篇文章，我就先跟你说说join语句到底是怎么执行的，然后再来回答这两个问题。</p>
<p>为了便于量化分析，我还是创建两个表t1和t2来和你说明。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，这两个表都有一个主键索引id和一个索引a，字段b上无索引。存储过程idata()往表t2里插入了1000行数据，在表t1里插入的是100行数据。</p>
<h1 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h1><p>我们来看一下这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br></pre></td></tr></table></figure>

<p>如果直接使用join语句，MySQL优化器可能会选择表t1或t2作为驱动表，这样会影响我们分析SQL语句的执行过程。所以，为了便于分析执行过程中的性能问题，我改用straight_join让MySQL使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去join。在这个语句里，t1 是驱动表，t2是被驱动表。</p>
<p>现在，我们来看一下这条语句的explain结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/4b/90/4b9cb0e0b83618e01c9bfde44a0ea990.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 使用索引字段join的 explain结果</b>
    </div>
    <br>
</center>

<p>可以看到，在这条语句里，被驱动表t2的字段a上有索引，join过程用上了这个索引，因此这个语句的执行流程是这样的：</p>
<ol>
<li>从表t1中读入一行数据 R；</li>
<li>从数据行R中，取出a字段到表t2里去查找；</li>
<li>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</li>
<li>重复执行步骤1到3，直到表t1的末尾循环结束。</li>
</ol>
<p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称NLJ。</p>
<p>它对应的流程图如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/d8/f6/d83ad1cbd6118603be795b26d38f8df6.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 Index Nested-Loop Join算法的执行流程</b>
    </div>
    <br>
</center>

<p>在这个流程里：</p>
<ol>
<li>对驱动表t1做了全表扫描，这个过程需要扫描100行；</li>
<li>而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行；</li>
<li>所以，整个执行流程，总扫描行数是200。</li>
</ol>
<p>现在我们知道了这个过程，再试着回答一下文章开头的两个问题。</p>
<p>先看第一个问题：<strong>能不能使用join?</strong></p>
<p>假设不使用join，那我们就只能用单表查询。我们看看上面这条语句的需求，用单表查询怎么实现。</p>
<ol>
<li>执行<code>select * from t1</code>，查出表t1的所有数据，这里有100行；</li>
<li>循环遍历这100行数据：<ul>
<li>从每一行R取出字段a的值$R.a；</li>
<li>执行<code>select * from t2 where a=$R.a</code>；</li>
<li>把返回的结果和R构成结果集的一行。</li>
</ul>
</li>
</ol>
<p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句和结果。</p>
<p>显然，这么做还不如直接join好。</p>
<p>我们再来看看第二个问题：<strong>怎么选择驱动表？</strong></p>
<p>在这个join语句执行过程中，驱动表是走全表扫描，而被驱动表是走树搜索。</p>
<p>假设被驱动表的行数是M。每次在被驱动表查一行数据，要先搜索索引a，再搜索主键索引。每次搜索一棵树近似复杂度是以2为底的M的对数，记为log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p>
<p>假设驱动表的行数是N，执行过程就要扫描驱动表N行，然后对于每一行，到被驱动表上匹配一次。</p>
<p>因此整个执行过程，近似复杂度是 N + N<em>2</em>log2M。</p>
<p>显然，N对扫描行数的影响更大，因此应该让小表来做驱动表。</p>
<blockquote>
<p>如果你没觉得这个影响有那么“显然”， 可以这么理解：N扩大1000倍的话，扫描行数就会扩大1000倍；而M扩大1000倍，扫描行数扩大不到10倍。</p>
</blockquote>
<p>到这里小结一下，通过上面的分析我们得到了两个结论：</p>
<ol>
<li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能要好；</li>
<li>如果使用join语句的话，需要让小表做驱动表。</li>
</ol>
<p>但是，你需要注意，这个结论的前提是“可以使用被驱动表的索引”。</p>
<p>接下来，我们再看看被驱动表用不上索引的情况。</p>
<h1 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h1><p>现在，我们把SQL语句改成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></table></figure>

<p>由于表t2的字段b上没有索引，因此再用图2的执行流程时，每次到t2去匹配的时候，就要做一次全表扫描。</p>
<p>你可以先设想一下这个问题，继续使用图2的算法，是不是可以得到正确的结果呢？如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p>
<p>但是，这样算来，这个SQL请求就要扫描表t2多达100次，总共扫描100*1000&#x3D;10万行。</p>
<p>这还只是两个小表，如果t1和t2都是10万行的表（当然了，这也还是属于小表的范围），就要扫描100亿行，这个算法看上去太“笨重”了。</p>
<p>当然，MySQL也没有使用这个Simple Nested-Loop Join算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称BNL。</p>
<h1 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h1><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol>
<li>把表t1的数据读入线程内存join_buffer中，由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；</li>
<li>扫描表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。</li>
</ol>
<p>这个过程的流程图如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/15/73/15ae4f17c46bf71e8349a8f2ef70d573.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 Block Nested-Loop Join 算法的执行流程</b>
    </div>
    <br>
</center>

<p>对应地，这条SQL语句的explain结果如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/67/e1/676921fa0883e9463dd34fb2bc5e87e1.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 不使用索引字段join的 explain结果</b>
    </div>
    <br>
</center>

<p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100。由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000&#x3D;10万次。</p>
<p>前面我们说过，如果使用Simple Nested-Loop Join算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join算法的这10万次判断是内存操作，速度上会快很多，性能也更好。</p>
<p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p>
<p>假设小表的行数是N，大表的行数是M，那么在这个算法里：</p>
<ol>
<li>两个表都做一次全表扫描，所以总的扫描行数是M+N；</li>
<li>内存中的判断次数是M*N。</li>
</ol>
<p>可以看到，调换这两个算式中的M和N没差别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p>
<p>然后，你可能马上就会问了，这个例子里表t1才100行，要是表t1是一个大表，join_buffer放不下怎么办呢？</p>
<p>join_buffer的大小是由参数join_buffer_size设定的，默认值是256k。<strong>如果放不下表t1的所有数据话，策略很简单，就是分段放。</strong>我把join_buffer_size改成1200，再执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></table></figure>

<p>执行过程就变成了：</p>
<ol>
<li>扫描表t1，顺序读取数据行放入join_buffer中，放完第88行join_buffer满了，继续第2步；</li>
<li>扫描表t2，把t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回；</li>
<li>清空join_buffer；</li>
<li>继续扫描表t1，顺序读取最后的12行数据放入join_buffer中，继续执行第2步。</li>
</ol>
<p>执行流程图也就变成这样：</p>
<p><img src="https://static001.geekbang.org/resource/image/69/c4/695adf810fcdb07e393467bcfd2f6ac4.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 Block Nested-Loop Join -- 两段</b>
    </div>
    <br>
</center>

<p>图中的步骤4和5，表示清空join_buffer再复用。</p>
<p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去join”。</p>
<p>可以看到，这时候由于表t1被分成了两次放入join_buffer中，导致表t2会被扫描两次。虽然分成两次放入join_buffer，但是判断等值条件的次数还是不变的，依然是(88+12)*1000&#x3D;10万次。</p>
<p>我们再来看下，在这种情况下驱动表的选择问题。</p>
<p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p>
<p>注意，这里的K不是常数，N越大K就会越大，因此把K表示为λ*N，显然λ的取值范围是(0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol>
<li>扫描行数是 N+λ<em>N</em>M；</li>
<li>内存判断 N*M次。</li>
</ol>
<p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在M和N大小确定的情况下，N小一些，整个算式的结果会更小。</p>
<p>所以结论是，应该让小表当驱动表。</p>
<p>当然，你会发现，在N+λ<em>N</em>M这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。</p>
<p>刚刚我们说了N越大，分段数K越大。那么，N固定的时候，什么参数会影响K的大小呢？（也就是λ的大小）答案是join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p>
<p>这就是为什么，你可能会看到一些建议告诉你，如果你的join语句很慢，就把join_buffer_size改大。</p>
<p>理解了MySQL执行join的两种算法，现在我们再来试着<strong>回答文章开头的两个问题</strong>。</p>
<p>第一个问题：能不能使用join语句？</p>
<ol>
<li>如果可以使用Index Nested-Loop Join算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li>
<li>如果使用Block Nested-Loop Join算法，扫描行数就会过多。尤其是在大表上的join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</li>
</ol>
<p>所以你在判断要不要使用join语句时，就是看explain结果里面，Extra字段里面有没有出现“Block Nested Loop”字样。</p>
<p>第二个问题是：如果要使用join，应该选择大表做驱动表还是选择小表做驱动表？</p>
<ol>
<li>如果是Index Nested-Loop Join算法，应该选择小表做驱动表；</li>
<li>如果是Block Nested-Loop Join算法：<ul>
<li>在join_buffer_size足够大的时候，是一样的；</li>
<li>在join_buffer_size不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>
</ul>
</li>
</ol>
<p>所以，这个问题的结论就是，总是应该使用小表做驱动表。</p>
<p>当然了，这里我需要说明下，<strong>什么叫作“小表”</strong>。</p>
<p>我们前面的例子是没有加条件的。如果我在语句的where条件加上 t2.id&lt;&#x3D;50这个限定条件，再来看下这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">50</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>注意，为了让两条语句的被驱动表都用不上索引，所以join字段都使用了没有索引的字段b。</p>
<p>但如果是用第二个语句的话，join_buffer只需要放入t2的前50行，显然是更好的。所以这里，“t2的前50行”是那个相对小的表，也就是“小表”。</p>
<p>我们再来看另外一组例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span>  t1  straight_join t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>;</span><br><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span>  t2  straight_join t1 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子里，表t1 和 t2都是只有100行参加join。但是，这两条语句每次查询放入join_buffer中的数据是不一样的：</p>
<ul>
<li>表t1只查字段b，因此如果把t1放到join_buffer中，则join_buffer中只需要放入b的值；</li>
<li>表t2需要查所有的字段，因此如果把表t2放到join_buffer中的话，就需要放入三个字段id、a和b。</li>
</ul>
<p>这里，我们应该选择表t1作为驱动表。也就是说在这个例子里，“只需要一列参与join的表t1”是那个相对小的表。</p>
<p>所以，更准确地说，<strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你介绍了MySQL执行join语句的两种可能算法，这两种算法是由能否使用被驱动表的索引决定的。而能否用上被驱动表的索引，对join语句的性能影响很大。</p>
<p>通过对Index Nested-Loop Join和Block Nested-Loop Join两个算法执行过程的分析，我们也得到了文章开头两个问题的答案：</p>
<ol>
<li>如果可以使用被驱动表的索引，join语句还是有其优势的；</li>
<li>不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句就尽量不要使用；</li>
<li>在使用join的时候，应该让小表做驱动表。</li>
</ol>
<p>最后，又到了今天的问题时间。</p>
<p>我们在上文说到，使用Block Nested-Loop Join算法，可能会因为join_buffer不够大，需要对被驱动表做多次全表扫描。</p>
<p>我的问题是，如果被驱动表是一个大表，并且是一个冷数据表，除了查询过程中可能会导致IO压力大以外，你觉得对这个MySQL服务还有什么更严重的影响吗？（这个问题需要结合上一篇文章的知识点）</p>
<p>你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上一篇文章最后留下的问题是，如果客户端由于压力过大，迟迟不能接收数据，会对服务端造成什么严重的影响。</p>
<p>这个问题的核心是，造成了“长事务”。</p>
<p>至于长事务的影响，就要结合我们前面文章中提到的锁、MVCC的知识点了。</p>
<ul>
<li>如果前面的语句有更新，意味着它们在占用着行锁，会导致别的语句更新被锁住；</li>
<li>当然读的事务也有问题，就是会导致undo log不能被回收，导致回滚段空间膨胀。</li>
</ul>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@老杨同志 提到了更新之间会互相等锁的问题。同一个事务，更新之后要尽快提交，不要做没必要的查询，尤其是不要执行需要返回大量数据的查询；<br>@长杰 同学提到了undo表空间变大，db服务堵塞，服务端磁盘空间不足的例子。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>35 | join语句怎么优化</title>
    <url>/posts/49276c08.html</url>
    <content><![CDATA[<p>在上一篇文章中，我和你介绍了join语句的两种算法，分别是Index Nested-Loop Join(NLJ)和Block Nested-Loop Join(BNL)。</p>
<p>我们发现在使用NLJ算法的时候，其实效果还是不错的，比通过应用层拆分成多个语句然后再拼接查询结果更方便，而且性能也不会差。</p>
<p>但是，BNL算法在大表join的时候性能就差多了，比较次数等于两个表参与join的行数的乘积，很消耗CPU资源。</p>
<p>当然了，这两个算法都还有继续优化的空间，我们今天就来聊聊这个话题。</p>
<span id="more"></span>

<p>为了便于分析，我还是创建两个表t1、t2来和你展开今天的问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, <span class="number">1001</span><span class="operator">-</span>i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>为了便于后面量化说明，我在表t1里，插入了1000行数据，每一行的a&#x3D;1001-id的值。也就是说，表t1中字段a是逆序的。同时，我在表t2中插入了100万行数据。</p>
<h1 id="Multi-Range-Read优化"><a href="#Multi-Range-Read优化" class="headerlink" title="Multi-Range Read优化"></a>Multi-Range Read优化</h1><p>在介绍join语句的优化方案之前，我需要先和你介绍一个知识点，即：Multi-Range Read优化(MRR)。这个优化的主要目的是尽量使用顺序读盘。</p>
<p>在<a href="https://time.geekbang.org/column/article/69236">第4篇文章</a>中，我和你介绍InnoDB的索引结构时，提到了“回表”的概念。我们先来回顾一下这个概念。回表是指，InnoDB在普通索引a上查到主键id的值后，再根据一个个主键id的值到主键索引上去查整行数据的过程。</p>
<p>然后，有同学在留言区问到，回表过程是一行行地查数据，还是批量地查数据？</p>
<p>我们先来看看这个问题。假设，我执行这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> a<span class="operator">&lt;=</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>主键索引是一棵B+树，在这棵树上，每次只能根据一个主键id查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图1所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/17/11/1761edbd7734276ae0a213af3cdd3311.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 基本回表流程</b>
    </div>
    <br>
</center>

<p>如果随着a的值递增顺序查询的话，id的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。</p>
<p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p>
<p>这，就是MRR优化的设计思路。此时，语句的执行流程变成了这样：</p>
<ol>
<li>根据索引a，定位到满足条件的记录，将id值放入read_rnd_buffer中;</li>
<li>将read_rnd_buffer中的id进行递增排序；</li>
<li>排序后的id数组，依次到主键id索引中查记录，并作为结果返回。</li>
</ol>
<p>这里，read_rnd_buffer的大小是由read_rnd_buffer_size参数控制的。如果步骤1中，read_rnd_buffer放满了，就会先执行完步骤2和3，然后清空read_rnd_buffer。之后继续找索引a的下个记录，并继续循环。</p>
<p>另外需要说明的是，如果你想要稳定地使用MRR优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用MRR，把mrr_cost_based设置为off，就是固定使用MRR了。）</p>
<p>下面两幅图就是使用了MRR优化后的执行流程和explain结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/d5/c7/d502fbaea7cac6f815c626b078da86c7.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 MRR执行流程</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/a5/32/a513d07ebaf1ae044d44391c89bc6432.png"></p>
<p>图3 MRR执行流程的explain结果从图3的explain结果中，我们可以看到Extra字段多了Using MRR，表示的是用上了MRR优化。而且，由于我们在read_rnd_buffer中按照id做了排序，所以最后得到的结果集也是按照主键id递增顺序的，也就是与图1结果集中行的顺序相反。</p>
<p>到这里，我们小结一下。</p>
<p><strong>MRR能够提升性能的核心</strong>在于，这条查询语句在索引a上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>
<h1 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h1><p>理解了MRR性能提升的原理，我们就能理解MySQL在5.6版本后开始引入的Batched Key Acess(BKA)算法了。这个BKA算法，其实就是对NLJ算法的优化。</p>
<p>我们再来看看上一篇文章中用到的NLJ算法的流程图：</p>
<p><img src="https://static001.geekbang.org/resource/image/10/3d/10e14e8b9691ac6337d457172b641a3d.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 Index Nested-Loop Join流程图</b>
    </div>
    <br>
</center>

<p>NLJ算法执行的逻辑是：从驱动表t1，一行行地取出a的值，再到被驱动表t2去做join。也就是说，对于表t2来说，每次都是匹配一个值。这时，MRR的优势就用不上了。</p>
<p>那怎么才能一次性地多传些值给表t2呢？方法就是，从表t1里一次性地多拿些行出来，一起传给表t2。</p>
<p>既然如此，我们就把表t1的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是join_buffer。</p>
<p>通过上一篇文章，我们知道join_buffer 在BNL算法里的作用，是暂存驱动表的数据。但是在NLJ算法里并没有用。那么，我们刚好就可以复用join_buffer到BKA算法中。</p>
<p>如图5所示，是上面的NLJ算法优化后的BKA算法的流程。</p>
<p><img src="https://static001.geekbang.org/resource/image/31/7e/31d85666542b9cb0b47a447a8593a47e.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 Batched Key Acess流程</b>
    </div>
    <br>
</center>

<p>图中，我在join_buffer中放入的数据是P1<del>P100，表示的是只会取查询需要的字段。当然，如果join buffer放不下P1</del>P100的所有数据，就会把这100行数据分成多段执行上图的流程。</p>
<p>那么，这个BKA算法到底要怎么启用呢？</p>
<p>如果要使用BKA优化算法的话，你需要在执行SQL语句之前，先设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>其中，前两个参数的作用是要启用MRR。这么做的原因是，BKA算法的优化要依赖于MRR。</p>
<h1 id="BNL算法的性能问题"><a href="#BNL算法的性能问题" class="headerlink" title="BNL算法的性能问题"></a>BNL算法的性能问题</h1><p>说完了NLJ算法的优化，我们再来看BNL算法的优化。</p>
<p>我在上一篇文章末尾，给你留下的思考题是，使用Block Nested-Loop Join(BNL)算法时，可能会对被驱动表做多次扫描。如果这个被驱动表是一个大的冷数据表，除了会导致IO压力大以外，还会对系统有什么影响呢？</p>
<p>在<a href="https://time.geekbang.org/column/article/79407">第33篇文章</a>中，我们说到InnoDB的LRU算法的时候提到，由于InnoDB对Bufffer Pool的LRU算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在old区域。如果1秒之后这个数据页不再被访问了，就不会被移动到LRU链表头部，这样对Buffer Pool的命中率影响就不大。</p>
<p>但是，如果一个使用BNL算法的join语句，多次扫描一个冷表，而且这个语句执行时间超过1秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU链表头部。</p>
<p>这种情况对应的，是冷表的数据量小于整个Buffer Pool的3&#x2F;8，能够完全放入old区域的情况。</p>
<p>如果这个冷表很大，就会出现另外一种情况：业务正常访问的数据页，没有机会进入young区域。</p>
<p>由于优化机制的存在，一个正常访问的数据页，要进入young区域，需要隔1秒后再次被访问到。但是，由于我们的join语句在循环读磁盘和淘汰内存页，进入old区域的数据页，很可能在1秒之内就被淘汰了。这样，就会导致这个MySQL实例的Buffer Pool在这段时间内，young区域的数据页没有被合理地淘汰。</p>
<p>也就是说，这两种情况都会影响Buffer Pool的正常运作。</p>
<p><strong>大表join操作虽然对IO有影响，但是在语句执行结束后，对IO的影响也就结束了。但是，对Buffer Pool的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p>
<p>为了减少这种影响，你可以考虑增大join_buffer_size的值，减少对被驱动表的扫描次数。</p>
<p>也就是说，BNL算法对系统的影响主要包括三个方面：</p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘IO资源；</li>
<li>判断join条件需要执行M*N次对比（M、N分别是两张表的行数），如果是大表就会占用非常多的CPU资源；</li>
<li>可能会导致Buffer Pool的热数据被淘汰，影响内存命中率。</li>
</ol>
<p>我们执行语句之前，需要通过理论分析和查看explain结果的方式，确认是否要使用BNL算法。如果确认优化器会使用BNL算法，就需要做优化。优化的常见做法是，给被驱动表的join字段加上索引，把BNL算法转成BKA算法。</p>
<p>接下来，我们就具体看看，这个优化怎么做？</p>
<h1 id="BNL转BKA"><a href="#BNL转BKA" class="headerlink" title="BNL转BKA"></a>BNL转BKA</h1><p>一些情况下，我们可以直接在被驱动表上建索引，这时就可以直接转成BKA算法了。</p>
<p>但是，有时候你确实会碰到一些不适合在被驱动表上建索引的情况。比如下面这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> t2.b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<p>我们在文章开始的时候，在表t2中插入了100万行数据，但是经过where条件过滤后，需要参与join的只有2000行数据。如果这条语句同时是一个低频的SQL语句，那么再为这个语句在表t2的字段b上创建一个索引就很浪费了。</p>
<p>但是，如果使用BNL算法来join的话，这个语句的执行流程是这样的：</p>
<ol>
<li>把表t1的所有字段取出来，存入join_buffer中。这个表只有1000行，join_buffer_size默认值是256k，可以完全存入。</li>
<li>扫描表t2，取出每一行数据跟join_buffer中的数据进行对比，<ul>
<li>如果不满足t1.b&#x3D;t2.b，则跳过；</li>
<li>如果满足t1.b&#x3D;t2.b, 再判断其他条件，也就是是否满足t2.b处于[1,2000]的条件，如果是，就作为结果集的一部分返回，否则跳过。</li>
</ul>
</li>
</ol>
<p>我在上一篇文章中说过，对于表t2的每一行，判断join是否满足的时候，都需要遍历join_buffer中的所有行。因此判断等值条件的次数是1000*100万&#x3D;10亿次，这个判断的工作量很大。</p>
<p><img src="https://static001.geekbang.org/resource/image/92/60/92fbdbfc35da3040396401250cb33f60.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 explain结果</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/d8/9c/d862bc3e88305688df2c354a4b26809c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 语句执行时间</b>
    </div>
    <br>
</center>

<p>可以看到，explain结果里Extra字段显示使用了BNL算法。在我的测试环境里，这条语句需要执行1分11秒。</p>
<p>在表t2的字段b上创建索引会浪费资源，但是不创建索引的话这个语句的等值条件要判断10亿次，想想也是浪费。那么，有没有两全其美的办法呢？</p>
<p>这时候，我们可以考虑使用临时表。使用临时表的大致思路是：</p>
<ol>
<li>把表t2中满足条件的数据放在临时表tmp_t中；</li>
<li>为了让join使用BKA算法，给临时表tmp_t的字段b加上索引；</li>
<li>让表t1和tmp_t做join操作。</li>
</ol>
<p>此时，对应的SQL语句的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure>

<p>图8就是这个语句序列的执行效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/a8/c7/a80cdffe8173fa0fd8969ed976ac6ac7.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 使用临时表的执行效果</b>
    </div>
    <br>
</center>

<p>可以看到，整个过程3个语句执行时间的总和还不到1秒，相比于前面的1分11秒，性能得到了大幅提升。接下来，我们一起看一下这个过程的消耗：</p>
<ol>
<li>执行insert语句构造temp_t表并插入数据的过程中，对表t2做了全表扫描，这里扫描行数是100万。</li>
<li>之后的join语句，扫描表t1，这里的扫描行数是1000；join比较过程中，做了1000次带索引的查询。相比于优化前的join语句需要做10亿次条件判断来说，这个优化效果还是很明显的。</li>
</ol>
<p>总体来看，不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让join语句能够用上被驱动表上的索引，来触发BKA算法，提升查询性能。</p>
<h1 id="扩展-hash-join"><a href="#扩展-hash-join" class="headerlink" title="扩展-hash join"></a>扩展-hash join</h1><p>看到这里你可能发现了，其实上面计算10亿次那个操作，看上去有点儿傻。如果join_buffer里面维护的不是一个无序数组，而是一个哈希表的话，那么就不是10亿次判断，而是100万次hash查找。这样的话，整条语句的执行速度就快多了吧？</p>
<p>确实如此。</p>
<p>这，也正是MySQL的优化器和执行器一直被诟病的一个原因：不支持哈希join。并且，MySQL官方的roadmap，也是迟迟没有把这个优化排上议程。</p>
<p>实际上，这个优化思路，我们可以自己实现在业务端。实现流程大致如下：</p>
<ol>
<li><code>select * from t1;</code>取得表t1的全部1000行数据，在业务端存入一个hash结构，比如C++里的set、PHP的dict这样的数据结构。</li>
<li><code>select * from t2 where b&gt;=1 and b&lt;=2000;</code> 获取表t2中满足条件的2000行数据。</li>
<li>把这2000行数据，一行一行地取到业务端，到hash结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li>
</ol>
<p>理论上，这个过程会比临时表方案的执行速度还要快一些。如果你感兴趣的话，可以自己验证一下。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我和你分享了Index Nested-Loop Join（NLJ）和Block Nested-Loop Join（BNL）的优化方法。</p>
<p>在这些优化方法中：</p>
<ol>
<li>BKA优化是MySQL已经内置支持的，建议你默认使用；</li>
<li>BNL算法效率低，建议你都尽量转成BKA算法。优化的方向就是给被驱动表的关联字段加上索引；</li>
<li>基于临时表的改进方案，对于能够提前过滤出小数据的join语句来说，效果还是很好的；</li>
<li>MySQL目前的版本还不支持hash join，但你可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。</li>
</ol>
<p>最后，我给你留下一道思考题吧。</p>
<p>我们在讲join语句的这两篇文章中，都只涉及到了两个表的join。那么，现在有一个三个表join的需求，假设这三个表的表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t1` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ... <span class="operator">/</span><span class="operator">/</span>初始化三张表的数据</span><br></pre></td></tr></table></figure>

<p>语句的需求实现如下的join逻辑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span>(t1.a<span class="operator">=</span>t2.a) <span class="keyword">join</span> t3 <span class="keyword">on</span> (t2.b<span class="operator">=</span>t3.b) <span class="keyword">where</span> t1.c<span class="operator">&gt;=</span>X <span class="keyword">and</span> t2.c<span class="operator">&gt;=</span>Y <span class="keyword">and</span> t3.c<span class="operator">&gt;=</span>Z;</span><br></pre></td></tr></table></figure>

<p>现在为了得到最快的执行速度，如果让你来设计表t1、t2、t3上的索引，来支持这个join语句，你会加哪些索引呢？</p>
<p>同时，如果我希望你用straight_join来重写这个语句，配合你创建的索引，你就需要安排连接顺序，你主要考虑的因素是什么呢？</p>
<p>你可以把你的方案和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上篇文章最后留给你的问题，已经在本篇文章中解答了。</p>
<p>这里我再根据评论区留言的情况，简单总结下。根据数据量的大小，有这么两种情况：</p>
<ul>
<li>@长杰 和 @老杨同志 提到了数据量小于old区域内存的情况；</li>
<li>@Zzz 同学，很认真地看了其他同学的评论，并且提了一个很深的问题。对被驱动表数据量大于Buffer Pool的场景，做了很细致的推演和分析。</li>
</ul>
<p>给这些同学点赞，非常好的思考和讨论。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>38 | 都说InnoDB好，那还要不要使用Memory引擎</title>
    <url>/posts/9e114ace.html</url>
    <content><![CDATA[<p>我在上一篇文章末尾留给你的问题是：两个group by 语句都用了order by null，为什么使用内存临时表得到的语句结果里，0这个值在最后一行；而使用磁盘临时表得到的结果里，0这个值在第一行？</p>
<p>今天我们就来看看，出现这个问题的原因吧。</p>
<span id="more"></span>

<h1 id="内存表的数据组织结构"><a href="#内存表的数据组织结构" class="headerlink" title="内存表的数据组织结构"></a>内存表的数据组织结构</h1><p>为了便于分析，我来把这个问题简化一下，假设有以下的两张表t1 和 t2，其中表t1使用Memory 引擎， 表t2使用InnoDB引擎。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>Memory;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>然后，我分别执行select * from t1和select * from t2。</p>
<p><img src="https://static001.geekbang.org/resource/image/3f/e6/3fb1100b6e3390357d4efff0ba4765e6.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 两个查询结果-0的位置</b>
    </div>
    <br>
</center>

<p>可以看到，内存表t1的返回结果里面0在最后一行，而InnoDB表t2的返回结果里0在第一行。</p>
<p>出现这个区别的原因，要从这两个引擎的主键索引的组织方式说起。</p>
<p>表t2用的是InnoDB引擎，它的主键索引id的组织方式，你已经很熟悉了：InnoDB表的数据就放在主键索引树上，主键索引是B+树。所以表t2的数据组织方式如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/4e/8d/4e29e4f9db55ace6ab09161c68ad8c8d.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 表t2的数据组织</b>
    </div>
    <br>
</center>

<p>主键索引上的值是有序存储的。在执行select *的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0就出现在第一行。</p>
<p>与InnoDB引擎不同，Memory引擎的数据和索引是分开的。我们来看一下表t1中的数据内容。</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/84/dde03e92074cecba4154d30cd16a9684.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 表t1 的数据组织</b>
    </div>
    <br>
</center>

<p>可以看到，内存表的数据部分以数组的方式单独存放，而主键id索引里，存的是每个数据的位置。主键id是hash索引，可以看到索引上的key并不是有序的。</p>
<p>在内存表t1中，当我执行select *的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0就是最后一个被读到，并放入结果集的数据。</p>
<p>可见，InnoDB和Memory引擎的数据组织方式是不同的：</p>
<ul>
<li>InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id。这种方式，我们称之为<strong>索引组织表</strong>（Index Organizied Table）。</li>
<li>而Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为<strong>堆组织表</strong>（Heap Organizied Table）。</li>
</ul>
<p>从中我们可以看出，这两个引擎的一些典型不同：</p>
<ol>
<li>InnoDB表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，InnoDB表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob 和 Text字段，并且即使定义了varchar(N)，实际也当作char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
</ol>
<p>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。比如，如果要在表t1中执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure>

<p>就会看到返回结果里，id&#x3D;10这一行出现在id&#x3D;4之后，也就是原来id&#x3D;5这行数据的位置。</p>
<p>需要指出的是，表t1的这个主键索引是哈希索引，因此如果执行范围查询，比如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>是用不上主键索引的，需要走全表扫描。你可以借此再回顾下<a href="https://time.geekbang.org/column/article/69236">第4篇文章</a>的内容。那如果要让内存表支持范围扫描，应该怎么办呢 ？</p>
<h1 id="hash索引和B-Tree索引"><a href="#hash索引和B-Tree索引" class="headerlink" title="hash索引和B-Tree索引"></a>hash索引和B-Tree索引</h1><p>实际上，内存表也是支B-Tree索引的。在id列上创建一个B-Tree索引，SQL语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> index a_btree_index <span class="keyword">using</span> btree (id);</span><br></pre></td></tr></table></figure>

<p>这时，表t1的数据组织形式就变成了这样：</p>
<p><img src="https://static001.geekbang.org/resource/image/17/e3/1788deca56cb83c114d8353c92e3bde3.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 表t1的数据组织--增加B-Tree索引</b>
    </div>
    <br>
</center>

<p>新增的这个B-Tree索引你看着就眼熟了，这跟InnoDB的b+树索引组织形式类似。</p>
<p>作为对比，你可以看一下这下面这两个语句的输出：</p>
<p><img src="https://static001.geekbang.org/resource/image/a8/8a/a85808fcccab24911d257d720550328a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 使用B-Tree和hash索引查询返回结果对比</b>
    </div>
    <br>
</center>

<p>可以看到，执行select * from t1 where id&lt;5的时候，优化器会选择B-Tree索引，所以返回结果是0到4。 使用force index强行使用主键id这个索引，id&#x3D;0这一行就在结果集的最末尾了。</p>
<p>其实，一般在我们的印象中，内存表的优势是速度快，其中的一个原因就是Memory引擎支持hash索引。当然，更重要的原因是，内存表的所有数据都保存在内存，而内存的读写速度总是比磁盘快。</p>
<p>但是，接下来我要跟你说明，为什么我不建议你在生产环境上使用内存表。这里的原因主要包括两个方面：</p>
<ol>
<li>锁粒度问题；</li>
<li>数据持久化问题。</li>
</ol>
<h1 id="内存表的锁"><a href="#内存表的锁" class="headerlink" title="内存表的锁"></a>内存表的锁</h1><p>我们先来说说内存表的锁粒度问题。</p>
<p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>
<p>需要注意的是，这里的表锁跟之前我们介绍过的MDL锁不同，但都是表级的锁。接下来，我通过下面这个场景，跟你模拟一下内存表的表级锁。</p>
<p><img src="https://static001.geekbang.org/resource/image/f2/29/f216e2d707559ed2ca98fbe21e509f29.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 内存表的表锁--复现步骤</b>
    </div>
    <br>
</center>

<p>在这个执行序列里，session A的update语句要执行50秒，在这个语句执行期间session B的查询会进入锁等待状态。session C的show processlist 结果输出如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/14/16/14d88076dad6db573f0b66f2c17df916.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 内存表的表锁--结果</b>
    </div>
    <br>
</center>

<p>跟行锁比起来，表锁对并发访问的支持不够好。所以，内存表的锁粒度问题，决定了它在处理并发事务的时候，性能也不会太好。</p>
<h1 id="数据持久性问题"><a href="#数据持久性问题" class="headerlink" title="数据持久性问题"></a>数据持久性问题</h1><p>接下来，我们再看看数据持久性的问题。</p>
<p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p>
<p>你可能会说，如果数据库异常重启，内存表被清空也就清空了，不会有什么问题啊。但是，在高可用架构下，内存表的这个特点简直可以当做bug来看待了。为什么这么说呢？</p>
<p><strong>我们先看看M-S架构下，使用内存表存在的问题。</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/5b/e9/5b910e4c0f1afa219aeecd1f291c95e9.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 M-S基本架构</b>
    </div>
    <br>
</center>

<p>我们来看一下下面这个时序：</p>
<ol>
<li>业务正常访问主库；</li>
<li>备库硬件升级，备库重启，内存表t1内容被清空；</li>
<li>备库重启后，客户端发送一条update语句，修改表t1的数据行，这时备库应用线程就会报错“找不到要更新的行”。</li>
</ol>
<p>这样就会导致主备同步停止。当然，如果这时候发生主备切换的话，客户端会看到，表t1的数据“丢失”了。</p>
<p>在图8中这种有proxy的架构里，大家默认主备切换的逻辑是由数据库系统自己维护的。这样对客户端来说，就是“网络断开，重连之后，发现内存表数据丢失了”。</p>
<p>你可能说这还好啊，毕竟主备发生切换，连接会断开，业务端能够感知到异常。</p>
<p>但是，接下来内存表的这个特性就会让使用现象显得更“诡异”了。由于MySQL知道重启之后，内存表的数据会丢失。所以，担心主库重启之后，出现主备不一致，MySQL在实现上做了这样一件事儿：在数据库重启之后，往binlog里面写入一行DELETE FROM t1。</p>
<p><strong>如果你使用是如图9所示的双M结构的话：</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/40/57/4089c9c1f92ce61d2ed779fd0932ba57.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 双M结构</b>
    </div>
    <br>
</center>

<p>在备库重启的时候，备库binlog里的delete语句就会传到主库，然后把主库内存表的内容删除。这样你在使用的时候就会发现，主库的内存表数据突然被清空了。</p>
<p>基于上面的分析，你可以看到，内存表并不适合在生产环境上作为普通数据表使用。</p>
<p>有同学会说，但是内存表执行速度快呀。这个问题，其实你可以这么分析：</p>
<ol>
<li>如果你的表更新量大，那么并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比内存表好；</li>
<li>能放到内存表的数据量都不大。如果你考虑的是读的性能，一个读QPS很高并且数据量不大的表，即使是使用InnoDB，数据也是都会缓存在InnoDB Buffer Pool里的。因此，使用InnoDB表的读性能也不会差。</li>
</ol>
<p>所以，<strong>我建议你把普通内存表都用InnoDB表来代替。</strong>但是，有一个场景却是例外的。</p>
<p>这个场景就是，我们在第35和36篇说到的用户临时表。在数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表。</p>
<p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p>
<ol>
<li>临时表不会被其他线程访问，没有并发性的问题；</li>
<li>临时表重启后也是需要删除的，清空数据这个问题不存在；</li>
<li>备库的临时表也不会影响主库的用户线程。</li>
</ol>
<p>现在，我们回过头再看一下第35篇join语句优化的例子，当时我建议的是创建一个InnoDB临时表，使用的语句序列是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure>

<p>了解了内存表的特性，你就知道了， 其实这里使用内存临时表的效果更好，原因有三个：</p>
<ol>
<li>相比于InnoDB表，使用内存表不需要写磁盘，往表temp_t的写数据的速度更快；</li>
<li>索引b使用hash索引，查找的速度比B-Tree索引快；</li>
<li>临时表数据只有2000行，占用的内存有限。</li>
</ol>
<p>因此，你可以对<a href="https://time.geekbang.org/column/article/80147">第35篇文章</a>的语句序列做一个改写，将临时表t1改成内存临时表，并且在字段b上创建一个hash索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index (b))engine<span class="operator">=</span>memory;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/a4/92/a468ba6d14ea225623074b6255b99f92.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图10 使用内存临时表的执行效果</b>
    </div>
    <br>
</center>

<p>可以看到，不论是导入数据的时间，还是执行join的时间，使用内存临时表的速度都比使用InnoDB临时表要更快一些。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我从“要不要使用内存表”这个问题展开，和你介绍了Memory引擎的几个特性。</p>
<p>可以看到，由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双M架构，还可能导致主库的内存表数据被删掉。</p>
<p>因此，在生产上，我不建议你使用普通内存表。</p>
<p>如果你是DBA，可以在建表的审核系统中增加这类规则，要求业务改用InnoDB表。我们在文中也分析了，其实InnoDB表性能还不错，而且数据安全也有保障。而内存表由于不支持行锁，更新语句会阻塞查询，性能也未必就如想象中那么好。</p>
<p>基于内存表的特性，我们还分析了它的一个适用场景，就是内存临时表。内存表支持hash索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p>
<p>最后，我给你留一个问题吧。</p>
<p>假设你刚刚接手的一个数据库上，真的发现了一个内存表。备库重启之后肯定是会导致备库的内存表数据被清空，进而导致主备同步停止。这时，最好的做法是将它修改成InnoDB引擎表。</p>
<p>假设当时的业务场景暂时不允许你修改引擎，你可以加上什么自动化逻辑，来避免主备同步停止呢？</p>
<p>你可以把你的思考和分析写在评论区，我会在下一篇文章的末尾跟你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>今天文章的正文内容，已经回答了我们上期的问题，这里就不再赘述了。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@老杨同志、@poppy、@长杰 这三位同学给出了正确答案</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>37 | 什么时候会使用内部临时表</title>
    <url>/posts/56a12130.html</url>
    <content><![CDATA[<p>在<a href="https://time.geekbang.org/column/article/73479">第16</a>和<a href="https://time.geekbang.org/column/article/79700">第34</a>篇文章中，我分别和你介绍了sort buffer、内存临时表和join buffer。这三个数据结构都是用来存放语句执行过程中的中间数据，以辅助SQL语句的执行的。其中，我们在排序的时候用到了sort buffer，在使用join语句的时候用到了join buffer。</p>
<p>然后，你可能会有这样的疑问，MySQL什么时候会使用内部临时表呢？</p>
<span id="more"></span>

<p>今天这篇文章，我就先给你举两个需要用到内部临时表的例子，来看看内部临时表是怎么工作的。然后，我们再来分析，什么情况下会使用内部临时表。</p>
<h1 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h1><p>为了便于量化分析，我用下面的表t1来举例。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>然后，我们执行下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这条语句用到了union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p>
<p>下图是这个语句的explain结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/40/4e/402cbdef84eef8f1b42201c6ec4bad4e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 union语句explain 结果</b>
    </div>
    <br>
</center>

<p>可以看到：</p>
<ul>
<li>第二行的key&#x3D;PRIMARY，说明第二个子句用到了索引id。</li>
<li>第三行的Extra字段，表示在对子查询的结果集做union的时候，使用了临时表(Using temporary)。</li>
</ul>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段f，并且f是主键字段。</li>
<li>执行第一个子查询，得到1000这个值，并存入临时表中。</li>
<li>执行第二个子查询：<ul>
<li>拿到第一行id&#x3D;1000，试图插入临时表中。但由于1000这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>
<li>取到第二行id&#x3D;999，插入临时表成功。</li>
</ul>
</li>
<li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是1000和999。</li>
</ol>
<p>这个过程的流程图如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/5d/0e/5d038c1366d375cc997005a5d65c600e.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 2 union 执行流程</b>
    </div>
    <br>
</center>

<p>可以看到，这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键id的唯一性约束，实现了union的语义。</p>
<p>顺便提一下，如果把上面这个语句中的union改成union all的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p>
<p><img src="https://static001.geekbang.org/resource/image/c1/6d/c1e90d1d7417b484d566b95720fe3f6d.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 union all的explain结果</b>
    </div>
    <br>
</center>

<p>可以看到，第二行的Extra字段显示的是Using index，表示只使用了覆盖索引，没有用临时表了。</p>
<h1 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h1><p>另外一个常见的使用临时表的例子是group by，我们来看一下这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>

<p>这个语句的逻辑是把表t1里的数据，按照 id%10 进行分组统计，并按照m的结果排序后输出。它的explain结果如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/3d/98/3d1cb94589b6b3c4bb57b0bdfa385d98.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 group by 的explain结果</b>
    </div>
    <br>
</center>

<p>在Extra字段里面，我们可以看到三个信息：</p>
<ul>
<li>Using index，表示这个语句使用了覆盖索引，选择了索引a，不需要回表；</li>
<li>Using temporary，表示使用了临时表；</li>
<li>Using filesort，表示需要排序。</li>
</ul>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建内存临时表，表里有两个字段m和c，主键是m；</li>
<li>扫描表t1的索引a，依次取出叶子节点上的id值，计算id%10的结果，记为x；<ul>
<li>如果临时表中没有主键为x的行，就插入一个记录(x,1);</li>
<li>如果表中有主键为x的行，就将x这一行的c值加1；</li>
</ul>
</li>
<li>遍历完成后，再根据字段m做排序，得到结果集返回给客户端。</li>
</ol>
<p>这个流程的执行图如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/03/54/0399382169faf50fc1b354099af71954.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 group by执行流程</b>
    </div>
    <br>
</center>

<p>图中最后一步，对内存临时表的排序，在<a href="https://time.geekbang.org/column/article/73795">第17篇文章</a>中已经有过介绍，我把图贴过来，方便你回顾。</p>
<p><img src="https://static001.geekbang.org/resource/image/b5/68/b5168d201f5a89de3b424ede2ebf3d68.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 内存临时表排序流程</b>
    </div>
    <br>
</center>

<p>其中，临时表的排序过程就是图6中虚线框内的过程。</p>
<p>接下来，我们再看一下这条语句的执行结果：</p>
<p><img src="https://static001.geekbang.org/resource/image/ae/55/ae6a28d890efc35ee4d07f694068f455.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 7 group by执行结果</b>
    </div>
    <br>
</center>

<p>如果你的需求并不需要对结果进行排序，那你可以在SQL语句末尾增加order by null，也就是改成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这样就跳过了最后排序的阶段，直接从临时表中取数据返回。返回的结果如图8所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/03/eb/036634e53276eaf8535c3442805dfaeb.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 group + order by null 的结果（内存临时表）</b>
    </div>
    <br>
</center>

<p>由于表t1中的id值是从1开始的，因此返回的结果集中第一行是id&#x3D;1；扫描到id&#x3D;10的时候才插入m&#x3D;0这一行，因此结果集里最后一行才是m&#x3D;0。</p>
<p>这个例子里由于临时表只有10行，内存可以放得下，因此全程只使用了内存临时表。但是，内存临时表的大小是有限制的，参数tmp_table_size就是控制这个内存大小的，默认是16M。</p>
<p>如果我执行下面这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>把内存临时表的大小限制为最大1024字节，并把语句改成id % 100，这样返回结果里有100行数据。但是，这时的内存临时表大小不够存下这100行数据，也就是说，执行过程中会发现内存临时表大小到达了上限（1024字节）。</p>
<p>那么，这时候就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是InnoDB。 这时，返回的结果如图9所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/a7/6e/a76381d0f3c947292cc28198901f9e6e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 group + order by null 的结果（磁盘临时表）</b>
    </div>
    <br>
</center>

<p>如果这个表t1的数据量很大，很可能这个查询需要的磁盘临时表就会占用大量的磁盘空间。</p>
<h1 id="group-by-优化方法-–索引"><a href="#group-by-优化方法-–索引" class="headerlink" title="group by 优化方法 –索引"></a>group by 优化方法 –索引</h1><p>可以看到，不论是使用内存临时表还是磁盘临时表，group by逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个group by语句执行起来就会很慢，我们有什么优化的方法呢？</p>
<p>要解决group by语句的优化问题，你可以先想一下这个问题：执行group by语句为什么需要临时表？</p>
<p>group by的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的id%100的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>
<p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？</p>
<p>假设，现在有一个类似图10的这么一个数据结构，我们来看看group by可以怎么做。</p>
<p><img src="https://static001.geekbang.org/resource/image/5c/19/5c4a581c324c1f6702f9a2c70acddd19.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图10 group by算法优化-有序输入</b>
    </div>
    <br>
</center>

<p>可以看到，如果可以确保输入的数据是有序的，那么计算group by的时候，就只需要从左到右，顺序扫描，依次累加。也就是下面这个过程：</p>
<ul>
<li>当碰到第一个1的时候，已经知道累积了X个0，结果集里的第一行就是(0,X);</li>
<li>当碰到第一个2的时候，已经知道累积了Y个1，结果集里的第二行就是(1,Y);</li>
</ul>
<p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到group by的结果，不需要临时表，也不需要再额外排序。</p>
<p>你一定想到了，InnoDB的索引，就可以满足这个输入有序的条件。</p>
<p>在MySQL 5.7版本支持了generated column机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列z，然后在z列上创建一个索引（如果是MySQL 5.6及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="type">int</span> generated always <span class="keyword">as</span>(id <span class="operator">%</span> <span class="number">100</span>), <span class="keyword">add</span> index(z);</span><br></pre></td></tr></table></figure>

<p>这样，索引z上的数据就是类似图10这样有序的了。上面的group by语句就可以改成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> z, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br></pre></td></tr></table></figure>

<p>优化后的group by语句的explain结果，如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/c9/b9/c9f88fa42d92cf7dde78fca26c4798b9.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图11 group by 优化的explain结果</b>
    </div>
    <br>
</center>

<p>从Extra字段可以看到，这个语句的执行不再需要临时表，也不需要排序了。</p>
<h1 id="group-by优化方法-–直接排序"><a href="#group-by优化方法-–直接排序" class="headerlink" title="group by优化方法 –直接排序"></a>group by优化方法 –直接排序</h1><p>所以，如果可以通过加索引来完成group by逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的group by要怎么优化呢？</p>
<p>如果我们明明知道，一个group by语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p>
<p>那么，我们就会想了，MySQL有没有让我们直接走磁盘临时表的方法呢？</p>
<p>答案是，有的。</p>
<p>在group by语句中加入SQL_BIG_RESULT这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>
<p>MySQL的优化器一看，磁盘临时表是B+树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>
<p>因此，下面这个语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_BIG_RESULT id<span class="operator">%</span><span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>

<p>的执行流程就是这样的：</p>
<ol>
<li>初始化sort_buffer，确定放入一个整型字段，记为m；</li>
<li>扫描表t1的索引a，依次取出里面的id值, 将 id%100的值存入sort_buffer中；</li>
<li>扫描完成后，对sort_buffer的字段m做排序（如果sort_buffer内存不够用，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
</ol>
<p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。这一步的逻辑，你已经从前面的图10中了解过了。</p>
<p>下面两张图分别是执行流程图和执行explain命令得到的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/82/6a/8269dc6206a7ef20cb515c23df0b846a.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图12 使用 SQL_BIG_RESULT的执行流程图</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/83/ec/83b6cd6b3e37dfbf9699cf0ccc0f1bec.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b></b>
    </div>
    <br>
</center>

<p>图13 使用 SQL_BIG_RESULT的explain 结果从Extra字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p>
<p>基于上面的union、union all和group by语句的执行过程的分析，我们来回答文章开头的问题：MySQL什么时候会使用内部临时表？</p>
<ol>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer是无序数组，sort_buffer是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union需要用到唯一索引约束， group by还需要用到另外一个字段来存累积计数。</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过今天这篇文章，我重点和你讲了group by的几种实现算法，从中可以总结一些使用的指导原则：</p>
<ol>
<li>如果对group by语句的结果没有排序要求，要在语句后面加 order by null；</li>
<li>尽量让group by过程用上表的索引，确认方法是explain结果里没有Using temporary 和 Using filesort；</li>
<li>如果group by需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大tmp_table_size参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法得到group by的结果。</li>
</ol>
<p>最后，我给你留下一个思考题吧。</p>
<p>文章中图8和图9都是order by null，为什么图8的返回结果里面，0是在结果集的最后一行，而图9的结果里面，0是在结果集的第一行？</p>
<p>你可以把你的分析写在留言区里，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是：为什么不能用rename修改临时表的改名。</p>
<p>在实现上，执行rename table语句的时候，要求按照“库名&#x2F;表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的frm文件是放在tmpdir目录下的，并且文件名的规则是“#sql{进程id}_{线程id}_序列号.frm”，因此会报“找不到文件名”的错误。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@poppy 同学，通过执行语句的报错现象推测了这个实现过程。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>39 | 自增主键为什么不是连续的</title>
    <url>/posts/857d22e5.html</url>
    <content><![CDATA[<p>在<a href="https://time.geekbang.org/column/article/69236">第4篇文章</a>中，我们提到过自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p>
<p>之前我见过有的业务设计依赖于自增主键的连续性，也就是说，这个设计假设自增主键是连续的。但实际上，这样的假设是错的，因为自增主键不能保证连续递增。</p>
<p>今天这篇文章，我们就来说说这个问题，看看什么情况下自增主键会出现 “空洞”？</p>
<span id="more"></span>

<p>为了便于说明，我们创建一个表t，其中id是自增主键字段、c是唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<h1 id="自增值保存在哪儿？"><a href="#自增值保存在哪儿？" class="headerlink" title="自增值保存在哪儿？"></a>自增值保存在哪儿？</h1><p>在这个空表t里面执行insert into t values(null, 1, 1);插入一行数据，再执行show create table命令，就可以看到如下图所示的结果：</p>
<p><img src="https://static001.geekbang.org/resource/image/cb/ff/cb2637cada0201b18650f56875e94fff.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 自动生成的AUTO_INCREMENT值</b>
    </div>
    <br>
</center>

<p>可以看到，表定义里面出现了一个AUTO_INCREMENT&#x3D;2，表示下一次插入数据时，如果需要自动生成自增值，会生成id&#x3D;2。</p>
<p>其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。实际上，<strong>表的结构定义存放在后缀名为.frm的文件中，但是并不会保存自增值。</strong></p>
<p>不同的引擎对于自增值的保存策略不同。</p>
<ul>
<li>MyISAM引擎的自增值保存在数据文件中。</li>
<li>InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：<ul>
<li>在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。﻿<br>举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT&#x3D;11。这时候，我们删除id&#x3D;10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。﻿<br>也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。</li>
<li>在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</li>
</ul>
</li>
</ul>
<p>理解了MySQL对自增值的保存策略以后，我们再看看自增值修改机制。</p>
<h1 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h1><p>在MySQL里面，如果字段id被定义为AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<ol>
<li>如果插入数据时id字段指定为0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT值填到自增字段；</li>
<li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是X，当前的自增值是Y。</p>
<ol>
<li>如果X&lt;Y，那么这个表的自增值不变；</li>
<li>如果X≥Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<p><strong>新的自增值生成算法是</strong>：从auto_increment_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。</p>
<p>其中，auto_increment_offset 和 auto_increment_increment是两个系统参数，分别用来表示自增的初始值和步长，默认值都是1。</p>
<blockquote>
<p>备注：在一些场景下，使用的就不全是默认值。比如，双M的主备结构里要求双写的时候，我们就可能会设置成auto_increment_increment&#x3D;2，让一个库的自增id都是奇数，另一个库的自增id都是偶数，避免两个库生成的主键发生冲突。</p>
</blockquote>
<p>当auto_increment_offset和auto_increment_increment都是1的时候，新的自增值生成逻辑很简单，就是：</p>
<ol>
<li>如果准备插入的值&gt;&#x3D;当前自增值，新的自增值就是“准备插入的值+1”；</li>
<li>否则，自增值不变。</li>
</ol>
<p>这就引入了我们文章开头提到的问题，在这两个参数都设置为1的时候，自增主键id却不能保证是连续的，这是什么原因呢？</p>
<h1 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h1><p>要回答这个问题，我们就要看一下自增值的修改时机。</p>
<p>假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这个语句的执行流程就是：</p>
<ol>
<li>执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);</li>
<li>InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；</li>
<li>将传入的行的值改成(2,1,1);</li>
<li>将表的自增值改成3；</li>
<li>继续执行插入数据操作，由于已经存在c&#x3D;1的记录，所以报Duplicate key error，语句返回。</li>
</ol>
<p>对应的执行流程图如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/f1/d3/f16d89a6e7ad6e2cde13b32bb2292dd3.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 insert(null, 1,1)唯一键冲突</b>
    </div>
    <br>
</center>

<p>可以看到，这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id&#x3D;2这一行并没有插入成功，但也没有将自增值再改回去。</p>
<p>所以，在这之后，再插入新的数据行时，拿到的自增id就是3。也就是说，出现了自增主键不连续的情况。</p>
<p>如图3所示就是完整的演示结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/77/26/77b87820b649692a555f19b562d5d926.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 一个自增主键id不连续的复现步骤</b>
    </div>
    <br>
</center>

<p>可以看到，这个操作序列复现了一个自增主键id不连续的现场(没有id&#x3D;2的行）。可见，<strong>唯一键冲突是导致自增主键id不连续的第一种原因。</strong></p>
<p>同样地，事务<strong>回滚也会产生类似的现象，这就是第二种原因。</strong></p>
<p>下面这个语句序列就可以构造不连续的自增id，你可以自己验证一下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入的行是(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL没有把表t的自增值改回去呢？如果把表t的当前自增值从3改回2，再插入新数据的时候，不就可以生成id&#x3D;2的一行数据了吗？</p>
<p>其实，MySQL这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看<strong>自增值为什么不能回退。</strong></p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请。</p>
<ol>
<li>假设事务A申请到了id&#x3D;2， 事务B申请到id&#x3D;3，那么这时候表t的自增值是4，之后继续执行。</li>
<li>事务B正确提交了，但事务A出现了唯一键冲突。</li>
<li>如果允许事务A把自增id回退，也就是把表t的当前自增值改回2，那么就会出现这样的情况：表里面已经有id&#x3D;3的行，而当前的自增id值是2。</li>
<li>接下来，继续执行的其他事务就会申请到id&#x3D;2，然后再申请到id&#x3D;3。这时，就会出现插入语句报错“主键冲突”。</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请id之前，先判断表里面是否已经存在这个id。如果存在，就跳过这个id。但是，这个方法的成本很高。因为，本来申请id是一个很快的操作，现在还要再去主键索引树上判断id是否存在。</li>
<li>把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ol>
<p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增id回退”的前提导致的。</p>
<p>因此，InnoDB放弃了这个设计，语句执行失败也不回退自增id。也正是因为这样，所以才只保证了自增id是递增的，但不保证是连续的。</p>
<h1 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h1><p>可以看到，自增id锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在MySQL 5.1版本之前，并不是这样的。</p>
<p>接下来，我会先给你介绍下自增锁设计的历史，这样有助于你分析接下来的一个问题。</p>
<p>在MySQL 5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p>
<p>MySQL 5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1。</p>
<ol>
<li>这个参数的值被设置为0时，表示采用之前MySQL 5.0版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为1时：<ul>
<li>普通insert语句，自增锁在申请之后就马上释放；</li>
<li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
<li>这个参数的值被设置为2时，所有的申请自增主键的动作都是申请后就释放锁。</li>
</ol>
<p>你一定有两个疑问：<strong>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是2？</strong></p>
<p>答案是，这么设计还是为了数据的一致性。</p>
<p>我们一起来看一下这个场景：</p>
<p><img src="https://static001.geekbang.org/resource/image/e0/df/e0a69e151277de54a8262657e4ec89df.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 批量插入数据的自增锁</b>
    </div>
    <br>
</center>

<p>在这个例子里，我往表t1中插入了4行数据，然后创建了一个相同结构的表t2，然后两个session同时执行向表t2中插入数据的操作。</p>
<p>你可以设想一下，如果session B是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p>
<ul>
<li>session B先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A来申请自增id得到id&#x3D;3，插入了（3,5,5)；</li>
<li>之后，session B继续执行，插入两条记录(4,3,3)、 (5,4,4)。</li>
</ul>
<p>你可能会说，这也没关系吧，毕竟session B的语义本身就没有要求表t2的所有行的数据都跟session A相同。</p>
<p>是的，从数据逻辑上看是对的。但是，如果我们现在的binlog_format&#x3D;statement，你可以设想下，binlog会怎么记录呢？</p>
<p>由于两个session是同时执行插入数据命令的，所以binlog里面对表t2的更新日志只有两种情况：要么先记session A的，要么先记session B的。</p>
<p>但不论是哪一种，这个binlog拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B这个语句执行出来，生成的结果里面，id都是连续的。这时，这个库就发生了数据不一致。</p>
<p>你可以分析一下，出现这个问题的原因是什么？</p>
<p>其实，这是因为原库session B的insert语句，生成的id不连续。这个不连续的id，用statement格式的binlog来串行执行，是执行不出来的。</p>
<p>而要解决这个问题，有两种思路：</p>
<ol>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的id值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li>
<li>另一种思路是，在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row。</li>
</ol>
<p>因此，<strong>在生产上，尤其是有insert … select这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode&#x3D;2 ，并且 binlog_format&#x3D;row</strong>.这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>需要注意的是，我这里说的<strong>批量插入数据，包含的语句类型是insert … select、replace … select和load data语句。</strong></p>
<p>但是，在普通的insert语句里面包含多个value值的情况下，即使innodb_autoinc_lock_mode设置为1，也不会等语句执行完成才释放锁。因为这类语句在申请自增id的时候，是可以精确计算出需要多少个id的，然后一次性申请，申请完成后锁就可以释放了。</p>
<p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为“不知道要预先申请多少个id”。</p>
<p>既然预先不知道要申请多少个自增id，那么一种直接的想法就是需要一个时申请一个。但如果一个select … insert语句要插入10万行数据，按照这个逻辑的话就要申请10万次。显然，这种申请自增id的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p>
<p>因此，对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：</p>
<ol>
<li>语句执行过程中，第一次申请自增id，会分配1个；</li>
<li>1个用完以后，这个语句第二次申请自增id，会分配2个；</li>
<li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个；</li>
<li>依此类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍。</li>
</ol>
<p>举个例子，我们一起看看下面的这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>insert…select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一次申请到了id&#x3D;1，第二次被分配了id&#x3D;2和id&#x3D;3， 第三次被分配到id&#x3D;4到id&#x3D;7。</p>
<p>由于这条语句实际只用上了4个id，所以id&#x3D;5到id&#x3D;7就被浪费掉了。之后，再执行insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p>
<p><strong>这是主键id出现自增id不连续的第三种原因。</strong></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天，我们从“自增主键为什么会出现不连续的值”这个问题开始，首先讨论了自增值的存储。</p>
<p>在MyISAM引擎里面，自增值是被写在数据文件上的。而在InnoDB中，自增值是被记录在内存的。MySQL直到8.0版本，才给InnoDB表的自增值加上了持久化的能力，确保重启前后一个表的自增值不变。</p>
<p>然后，我和你分享了在一个语句执行过程中，自增值改变的时机，分析了为什么MySQL在事务回滚的时候不能回收自增id。</p>
<p>MySQL 5.1.22版本开始引入的参数innodb_autoinc_lock_mode，控制了自增值申请时的锁范围。从并发性能的角度考虑，我建议你将其设置为2，同时将binlog_format设置为row。我在前面的文章中其实多次提到，binlog_format设置为row，是很有必要的。今天的例子给这个结论多了一个理由。</p>
<p>最后，我给你留一个思考题吧。</p>
<p>在最后一个例子中，执行insert into t2(c,d) select c,d from t;这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format&#x3D;statement。这个语句会对表t的所有记录和间隙加锁。</p>
<p>你觉得为什么需要这么做呢？</p>
<p>你可以把你的思考和分析写在评论区，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，如果你维护的MySQL系统里有内存表，怎么避免内存表突然丢数据，然后导致主备同步停止的情况。</p>
<p>我们假设的是主库暂时不能修改引擎，那么就把备库的内存表引擎先都改成InnoDB。对于每个内存表，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> sql_log_bin<span class="operator">=</span>off;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>

<p>这样就能避免备库重启的时候，数据丢失的问题。</p>
<p>由于主库重启后，会往binlog里面写“delete from tbl_name”，这个命令传到备库，备库的同名的表数据也会被清空。</p>
<p>因此，就不会出现主备同步停止的问题。</p>
<p>如果由于主库异常重启，触发了HA，这时候我们之前修改过引擎的备库变成了主库。而原来的主库变成了新备库，在新备库上把所有的内存表（这时候表里没数据）都改成InnoDB表。</p>
<p>所以，如果我们不能直接修改主库上的表引擎，可以配置一个自动巡检的工具，在备库上发现内存表就把引擎改了。</p>
<p>同时，跟业务开发同学约定好建表规则，避免创建新的内存表。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>大家在春节期间还坚持看专栏，并且深入地思考和回复，给大家点赞。<br>@长杰 同学提到的将数据保存到InnoDB表用来持久化，也是一个方法。不过，我还是建议釜底抽薪，直接修改备库的内存表的引擎。<br>@老杨同志 提到的是主库异常重启的场景，这时候是不会报主备不一致的，因为主库重启的时候写了delete from tbl_name，主备的内存表都清空了。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>40 | insert语句的锁为什么这么多</title>
    <url>/posts/a90aa258.html</url>
    <content><![CDATA[<p>在上一篇文章中，我提到MySQL对自增主键锁做了优化，尽量在申请到自增id以后，就释放自增锁。</p>
<p>因此，insert语句是一个很轻量的操作。不过，这个结论对于“普通的insert语句”才有效。也就是说，还有些insert语句是属于“特殊情况”的，在执行过程中需要给其他资源加锁，或者无法在申请到自增id以后就立马释放自增锁。</p>
<span id="more"></span>

<p>那么，今天这篇文章，我们就一起来聊聊这个话题。</p>
<h1 id="insert-…-select-语句"><a href="#insert-…-select-语句" class="headerlink" title="insert … select 语句"></a>insert … select 语句</h1><p>我们先从昨天的问题说起吧。表t和t2的表结构、初始化数据语句如下，今天的例子我们还是针对这两个表展开。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure>

<p>现在，我们一起来看看为什么在可重复读隔离级别下，binlog_format&#x3D;statement时执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>

<p>这个语句时，需要对表t的所有行和间隙加锁呢？</p>
<p>其实，这个问题我们需要考虑的还是日志和数据的一致性。我们看下这个执行序列：</p>
<p><img src="https://static001.geekbang.org/resource/image/33/86/33e513ee55d5700dc67f32bcdafb9386.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 并发insert场景</b>
    </div>
    <br>
</center>

<p>实际的执行效果是，如果session B先执行，由于这个语句对表t主键索引加了(-∞,1]这个next-key lock，会在语句执行完成后，才允许session A的insert语句执行。</p>
<p>但如果没有锁的话，就可能出现session B的insert语句先执行，但是后写入binlog的情况。于是，在binlog_format&#x3D;statement的情况下，binlog里面就记录了这样的语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>

<p>这个语句到了备库执行，就会把id&#x3D;-1这一行也写到表t2中，出现主备不一致。</p>
<h1 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h1><p>当然了，执行insert … select 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p>
<p>如果现在有这么一个需求：要往表t2中插入一行数据，这一行的c值是表t中c值的最大值加1。</p>
<p>此时，我们可以这么写这条SQL语句 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这个语句的加锁范围，就是表t索引c上的(4,supremum]这个next-key lock和主键索引上id&#x3D;4这一行。</p>
<p>它的执行流程也比较简单，从表t中按照索引c倒序，扫描第一行，拿到结果写入到表t2中。</p>
<p>因此整条语句的扫描行数是1。</p>
<p>这个语句执行的慢查询日志（slow log），如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/3e/74/3efdf8256309a44e23d93089459eda74.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 慢查询日志--将数据插入表t2</b>
    </div>
    <br>
</center>

<p>通过这个慢查询日志，我们看到Rows_examined&#x3D;1，正好验证了执行这条语句的扫描行数为1。</p>
<p>那么，如果我们是要把这样的一行数据插入到表t中的话：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c,d)  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>语句的执行流程是怎样的？扫描行数又是多少呢？</p>
<p>这时候，我们再看慢查询日志就会发现不对了。</p>
<p><img src="https://static001.geekbang.org/resource/image/6f/18/6f90b04c09188bff11dae6e788abb918.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 慢查询日志--将数据插入表t</b>
    </div>
    <br>
</center>

<p>可以看到，这时候的Rows_examined的值是5。</p>
<p>我在前面的文章中提到过，希望你都能够学会用explain的结果来“脑补”整条语句的执行过程。今天，我们就来一起试试。</p>
<p>如图4所示就是这条语句的explain结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/d7/2a/d7270781ee3f216325b73bd53999b82a.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 explain结果</b>
    </div>
    <br>
</center>

<p>从Extra字段可以看到“Using temporary”字样，表示这个语句用到了临时表。也就是说，执行过程中，需要把表t的内容读出来，写入临时表。</p>
<p>图中rows显示的是1，我们不妨先对这个语句的执行流程做一个猜测：如果说是把子查询的结果读出来（扫描1行），写入临时表，然后再从临时表读出来（扫描1行），写回表t中。那么，这个语句的扫描行数就应该是2，而不是5。</p>
<p>所以，这个猜测不对。实际上，Explain结果里的rows&#x3D;1是因为受到了limit 1 的影响。</p>
<p>从另一个角度考虑的话，我们可以看看InnoDB扫描了多少行。如图5所示，是在执行这个语句前后查看Innodb_rows_read的结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/48/d7/489281d8029e8f60979cb7c4494010d7.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 查看 Innodb_rows_read变化</b>
    </div>
    <br>
</center>

<p>可以看到，这个语句执行前后，Innodb_rows_read的值增加了4。因为默认临时表是使用Memory引擎的，所以这4行查的都是表t，也就是说对表t做了全表扫描。</p>
<p>这样，我们就把整个执行过程理清楚了：</p>
<ol>
<li>创建临时表，表里有两个字段c和d。</li>
<li>按照索引c扫描表t，依次取c&#x3D;4、3、2、1，然后回表，读到c和d的值写入临时表。这时，Rows_examined&#x3D;4。</li>
<li>由于语义里面有limit 1，所以只取了临时表的第一行，再插入到表t中。这时，Rows_examined的值加1，变成了5。</li>
</ol>
<p>也就是说，这个语句会导致在表t上做全表扫描，并且会给索引c上的所有间隙都加上共享的next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p>
<p>至于这个语句的执行为什么需要临时表，原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p>
<p>由于实现上这个语句没有在子查询中就直接使用limit 1，从而导致了这个语句的执行需要遍历整个表t。它的优化方法也比较简单，就是用前面介绍的方法，先insert into到临时表temp_t，这样就只需要扫描一行；然后再从表temp_t里面取出这行数据插入表t1。</p>
<p>当然，由于这个语句涉及的数据量很小，你可以考虑使用内存临时表来做这个优化。使用内存临时表优化时，语句序列的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(c <span class="type">int</span>,d <span class="type">int</span>) engine<span class="operator">=</span>memory;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t  (<span class="keyword">select</span> c<span class="operator">+</span><span class="number">1</span>, d <span class="keyword">from</span> t force index(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> limit <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_t;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> temp_t;</span><br></pre></td></tr></table></figure>

<h1 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h1><p>前面的两个例子是使用insert … select的情况，接下来我要介绍的这个例子就是最常见的insert语句出现唯一键冲突的情况。</p>
<p>对于有唯一键的表，插入数据时出现唯一键冲突也是常见的情况了。我先给你举一个简单的唯一键冲突的例子。</p>
<p><img src="https://static001.geekbang.org/resource/image/83/ca/83fb2d877932941b230d6b5be8cca6ca.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 唯一键冲突加锁</b>
    </div>
    <br>
</center>

<p>这个例子也是在可重复读（repeatable read）隔离级别下执行的。可以看到，session B要执行的insert语句进入了锁等待状态。</p>
<p>也就是说，session A执行的insert语句，发生主键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。我们前面说过，一个next-key lock就是由它右边界的值定义的。这时候，session A持有索引c上的(5,10]共享next-key lock（读锁）。</p>
<p>至于为什么要加这个读锁，其实我也没有找到合理的解释。从作用上来看，这样做可以避免这一行被别的事务删掉。</p>
<p>这里<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">官方文档</a>有一个描述错误，认为如果冲突的是主键索引，就加记录锁，唯一索引才加next-key lock。但实际上，这两类索引冲突加的都是next-key lock。</p>
<blockquote>
<p>备注：这个bug，是我在写这篇文章查阅文档时发现的，已经<a href="https://bugs.mysql.com/bug.php?id=93806">发给官方</a>并被verified了。</p>
</blockquote>
<p>有同学在前面文章的评论区问到，在有多个唯一索引的表中并发插入数据时，会出现死锁。但是，由于他没有提供复现方法或者现场，我也无法做分析。所以，我建议你在评论区发问题的时候，尽量同时附上复现方法，或者现场信息，这样我才好和你一起分析问题。</p>
<p>这里，我就先和你分享一个经典的死锁场景，如果你还遇到过其他唯一键冲突导致的死锁场景，也欢迎给我留言。</p>
<p><img src="https://static001.geekbang.org/resource/image/63/2d/63658eb26e7a03b49f123fceed94cd2d.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 唯一键冲突--死锁</b>
    </div>
    <br>
</center>

<p>在session A执行rollback语句回滚的时候，session C几乎同时发现死锁并返回。</p>
<p>这个死锁产生的逻辑是这样的：</p>
<ol>
<li>在T1时刻，启动session A，并执行insert语句，此时在索引c的c&#x3D;5上加了记录锁。注意，这个索引是唯一索引，因此退化为记录锁（如果你的印象模糊了，可以回顾下<a href="https://time.geekbang.org/column/article/75659">第21篇文章</a>介绍的加锁规则）。</li>
<li>在T2时刻，session B要执行相同的insert语句，发现了唯一键冲突，加上读锁；同样地，session C也在索引c上，c&#x3D;5这一个记录上，加了读锁。</li>
<li>T3时刻，session A回滚。这时候，session B和session C都试图继续执行插入操作，都要加上写锁。两个session都要等待对方的行锁，所以就出现了死锁。</li>
</ol>
<p>这个流程的状态变化图如下所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/3e/b8/3e0bf1a1241931c14360e73fd10032b8.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 状态变化图--死锁</b>
    </div>
    <br>
</center>

<h1 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h1><p>上面这个例子是主键冲突后直接报错，如果是改写成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">10</span>,<span class="number">10</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> d<span class="operator">=</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>的话，就会给索引c上(5,10] 加一个排他的next-key lock（写锁）。</p>
<p><strong>insert into … on duplicate key update 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</strong></p>
<p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p>
<p>现在表t里面已经有了(1,1,1)和(2,2,2)这两行，我们再来看看下面这个语句执行的效果：</p>
<p><img src="https://static001.geekbang.org/resource/image/5f/02/5f384d6671c87a60e1ec7e490447d702.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 两个唯一键同时冲突</b>
    </div>
    <br>
</center>

<p>可以看到，主键id是先判断的，MySQL认为这个语句跟id&#x3D;2这一行冲突，所以修改的是id&#x3D;2的行。</p>
<p>需要注意的是，执行这条语句的affected rows返回的是2，很容易造成误解。实际上，真正更新的只有一行，只是在代码实现上，insert和update都认为自己成功了，update计数加了1， insert计数也加了1。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你介绍了几种特殊情况下的insert语句。</p>
<p>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。</p>
<p>而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。</p>
<p>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(S锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p>
<p>最后，我给你留一个问题吧。</p>
<p>你平时在两个表之间拷贝数据用的是什么方法，有什么注意事项吗？在你的应用场景里，这个方法，相较于其他方法的优势是什么呢？</p>
<p>你可以把你的经验和分析写在评论区，我会在下一篇文章的末尾选取有趣的评论来和你一起分析。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我们已经在文章中回答了上期问题。</p>
<p>有同学提到，如果在insert … select 执行期间有其他线程操作原表，会导致逻辑错误。其实，这是不会的，如果不加锁，就是快照读。</p>
<p>一条语句执行期间，它的一致性视图是不会修改的，所以即使有其他事务修改了原表的数据，也不会影响这条语句看到的数据。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>41 | 怎么最快地复制一张表</title>
    <url>/posts/fd323700.html</url>
    <content><![CDATA[<p>我在上一篇文章最后，给你留下的问题是怎么在两张表中拷贝数据。如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用insert … select 语句即可实现。</p>
<p>当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。这时，有两种常用的方法。接下来的内容，我会和你详细展开一下这两种方法。</p>
<span id="more"></span>

<p>为了便于说明，我还是先创建一个表db1.t，并插入1000行数据，同时创建一个相同结构的表db2.t。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database db1;</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a))engine<span class="operator">=</span>innodb;</span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br></pre></td></tr></table></figure>

<p>假设，我们要把db1.t里面a&gt;900的数据行导出来，插入到db2.t中。</p>
<h1 id="mysqldump方法"><a href="#mysqldump方法" class="headerlink" title="mysqldump方法"></a>mysqldump方法</h1><p>一种方法是，使用mysqldump命令将数据导出成一组INSERT语句。你可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="comment">--add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql</span></span><br></pre></td></tr></table></figure>

<p>把结果输出到临时文件。</p>
<p>这条命令中，主要参数含义如下：</p>
<ol>
<li>–single-transaction的作用是，在导出数据的时候不需要对表db1.t加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li>
<li>–add-locks设置为0，表示在输出的文件结果里，不增加” LOCK TABLES <code>t</code> WRITE;” ；</li>
<li>–no-create-info的意思是，不需要导出表结构；</li>
<li>–set-gtid-purged&#x3D;off表示的是，不输出跟GTID相关的信息；</li>
<li>–result-file指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。</li>
</ol>
<p>通过这条mysqldump命令生成的t.sql文件中就包含了如图1所示的INSERT语句。</p>
<p><img src="https://static001.geekbang.org/resource/image/8a/de/8acdcefcaf5c9940570bf7e8f73dbdde.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 mysqldump输出文件的部分结果</b>
    </div>
    <br>
</center>

<p>可以看到，一条INSERT语句里面会包含多个value对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。</p>
<p>如果你希望生成的文件中一条INSERT语句只插入一行数据的话，可以在执行mysqldump命令时，加上参数–skip-extended-insert。</p>
<p>然后，你可以通过下面这条命令，将这些INSERT语句放到db2库里去执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P13000  <span class="operator">-</span>uroot db2 <span class="operator">-</span>e &quot;source /client_tmp/t.sql&quot;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，source并不是一条SQL语句，而是一个客户端命令。mysql客户端执行这个命令的流程是这样的：</p>
<ol>
<li>打开文件，默认以分号为结尾读取一条条的SQL语句；</li>
<li>将SQL语句发送到服务端执行。</li>
</ol>
<p>也就是说，服务端执行的并不是这个“source t.sql”语句，而是INSERT语句。所以，不论是在慢查询日志（slow log），还是在binlog，记录的都是这些要被真正执行的INSERT语句。</p>
<h1 id="导出CSV文件"><a href="#导出CSV文件" class="headerlink" title="导出CSV文件"></a>导出CSV文件</h1><p>另一种方法是直接将结果导出成.csv文件。MySQL提供了下面的语法，用来将查询结果导出到服务端本地目录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.t <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/server_tmp/t.csv&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们在使用这条语句时，需要注意如下几点。</p>
<ol>
<li>这条语句会将结果保存在服务端。如果你执行命令的客户端和MySQL服务端不在同一个机器上，客户端机器的临时目录下是不会生成t.csv文件的。</li>
<li>into outfile指定了文件的生成位置（&#x2F;server_tmp&#x2F;），这个位置必须受参数secure_file_priv的限制。参数secure_file_priv的可选值和作用分别是：<ul>
<li>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</li>
<li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li>
<li>如果设置为NULL，就表示禁止在这个MySQL实例上执行select … into outfile 操作。</li>
</ul>
</li>
<li>这条命令不会帮你覆盖文件，因此你需要确保&#x2F;server_tmp&#x2F;t.csv这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li>
<li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li>
</ol>
<p>得到.csv导出文件后，你就可以用下面的load data命令将数据导入到目标表db2.t中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load data infile <span class="string">&#x27;/server_tmp/t.csv&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></table></figure>

<p>这条语句的执行流程如下所示。</p>
<ol>
<li>打开文件&#x2F;server_tmp&#x2F;t.csv，以制表符(\t)作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；</li>
<li>启动事务。</li>
<li>判断每一行的字段数与表db2.t是否相同：<ul>
<li>若不相同，则直接报错，事务回滚；</li>
<li>若相同，则构造成一行，调用InnoDB引擎接口，写入到表中。</li>
</ul>
</li>
<li>重复步骤3，直到&#x2F;server_tmp&#x2F;t.csv整个文件读入完成，提交事务。</li>
</ol>
<p>你可能有一个疑问，<strong>如果binlog_format&#x3D;statement，这个load语句记录到binlog里以后，怎么在备库重放呢？</strong></p>
<p>由于&#x2F;server_tmp&#x2F;t.csv文件只保存在主库所在的主机上，如果只是把这条语句原文写到binlog中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。</p>
<p>所以，这条语句执行的完整流程，其实是下面这样的。</p>
<ol>
<li>主库执行完成后，将&#x2F;server_tmp&#x2F;t.csv文件的内容直接写到binlog文件中。</li>
<li>往binlog文件中写入语句load data local infile ‘&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li>
<li>把这个binlog日志传到备库。</li>
<li>备库的apply线程在执行这个事务日志时：<br>a. 先将binlog中t.csv文件的内容读出来，写入到本地临时目录&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0 中；<br>b. 再执行load data语句，往备库的db2.t表中插入跟主库相同的数据。</li>
</ol>
<p>执行流程如图2所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/3a/fd/3a6790bc933af5ac45a75deba0f52cfd.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 load data的同步流程</b>
    </div>
    <br>
</center>

<p>注意，这里备库执行的load data语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件&#x2F;tmp&#x2F;SQL_LOAD_MB-1-0的内容，加载到目标表db2.t中”。</p>
<p>也就是说，<strong>load data命令有两种用法</strong>：</p>
<ol>
<li>不加“local”，是读取服务端的文件，这个文件必须在secure_file_priv指定的目录或子目录下；</li>
<li>加上“local”，读取的是客户端的文件，只要mysql客户端有访问这个文件的权限即可。这时候，MySQL客户端会先把本地文件传给服务端，然后执行上述的load data流程。</li>
</ol>
<p>另外需要注意的是，<strong>select …into outfile方法不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump提供了一个–tab参数，可以同时导出表结构定义文件和csv数据文件。这条命令的使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="comment">---single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --tab=$secure_file_priv</span></span><br></pre></td></tr></table></figure>

<p>这条命令会在$secure_file_priv定义的目录下，创建一个t.sql文件保存建表语句，同时创建一个t.txt文件保存CSV数据。</p>
<h1 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h1><p>前面我们提到的mysqldump方法和导出CSV文件的方法，都是逻辑导数据的方法，也就是将数据从表db1.t中读出来，生成文本，然后再写入目标表db2.t中。</p>
<p>你可能会问，有物理导数据的方法吗？比如，直接把db1.t表的.frm文件和.ibd文件拷贝到db2目录下，是否可行呢？</p>
<p>答案是不行的。</p>
<p>因为，一个InnoDB表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有db2.t这个表，系统是不会识别和接受它们的。</p>
<p>不过，在MySQL 5.6版本引入了<strong>可传输表空间</strong>(transportable tablespace)的方法，可以通过导出+导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设我们现在的目标是在db1库下，复制一个跟表t相同的表r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行alter table r discard tablespace，这时候r.ibd文件会被删除；</li>
<li>执行flush table t for export，这时候db1目录下会生成一个t.cfg文件；</li>
<li>在db1目录下执行cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li>
<li>执行unlock tables，这时候t.cfg文件会被删除；</li>
<li>执行alter table r import tablespace，将这个r.ibd文件作为表r的新的表空间，由于这个文件的数据内容和t.ibd是相同的，所以表r中就有了和表t相同的数据。</li>
</ol>
<p>至此，拷贝表数据的操作就完成了。这个流程的执行过程图如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/24/05/2407737651cdc1f5d6ade4d8907e7c05.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 物理拷贝表</b>
    </div>
    <br>
</center>

<p>关于拷贝表的这个流程，有以下几个注意点：</p>
<ol>
<li>在第3步执行完flsuh table命令之后，db1.t整个表处于只读状态，直到执行unlock tables命令后才释放读锁；</li>
<li>在执行import tablespace的时候，为了让文件里的表空间id和数据字典中的一致，会修改t.ibd的表空间id。而这个表空间id存在于每一个数据页中。因此，如果是一个很大的文件（比如TB级别），每个数据页都需要修改，所以你会看到这个import语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import语句的耗时是非常短的。</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你介绍了三种将一个表的数据导入到另外一个表中的方法。</p>
<p>我们来对比一下这三种方法的优缺点。</p>
<ol>
<li>物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：<ul>
<li>必须是全表拷贝，不能只拷贝部分数据；</li>
<li>需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；</li>
<li>由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。</li>
</ul>
</li>
<li>用mysqldump生成包含INSERT语句文件的方法，可以在where参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用join这种比较复杂的where条件写法。</li>
<li>用select … into outfile的方法是最灵活的，支持所有的SQL写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。</li>
</ol>
<p>后两种方式都是逻辑备份方式，是可以跨引擎使用的。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>我们前面介绍binlog_format&#x3D;statement的时候，binlog记录的load data命令是带local的。既然这条命令是发送到备库去执行的，那么备库执行的时候也是本地执行，为什么需要这个local呢？如果写到binlog中的命令不带local，又会出现什么问题呢？</p>
<p>你可以把你的分析写在评论区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>我在上篇文章最后给你留下的思考题，已经在今天这篇文章的正文部分做了回答。</p>
<p>上篇文章的评论区有几个非常好的留言，我在这里和你分享一下。</p>
<p>@huolang 同学提了一个问题：如果sessionA拿到c&#x3D;5的记录锁是写锁，那为什么sessionB和sessionC还能加c&#x3D;5的读锁呢？</p>
<p>这是因为next-key lock是先加间隙锁，再加记录锁的。加间隙锁成功了，加记录锁就会被堵住。如果你对这个过程有疑问的话，可以再复习一下<a href="https://time.geekbang.org/column/article/78427">第30篇文章</a>中的相关内容。</p>
<p>@一大只 同学做了一个实验，验证了主键冲突以后，insert语句加间隙锁的效果。比我在上篇文章正文中提的那个回滚导致死锁的例子更直观，体现了他对这个知识点非常好的理解和思考，很赞。</p>
<p>@roaming 同学验证了在MySQL 8.0版本中，已经能够用临时表处理insert … select写入原表的语句了。</p>
<p>@老杨同志 的回答提到了我们本文中说到的几个方法。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>42 | grant之后要跟着flushprivileges吗</title>
    <url>/posts/43e37da1.html</url>
    <content><![CDATA[<p>在MySQL里面，grant语句是用来给用户赋权的。不知道你有没有见过一些操作文档里面提到，grant之后要马上跟着执行一个flush privileges命令，才能使赋权语句生效。我最开始使用MySQL的时候，就是照着一个操作文档的说明按照这个顺序操作的。</p>
<p>那么，grant之后真的需要执行flush privileges吗？如果没有执行这个flush命令的话，赋权语句真的不能生效吗？</p>
<span id="more"></span>

<p>接下来，我就先和你介绍一下grant语句和flush privileges语句分别做了什么事情，然后再一起来分析这个问题。</p>
<p>为了便于说明，我先创建一个用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;pa&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是pa。注意，在MySQL里面，用户名(user)+地址(host)才表示一个用户，因此 ua@ip1 和 ua@ip2代表的是两个不同的用户。</p>
<p>这条命令做了两个动作：</p>
<ol>
<li>磁盘上，往mysql.user表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是N；</li>
<li>内存里，往数组acl_users里插入一个acl_user对象，这个对象的access字段值为0。</li>
</ol>
<p>图1就是这个时刻用户ua在user表中的状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/7e/35/7e75bbfbca0cb932e1256941c99d5f35.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 mysql.user 数据行</b>
    </div>
    <br>
</center>

<p>在MySQL中，用户权限是有不同的范围的。接下来，我就按照用户权限范围从大到小的顺序依次和你说明。</p>
<h1 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h1><p>全局权限，作用于整个MySQL实例，这些权限信息保存在mysql库的user表里。如果我要给用户ua赋一个最高权限的话，语句是这么写的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure>

<p>这个grant命令做了两个动作：</p>
<ol>
<li>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</li>
<li>内存里，从数组acl_users中找到这个用户对应的对象，将access值（权限位）修改为二进制的“全1”。</li>
</ol>
<p>在这个grant命令执行完成后，如果有新的客户端使用用户名ua登录成功，MySQL会为新连接维护一个线程对象，然后从acl_users数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。</p>
<p>基于上面的分析我们可以知道：</p>
<ol>
<li>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。</li>
<li>对于一个已经存在的连接，它的全局权限不受grant命令的影响。</li>
</ol>
<p>需要说明的是，<strong>一般在生产环境上要合理控制用户权限的范围</strong>。我们上面用到的这个grant语句就是一个典型的错误示范。如果一个用户有所有权限，一般就不应该设置为所有IP地址都可以访问。</p>
<p>如果要回收上面的grant语句赋予的权限，你可以使用下面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这条revoke命令的用法与grant类似，做了如下两个动作：</p>
<ol>
<li>磁盘上，将mysql.user表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为“N”；</li>
<li>内存里，从数组acl_users中找到这个用户对应的对象，将access的值修改为0。</li>
</ol>
<h1 id="db权限"><a href="#db权限" class="headerlink" title="db权限"></a>db权限</h1><p>除了全局权限，MySQL也支持库级别的权限定义。如果要让用户ua拥有库db1的所有权限，可以执行下面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure>

<p>基于库的权限记录保存在mysql.db表中，在内存里则保存在数组acl_dbs中。这条grant命令做了如下两个动作：</p>
<ol>
<li>磁盘上，往mysql.db表中插入了一行记录，所有权限位字段设置为“Y”；</li>
<li>内存里，增加一个对象到数组acl_dbs中，这个对象的权限位为“全1”。</li>
</ol>
<p>图2就是这个时刻用户ua在db表中的状态。</p>
<p><img src="https://static001.geekbang.org/resource/image/32/2e/32cd61ee14ad2f370e1de0fb4e39bb2e.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 mysql.db 数据行</b>
    </div>
    <br>
</center>

<p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次acl_dbs数组，根据user、host和db找到匹配的对象，然后根据对象的权限位来判断。</p>
<p>也就是说，grant修改db权限的时候，是同时对磁盘和内存生效的。</p>
<p>grant操作对于已经存在的连接的影响，在全局权限和基于db的权限效果是不同的。接下来，我们做一个对照试验来分别看一下。</p>
<p><img src="https://static001.geekbang.org/resource/image/ae/c7/aea26807c8895961b666a5d96b081ac7.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 权限操作效果</b>
    </div>
    <br>
</center>

<p>需要说明的是，图中set global sync_binlog这个操作是需要super权限的。</p>
<p>可以看到，虽然用户ua的super权限在T3时刻已经通过revoke语句回收了，但是在T4时刻执行set global的时候，权限验证还是通过了。这是因为super是全局权限，这个权限信息在线程对象中，而revoke操作影响不到这个线程对象。</p>
<p>而在T5时刻去掉ua对db1库的所有权限后，在T6时刻session B再操作db1库的表，就会报错“权限不足”。这是因为acl_dbs是一个全局数组，所有线程判断db权限都用这个数组，这样revoke操作马上就会影响到session B。</p>
<p>这里在代码实现上有一个特别的逻辑，如果当前会话已经处于某一个db里面，之前use这个库的时候拿到的库权限会保存在会话变量中。</p>
<p>你可以看到在T6时刻，session C和session B对表t的操作逻辑是一样的。但是session B报错，而session C可以执行成功。这是因为session C在T2 时刻执行的use db1，拿到了这个库的权限，在切换出db1库之前，session C对这个库就一直有权限。</p>
<h1 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h1><p>除了db级别的权限外，MySQL支持更细粒度的表权限和列权限。其中，表权限定义存放在表mysql.tables_priv中，列权限定义存放在表mysql.columns_priv中。这两类权限，组合起来存放在内存的hash结构column_priv_hash中。</p>
<p>这两类权限的赋权命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db1.t1(id <span class="type">int</span>, a <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.t1 <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>(id), <span class="keyword">INSERT</span> (id,a) <span class="keyword">ON</span> mydb.mytbl <span class="keyword">TO</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure>

<p>跟db权限类似，这两个权限每次grant的时候都会修改数据表，也会同步修改内存中的hash结构。因此，对这两类权限的操作，也会马上影响到已经存在的连接。</p>
<p>看到这里，你一定会问，看来grant语句都是即时生效的，那这么看应该就不需要执行flush privileges语句了呀。</p>
<p>答案也确实是这样的。</p>
<p>flush privileges命令会清空acl_users数组，然后从mysql.user表中读取数据重新加载，重新构造一个acl_users数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p>
<p>同样地，对于db权限、表权限和列权限，MySQL也做了这样的处理。</p>
<p>也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行flush privileges。而如果我们都是用grant&#x2F;revoke语句来执行的话，内存和数据表本来就是保持同步更新的。</p>
<p><strong>因此，正常情况下，grant命令之后，没有必要跟着执行flush privileges命令。</strong></p>
<h1 id="flush-privileges使用场景"><a href="#flush-privileges使用场景" class="headerlink" title="flush privileges使用场景"></a>flush privileges使用场景</h1><p>那么，flush privileges是在什么时候使用呢？显然，当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges语句可以用来重建内存数据，达到一致状态。</p>
<p>这种不一致往往是由不规范的操作导致的，比如直接用DML语句操作系统权限表。我们来看一下下面这个场景：</p>
<p><img src="https://static001.geekbang.org/resource/image/90/ec/9031814361be42b7bc084ad2ab2aa3ec.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 使用flush privileges</b>
    </div>
    <br>
</center>

<p>可以看到，T3时刻虽然已经用delete语句删除了用户ua，但是在T4时刻，仍然可以用ua连接成功。原因就是，这时候内存中acl_users数组中还有这个用户，因此系统判断时认为用户还正常存在。</p>
<p>在T5时刻执行过flush命令后，内存更新，T6时刻再要用ua来登录的话，就会报错“无法访问”了。</p>
<p>直接操作系统表是不规范的操作，这个不一致状态也会导致一些更“诡异”的现象发生。比如，前面这个通过delete语句删除用户的例子，就会出现下面的情况：</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/f1/dd625b6b4eb2dcbdaac73648a1af50f1.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 不规范权限操作导致的异常</b>
    </div>
    <br>
</center>

<p>可以看到，由于在T3时刻直接删除了数据表的记录，而内存的数据还存在。这就导致了：</p>
<ol>
<li>T4时刻给用户ua赋权限失败，因为mysql.user表中找不到这行记录；</li>
<li>而T5时刻要重新创建这个用户也不行，因为在做内存判断的时候，会认为这个用户还存在。</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你介绍了MySQL用户权限在数据表和内存中的存在形式，以及grant和revoke命令的执行逻辑。</p>
<p>grant语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用grant和revoke语句，是不需要随后加上flush privileges语句的。</p>
<p>flush privileges语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p>
<p>另外，在使用grant语句赋权时，你可能还会看到这样的写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> super <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ua&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;pa&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这条命令加了identified by ‘密码’， 语句的逻辑里面除了赋权外，还包含了：</p>
<ol>
<li>如果用户’ua’@’%’不存在，就创建这个用户，密码是pa；</li>
<li>如果用户ua已经存在，就将密码修改成pa。</li>
</ol>
<p>这也是一种不建议的写法，因为这种写法很容易就会不慎把密码给改了。</p>
<p>“grant之后随手加flush privileges”，我自己是这么使用了两三年之后，在看代码的时候才发现其实并不需要这样做，那已经是2011年的事情了。</p>
<p>去年我看到一位小伙伴这么操作的时候，指出这个问题时，他也觉得很神奇。因为，他和我一样看的第一份文档就是这么写的，自己也一直是这么用的。</p>
<p>所以，今天的课后问题是，请你也来说一说，在使用数据库或者写代码的过程中，有没有遇到过类似的场景：误用了很长时间以后，由于一个契机发现“啊，原来我错了这么久”？</p>
<p>你可以把你的经历写在留言区，我会在下一篇文章的末尾选取有趣的评论和你分享。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，MySQL解析statement格式的binlog的时候，对于load data命令，解析出来为什么用的是load data local。</p>
<p>这样做的一个原因是，为了确保备库应用binlog正常。因为备库可能配置了secure_file_priv&#x3D;null，所以如果不用local的话，可能会导入失败，造成主备同步延迟。</p>
<p>另一种应用场景是使用mysqlbinlog工具解析binlog文件，并应用到目标库的情况。你可以使用下面这条命令 ：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="variable">$binlog_file</span> | mysql <span class="literal">-h</span><span class="variable">$host</span> <span class="literal">-P</span><span class="variable">$port</span> <span class="literal">-u</span><span class="variable">$user</span> <span class="literal">-p</span><span class="variable">$pwd</span></span><br></pre></td></tr></table></figure>

<p>把日志直接解析出来发给目标库执行。增加local，就能让这个方法支持非本地的$host。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@poppy 、@库淘淘 两位同学提到了第一个场景；<br>@王显伟 @lionetes 两位同学帮忙回答了 @undifined 同学的疑问，拷贝出来的文件要确保MySQL进程可以读。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>36 | 为什么临时表可以重名</title>
    <url>/posts/f4790cb.html</url>
    <content><![CDATA[<p>在上一篇文章中，我们在优化join查询的时候使用到了临时表。当时，我们是这么用的：</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t1;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp_t <span class="keyword">add</span> index(b);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></table></figure>

<p>你可能会有疑问，为什么要用临时表呢？直接用普通表是不是也可以呢？</p>
<p>今天我们就从这个问题说起：临时表有哪些特征，为什么它适合这个场景？</p>
<p>这里，我需要先帮你厘清一个容易误解的问题：有的人可能会认为，临时表就是内存表。但是，这两个概念可是完全不同的。</p>
<ul>
<li>内存表，指的是使用Memory引擎的表，建表语法是create table … engine&#x3D;memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li>
<li>而临时表，可以使用各种引擎类型 。如果是使用InnoDB引擎或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用Memory引擎。</li>
</ul>
<p>弄清楚了内存表和临时表的区别以后，我们再来看看临时表有哪些特征。</p>
<h1 id="临时表的特性"><a href="#临时表的特性" class="headerlink" title="临时表的特性"></a>临时表的特性</h1><p>为了便于理解，我们来看下下面这个操作序列：</p>
<p><img src="https://static001.geekbang.org/resource/image/3c/e3/3cbb2843ef9a84ee582330fb1bd0d6e3.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 临时表特性示例</b>
    </div>
    <br>
</center>

<p>可以看到，临时表在使用上有以下几个特点：</p>
<ol>
<li>建表语法是create temporary table …。</li>
<li>一个临时表只能被创建它的session访问，对其他线程不可见。所以，图中session A创建的临时表t，对于session B就是不可见的。</li>
<li>临时表可以与普通表同名。</li>
<li>session A内有同名的临时表和普通表的时候，show create语句，以及增删改查语句访问的是临时表。</li>
<li>show tables命令不显示临时表。</li>
</ol>
<p>由于临时表只能被创建它的session访问，所以在这个session结束的时候，会自动删除临时表。也正是由于这个特性，<strong>临时表就特别适合我们文章开头的join优化这种场景</strong>。为什么呢？</p>
<p>原因主要包括以下两个方面：</p>
<ol>
<li>不同session的临时表是可以重名的，如果有多个session同时执行join优化，不需要担心表名重复导致建表失败的问题。</li>
<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li>
</ol>
<h1 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h1><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p>
<p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表ht，按照字段f，拆分成1024个分表，然后分布到32个数据库实例上。如下图所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/81/ddb9c43526dfd9b9a3e6f8c153478181.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 分库分表简图</b>
    </div>
    <br>
</center>

<p>一般情况下，这种分库分表系统都有一个中间层proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有proxy这一层。</p>
<p>在这个架构中，分区key的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含f的等值条件，那么就要用f做分区键。这样，在proxy这一层解析完SQL语句以后，就能确定将这条语句路由到哪个分表做查询。</p>
<p>比如下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v <span class="keyword">from</span> ht <span class="keyword">where</span> f<span class="operator">=</span>N;</span><br></pre></td></tr></table></figure>

<p>这时，我们就可以通过分表规则（比如，N%1024)来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。</p>
<p>但是，如果这个表上还有另外一个索引k，并且查询语句是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v <span class="keyword">from</span> ht <span class="keyword">where</span> k <span class="operator">&gt;=</span> M <span class="keyword">order</span> <span class="keyword">by</span> t_modified <span class="keyword">desc</span> limit <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这时候，由于查询条件里面没有用到分区字段f，只能到所有的分区中去查找满足条件的所有行，然后统一做order by 的操作。这种情况下，有两种比较常用的思路。</p>
<p><strong>第一种思路是，</strong> 在proxy层的进程代码中实现排序。</p>
<p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p>
<ol>
<li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如group by，甚至join这样的操作，对中间层的开发能力要求比较高；</li>
<li>对proxy端的压力比较大，尤其是很容易出现内存不够用和CPU瓶颈的问题。</li>
</ol>
<p><strong>另一种思路就是，</strong> 把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作。</p>
<p>比如上面这条语句，执行流程可以类似这样：</p>
<ul>
<li>在汇总库上创建一个临时表temp_ht，表里包含三个字段v、k、t_modified；</li>
<li>在各个分库上执行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v,k,t_modified <span class="keyword">from</span> ht_x <span class="keyword">where</span> k <span class="operator">&gt;=</span> M <span class="keyword">order</span> <span class="keyword">by</span> t_modified <span class="keyword">desc</span> limit <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>把分库执行的结果插入到temp_ht表中；</li>
<li>执行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v <span class="keyword">from</span> temp_ht <span class="keyword">order</span> <span class="keyword">by</span> t_modified <span class="keyword">desc</span> limit <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>得到结果。</p>
<p>这个过程对应的流程图如下所示：</p>
<p><img src="https://static001.geekbang.org/resource/image/f5/0d/f5ebe0f5af37deeb4d0b63d6fb11fc0d.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 跨库查询流程示意图</b>
    </div>
    <br>
</center>

<p><strong>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表temp_ht放到32个分库中的某一个上。</strong> 这时的查询逻辑与图3类似，你可以自己再思考一下具体的流程。</p>
<h1 id="为什么临时表可以重名？"><a href="#为什么临时表可以重名？" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h1><p>你可能会问，不同线程可以创建同名的临时表，这是怎么做到的呢？</p>
<p>接下来，我们就看一下这个问题。</p>
<p>我们在执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>

<p>这个语句的时候，MySQL要给这个InnoDB表创建一个frm文件保存表结构定义，还要有地方保存表数据。</p>
<p><strong>这个frm文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程id}_{线程id}_序列号”</strong>。你可以使用select @@tmpdir命令，来显示实例的临时文件目录。</p>
<p>而关于表中数据的存放方式，在不同的MySQL版本中有着不同的处理方式：</p>
<ul>
<li>在5.6以及之前的版本里，MySQL会在临时文件目录下创建一个相同前缀、以.ibd为后缀的文件，用来存放数据文件；</li>
<li>而从 5.7版本开始，MySQL引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建ibd文件了。</li>
</ul>
<p>从文件名的前缀规则，我们可以看到，其实创建一个叫作t1的InnoDB临时表，MySQL在存储上认为我们创建的表名跟普通表t1是不同的，因此同一个库下面已经有普通表t1的情况下，还是可以再创建一个临时表t1的。</p>
<p>为了便于后面讨论，我先来举一个例子。</p>
<p><img src="https://static001.geekbang.org/resource/image/22/1b/22078eab5c7688c9fbfd6185555bd91b.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 临时表的表名</b>
    </div>
    <br>
</center>

<p>这个进程的进程号是1234，session A的线程id是4，session B的线程id是5。所以你看到了，session A和session B创建的临时表，在磁盘上的文件不会重名。</p>
<p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。</p>
<ul>
<li>一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。</li>
<li>而对于临时表，table_def_key在“库名+表名”基础上，又加入了“server_id+thread_id”。</li>
</ul>
<p>也就是说，session A和sessionB创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。</p>
<p>在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p>
<p>这时候你会发现，binlog中也记录了DROP TEMPORARY TABLE这条命令。你一定会觉得奇怪，临时表只在线程内自己可以访问，为什么需要写到binlog里面？</p>
<p>这，就需要说到主备复制了。</p>
<h1 id="临时表和主备复制"><a href="#临时表和主备复制" class="headerlink" title="临时表和主备复制"></a>临时表和主备复制</h1><p>既然写binlog，就意味着备库需要。</p>
<p>你可以设想一下，在主库上执行下面这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_normal(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>)engine<span class="operator">=</span>innodb;<span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t <span class="keyword">like</span> t_normal;<span class="comment">/*Q2*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_normal <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_t;<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure>

<p>如果关于临时表的操作都不记录，那么在备库就只有create table t_normal表和insert into t_normal select * from temp_t这两个语句的binlog日志，备库在执行到insert into t_normal的时候，就会报错“表temp_t不存在”。</p>
<p>你可能会说，如果把binlog设置为row格式就好了吧？因为binlog是row格式时，在记录insert into t_normal的binlog时，记录的是这个操作的数据，即：write_row event里面记录的逻辑是“插入一行数据（1,1)”。</p>
<p>确实是这样。如果当前的binlog_format&#x3D;row，那么跟临时表有关的语句，就不会记录到binlog里。也就是说，只在binlog_format&#x3D;statment&#x2F;mixed 的时候，binlog中才会记录临时表的操作。</p>
<p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个DROP TEMPORARY TABLE传给备库执行。</p>
<p><strong>之前有人问过我一个有趣的问题：</strong>MySQL在记录binlog的时候，不论是create table还是alter table语句，都是原样记录，甚至于连空格都不变。但是如果执行drop table t_normal，系统记录binlog就会写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `t_normal` <span class="comment">/* generated by server */</span></span><br></pre></td></tr></table></figure>

<p>也就是改成了标准的格式。为什么要这么做呢 ？</p>
<p>现在你知道原因了，那就是：drop table命令是可以一次删除多个表的。比如，在上面的例子中，设置binlog_format&#x3D;row，如果主库上执行 “drop table t_normal, temp_t”这个命令，那么binlog中就只能记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `t_normal` <span class="comment">/* generated by server */</span></span><br></pre></td></tr></table></figure>

<p>因为备库上并没有表temp_t，将这个命令重写后再传到备库执行，才不会导致备库同步线程停止。</p>
<p>所以，drop table命令记录binlog的时候，就必须对语句做改写。“&#x2F;* generated by server *&#x2F;”说明了这是一个被服务端改写过的命令。</p>
<p>说到主备复制，<strong>还有另外一个问题需要解决</strong>：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？</p>
<p>现在，我给你举个例子，下面的序列中实例S是M的备库。</p>
<p><img src="https://static001.geekbang.org/resource/image/74/ba/74e789024f10bcde515f21c0368847ba.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 主备关系中的临时表操作</b>
    </div>
    <br>
</center>

<p>主库M上的两个session创建了同名的临时表t1，这两个create temporary table t1 语句都会被传到备库S上。</p>
<p>但是，备库的应用日志线程是共用的，也就是说要在应用线程里面先后执行这个create 语句两次。（即使开了多线程复制，也可能被分配到从库的同一个worker中执行）。那么，这会不会导致同步线程报错 ？</p>
<p>显然是不会的，否则临时表就是一个bug了。也就是说，备库线程在执行的时候，要把这两个t1表当做两个不同的临时表来处理。这，又是怎么实现的呢？</p>
<p>MySQL在记录binlog的时候，会把主库执行这个语句的线程id写到binlog中。这样，在备库的应用线程就能够知道执行每个语句的主库线程id，并利用这个线程id来构造临时表的table_def_key：</p>
<ol>
<li>session A的临时表t1，在备库的table_def_key就是：库名+t1+“M的serverid”+“session A的thread_id”;</li>
<li>session B的临时表t1，在备库的table_def_key就是 ：库名+t1+“M的serverid”+“session B的thread_id”。</li>
</ol>
<p>由于table_def_key不同，所以这两个表在备库的应用线程里面是不会冲突的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇文章，我和你介绍了临时表的用法和特性。</p>
<p>在实际应用中，临时表一般用于处理比较复杂的计算逻辑。由于临时表是每个线程自己可见的，所以不需要考虑多个线程执行同一个处理逻辑时，临时表的重名问题。在线程退出的时候，临时表也能自动删除，省去了收尾和异常处理的工作。</p>
<p>在binlog_format&#x3D;’row’的时候，临时表的操作不记录到binlog中，也省去了不少麻烦，这也可以成为你选择binlog_format时的一个考虑因素。</p>
<p>需要注意的是，我们上面说到的这种临时表，是用户自己创建的 ，也可以称为用户临时表。与它相对应的，就是内部临时表，在<a href="https://time.geekbang.org/column/article/73795">第17篇文章</a>中我已经和你介绍过。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>下面的语句序列是创建一个临时表，并将其改名：</p>
<p><img src="https://static001.geekbang.org/resource/image/33/f9/333ad95b2ce16de1931fe347128caff9.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 关于临时表改名的思考题</b>
    </div>
    <br>
</center>

<p>可以看到，我们可以使用alter table语法修改临时表的表名，而不能使用rename语法。你知道这是什么原因吗？</p>
<p>你可以把你的分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，对于下面这个三个表的join语句，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span>(t1.a<span class="operator">=</span>t2.a) <span class="keyword">join</span> t3 <span class="keyword">on</span> (t2.b<span class="operator">=</span>t3.b) <span class="keyword">where</span> t1.c<span class="operator">&gt;=</span>X <span class="keyword">and</span> t2.c<span class="operator">&gt;=</span>Y <span class="keyword">and</span> t3.c<span class="operator">&gt;=</span>Z;</span><br></pre></td></tr></table></figure>

<p>如果改写成straight_join，要怎么指定连接顺序，以及怎么给三个表创建索引。</p>
<p>第一原则是要尽量使用BKA算法。需要注意的是，使用BKA算法的时候，并不是“先计算两个表join的结果，再跟第三个表join”，而是直接嵌套查询的。</p>
<p>具体实现是：在t1.c&gt;&#x3D;X、t2.c&gt;&#x3D;Y、t3.c&gt;&#x3D;Z这三个条件里，选择一个经过过滤以后，数据最少的那个表，作为第一个驱动表。此时，可能会出现如下两种情况。</p>
<p>第一种情况，如果选出来是表t1或者t3，那剩下的部分就固定了。</p>
<ol>
<li>如果驱动表是t1，则连接顺序是t1-&gt;t2-&gt;t3，要在被驱动表字段创建上索引，也就是t2.a 和 t3.b上创建索引；</li>
<li>如果驱动表是t3，则连接顺序是t3-&gt;t2-&gt;t1，需要在t2.b 和 t1.a上创建索引。</li>
</ol>
<p>同时，我们还需要在第一个驱动表的字段c上创建索引。</p>
<p>第二种情况是，如果选出来的第一个驱动表是表t2的话，则需要评估另外两个条件的过滤效果。</p>
<p>总之，整体的思路就是，尽量让每一次参与join的驱动表的数据集，越小越好，因为这样我们的驱动表就会越小。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@库淘淘 做了实验验证；<br>@poppy同学做了很不错的分析；<br>@dzkk 同学在评论中介绍了MariaDB支持的hash join，大家可以了解一下；<br>@老杨同志提了一个好问题，如果语句使用了索引a，结果还要对a排序，就不用MRR优化了，否则回表完还要增加额外的排序过程，得不偿失。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>43 | 要不要使用分区表</title>
    <url>/posts/d2414150.html</url>
    <content><![CDATA[<p>我经常被问到这样一个问题：分区表有什么问题，为什么公司规范不让使用分区表呢？今天，我们就来聊聊分区表的使用行为，然后再一起回答这个问题。</p>
<span id="more"></span>

<h1 id="分区表是什么？"><a href="#分区表是什么？" class="headerlink" title="分区表是什么？"></a>分区表是什么？</h1><p>为了说明分区表的组织形式，我先创建一个表t：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">&#x27;2017-4-1&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;2018-4-1&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/06/f5/06f041129783533de9c75580f9decdf5.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 表t的磁盘文件</b>
    </div>
    <br>
</center>

<p>我在表t中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在p_2018和p_2019这两个分区上。</p>
<p>可以看到，这个表包含了一个.frm文件和4个.ibd文件，每个分区对应一个.ibd文件。也就是说：</p>
<ul>
<li>对于引擎层来说，这是4个表；</li>
<li>对于Server层来说，这是1个表。</li>
</ul>
<p>你可能会觉得这两句都是废话。其实不然，这两句话非常重要，可以帮我们理解分区表的执行逻辑。</p>
<h1 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h1><p>我先给你举个在分区表加间隙锁的例子，目的是说明对于InnoDB来说，这是4个表。</p>
<p><img src="https://static001.geekbang.org/resource/image/d2/c7/d28d6ab873bd8337d88812d45b9266c7.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 分区表间隙锁示例</b>
    </div>
    <br>
</center>

<p>这里顺便复习一下，我在<a href="https://time.geekbang.org/column/article/75659">第21篇文章</a>和你介绍的间隙锁加锁规则。</p>
<p>我们初始化表t的时候，只插入了两行数据， ftime的值分别是，‘2017-4-1’ 和’2018-4-1’ 。session A的select语句对索引ftime上这两个记录之间的间隙加了锁。如果是一个普通表的话，那么T1时刻，在表t的ftime索引上，间隙和加锁状态应该是图3这样的。</p>
<p><img src="https://static001.geekbang.org/resource/image/27/d2/273c9ca869f5b52621641d73eb6f72d2.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 普通表的加锁范围</b>
    </div>
    <br>
</center>

<p>也就是说，‘2017-4-1’ 和’2018-4-1’ 这两个记录之间的间隙是会被锁住的。那么，sesion B的两条插入语句应该都要进入锁等待状态。</p>
<p>但是，从上面的实验效果可以看出，session B的第一个insert语句是可以执行成功的。这是因为，对于引擎来说，p_2018和p_2019是两个不同的表，也就是说2017-4-1的下一个记录并不是2018-4-1，而是p_2018分区的supremum。所以T1时刻，在表t的ftime索引上，间隙和加锁的状态其实是图4这样的：</p>
<p><img src="https://static001.geekbang.org/resource/image/92/5c/92f63aba0b24adefac7316c75463b95c.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 分区表t的加锁范围</b>
    </div>
    <br>
</center>

<p>由于分区表的规则，session A的select语句其实只操作了分区p_2018，因此加锁范围就是图4中深绿色的部分。</p>
<p>所以，session B要写入一行ftime是2018-2-1的时候是可以成功的，而要写入2017-12-1这个记录，就要等session A的间隙锁。</p>
<p>图5就是这时候的show engine innodb status的部分结果。</p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 session B被锁住信息</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/e3/0f/e3d83d9ba89de9a6f541c9a2f24a3b0f.png"></p>
<p>看完InnoDB引擎的例子，我们再来一个MyISAM分区表的例子。</p>
<p>我首先用alter table t engine&#x3D;myisam，把表t改成MyISAM表；然后，我再用下面这个例子说明，对于MyISAM引擎来说，这是4个表。</p>
<p><img src="https://static001.geekbang.org/resource/image/94/76/941306d4a7193455dcf1cfebf7678876.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 用MyISAM表锁验证</b>
    </div>
    <br>
</center>

<p>在session A里面，我用sleep(100)将这条语句的执行时间设置为100秒。由于MyISAM引擎只支持表锁，所以这条update语句会锁住整个表t上的读。</p>
<p>但我们看到的结果是，session B的第一条查询语句是可以正常执行的，第二条语句才进入锁等待状态。</p>
<p>这正是因为MyISAM的表锁是在引擎层实现的，session A加的表锁，其实是锁在分区p_2018上。因此，只会堵住在这个分区上执行的查询，落到其他分区的查询是不受影响的。</p>
<p>看到这里，你可能会说，分区表看来还不错嘛，为什么不让用呢？我们使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式。</p>
<p>接下来，我们一起看看手动分表和分区表有什么区别。</p>
<p>比如，按照年份来划分，我们就分别创建普通表t_2017、t_2018、t_2019等等。手工分表的逻辑，也是找到需要更新的所有分表，然后依次执行更新。在性能上，这和分区表并没有实质的差别。</p>
<p>分区表和手工分表，一个是由server层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。</p>
<p>其实这两个方案的区别，主要是在server层上。从server层看，我们就不得不提到分区表一个被广为诟病的问题：打开表的行为。</p>
<h1 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h1><p>每当第一次访问一个分区表的时候，MySQL需要把所有的分区都访问一遍。<strong>一个典型的报错情况</strong>是这样的：如果一个分区表的分区很多，比如超过了1000个，而MySQL启动的时候，open_files_limit参数使用的是默认值1024，那么就会在访问这个表的时候，由于需要打开所有的文件，导致打开表文件的个数超过了上限而报错。</p>
<p>下图就是我创建的一个包含了很多分区的表t_myisam，执行一条插入语句后报错的情况。</p>
<p><img src="https://static001.geekbang.org/resource/image/ab/e7/abfa0054ec43d97fb18ba3c1c8829ae7.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图 7 insert 语句报错</b>
    </div>
    <br>
</center>

<p>可以看到，这条insert语句，明显只需要访问一个分区，但语句却无法执行。</p>
<p>这时，你一定从表名猜到了，这个表我用的是MyISAM引擎。是的，因为使用InnoDB引擎的话，并不会出现这个问题。</p>
<p>MyISAM分区表使用的分区策略，我们称为<strong>通用分区策略</strong>（generic partitioning），每次访问分区都由server层控制。通用分区策略，是MySQL一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。</p>
<p>从MySQL 5.7.9开始，InnoDB引擎引入了<strong>本地分区策略</strong>（native partitioning）。这个策略是在InnoDB内部自己管理打开分区的行为。</p>
<p>MySQL从5.7.17开始，将MyISAM分区表标记为即将弃用(deprecated)，意思是“从这个版本开始不建议这么使用，请使用替代方案。在将来的版本中会废弃这个功能”。</p>
<p>从MySQL 8.0版本开始，就不允许创建MyISAM分区表了，只允许创建已经实现了本地分区策略的引擎。目前来看，只有InnoDB和NDB这两个引擎支持了本地分区策略。</p>
<p>接下来，我们再看一下分区表在server层的行为。</p>
<h1 id="分区表的server层行为"><a href="#分区表的server层行为" class="headerlink" title="分区表的server层行为"></a>分区表的server层行为</h1><p>如果从server层看的话，一个分区表就只是一个表。</p>
<p>这句话是什么意思呢？接下来，我就用下面这个例子来和你说明。如图8和图9所示，分别是这个例子的操作序列和执行结果图。</p>
<p><img src="https://static001.geekbang.org/resource/image/0e/81/0eca5a3190161e59ea58493915bd5e81.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图8 分区表的MDL锁</b>
    </div>
    <br>
</center>

<p><img src="https://static001.geekbang.org/resource/image/af/a8/afe662f5e051a2ceb96a87624a589aa8.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图9 show processlist结果</b>
    </div>
    <br>
</center>

<p>可以看到，虽然session B只需要操作p_2107这个分区，但是由于session A持有整个表t的MDL锁，就导致了session B的alter语句被堵住。</p>
<p>这也是DBA同学经常说的，分区表，在做DDL的时候，影响会更大。如果你使用的是普通分表，那么当你在truncate一个分表的时候，肯定不会跟另外一个分表上的查询语句，出现MDL锁冲突。</p>
<p>到这里我们小结一下：</p>
<ol>
<li>MySQL在第一次打开分区表的时候，需要访问所有的分区；</li>
<li>在server层，认为这是同一张表，因此所有分区共用同一个MDL锁；</li>
<li>在引擎层，认为这是不同的表，因此MDL锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li>
</ol>
<p>而关于“必要的分区”的判断，就是根据SQL语句中的where条件，结合分区规则来实现的。比如我们上面的例子中，where ftime&#x3D;‘2018-4-1’，根据分区规则year函数算出来的值是2018，那么就会落在p_2019这个分区。</p>
<p>但是，如果这个where 条件改成 where ftime&gt;&#x3D;‘2018-4-1’，虽然查询结果相同，但是这时候根据where条件，就要访问p_2019和p_others这两个分区。</p>
<p>如果查询语句的where条件中没有分区key，那就只能访问所有分区了。当然，这并不是分区表的问题。即使是使用业务分表的方式，where条件中没有使用分表的key，也必须访问所有的分表。</p>
<p>我们已经理解了分区表的概念，那么什么场景下适合使用分区表呢？</p>
<h1 id="分区表的应用场景"><a href="#分区表的应用场景" class="headerlink" title="分区表的应用场景"></a>分区表的应用场景</h1><p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。</p>
<p>如果一项业务跑的时间足够长，往往就会有根据时间删除历史数据的需求。这时候，按照时间分区的分区表，就可以直接通过alter table t drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p>
<p>这个alter table t drop partition …操作是直接删除分区文件，效果跟drop普通表类似。与使用delete语句删除数据相比，优势是速度快、对系统影响小。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章，我主要和你介绍的是server层和引擎层对分区表的处理方式。我希望通过这些介绍，你能够对是否选择使用分区表，有更清晰的想法。</p>
<p>需要注意的是，我是以范围分区（range）为例和你介绍的。实际上，MySQL还支持hash分区、list分区等分区方法。你可以在需要用到的时候，再翻翻<a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html">手册</a>。</p>
<p>实际使用时，分区表跟用户分表比起来，有两个绕不开的问题：一个是第一次访问的时候需要访问所有分区，另一个是共用MDL锁。</p>
<p>因此，如果要使用分区表，就不要创建太多的分区。我见过一个用户做了按天分区策略，然后预先创建了10年的分区。这种情况下，访问分区表的性能自然是不好的。这里有两个问题需要注意：</p>
<ol>
<li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li>
<li>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的12个新分区创建上即可。对于没有数据的历史分区，要及时的drop掉。</li>
</ol>
<p>至于分区表的其他问题，比如查询需要跨多个分区取数据，查询性能就会比较慢，基本上就不是分区表本身的问题，而是数据量的问题或者说是使用方式的问题了。</p>
<p>当然，如果你的团队已经维护了成熟的分库分表中间件，用业务分表，对业务开发同学没有额外的复杂性，对DBA也更直观，自然是更好的。</p>
<p>最后，我给你留下一个思考题吧。</p>
<p>我们举例的表中没有用到自增主键，假设现在要创建一个自增字段id。MySQL要求分区表中的主键必须包含分区字段。如果要在表t的基础上做修改，你会怎么定义这个表的主键呢？为什么这么定义呢？</p>
<p>你可以把你的结论和分析写在留言区，我会在下一篇文章的末尾和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上篇文章后面还不够多，可能很多同学还没来记得看吧，我们就等后续有更多留言的时候，再补充本期的“上期问题时间”吧。</p>
<p>@夹心面包 提到了在grant的时候是支持通配符的：”_”表示一个任意字符，“%”表示任意字符串。这个技巧在一个分库分表方案里面，同一个分库上有多个db的时候，是挺方便的。不过我个人认为，权限赋值的时候，控制的精确性还是要优先考虑的。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>44 | 答疑文章（三）：说一说这些好问题</title>
    <url>/posts/b872f9f9.html</url>
    <content><![CDATA[<p>在我看来，能够帮我们扩展一个逻辑的边界的问题，就是好问题。因为通过解决这样的问题，能够加深我们对这个逻辑的理解，或者帮我们关联到另外一个知识点，进而可以帮助我们建立起自己的知识网络。</p>
<span id="more"></span>

<p>在工作中会问好问题，是一个很重要的能力。</p>
<p>经过这段时间的学习，从评论区的问题我可以感觉出来，紧跟课程学习的同学，对SQL语句执行性能的感觉越来越好了，提出的问题也越来越细致和精准了。</p>
<p>接下来，我们就一起看看同学们在评论区提到的这些好问题。在和你一起分析这些问题的时候，我会指出它们具体是在哪篇文章出现的。同时，在回答这些问题的过程中，我会假设你已经掌握了这篇文章涉及的知识。当然，如果你印象模糊了，也可以跳回文章再复习一次。</p>
<h1 id="join的写法"><a href="#join的写法" class="headerlink" title="join的写法"></a>join的写法</h1><p>在第35篇文章<a href="https://time.geekbang.org/column/article/80147">《join语句怎么优化？》</a>中，我在介绍join执行顺序的时候，用的都是straight_join。@郭健 同学在文后提出了两个问题：</p>
<ol>
<li>如果用left join的话，左边的表一定是驱动表吗？</li>
<li>如果两个表的join包含多个条件的等值匹配，是都要写到on里面呢，还是只把一个条件写到on里面，其他条件写到where部分？</li>
</ol>
<p>为了同时回答这两个问题，我来构造两个表a和b：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(f1 <span class="type">int</span>, f2 <span class="type">int</span>, index(f1))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> b(f1 <span class="type">int</span>, f2 <span class="type">int</span>)engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> a <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> b <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>表a和b都有两个字段f1和f2，不同的是表a的字段f1上有索引。然后，我往两个表中都插入了6条记录，其中在表a和b中同时存在的数据有4行。</p>
<p>@郭健 同学提到的第二个问题，其实就是下面这两种写法的区别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">and</span> (a.f2<span class="operator">=</span>b.f2); <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">where</span> (a.f2<span class="operator">=</span>b.f2);<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>

<p>我把这两条语句分别记为Q1和Q2。</p>
<p>首先，需要说明的是，这两个left join语句的语义逻辑并不相同。我们先来看一下它们的执行结果。</p>
<p><img src="https://static001.geekbang.org/resource/image/87/bd/871f890532349781fdc4a4287e9f91bd.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图1 两个join的查询结果</b>
    </div>
    <br>
</center>

<p>可以看到：</p>
<ul>
<li>语句Q1返回的数据集是6行，表a中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表b的各个字段值填成NULL。</li>
<li>语句Q2返回的是4行。从逻辑上可以这么理解，最后的两行，由于表b中没有匹配的字段，结果集里面b.f2的值是空，不满足where 部分的条件判断，因此不能作为结果集的一部分。</li>
</ul>
<p>接下来，我们看看实际执行这两条语句时，MySQL是怎么做的。</p>
<p>我们先一起看看语句Q1的explain结果：</p>
<p><img src="https://static001.geekbang.org/resource/image/b7/17/b7f27917ceb0be90ef7b201f2794c817.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图2 Q1的explain结果</b>
    </div>
    <br>
</center>

<p>可以看到，这个结果符合我们的预期：</p>
<ul>
<li>驱动表是表a，被驱动表是表b；</li>
<li>由于表b的f1字段上没有索引，所以使用的是Block Nexted Loop Join（简称BNL） 算法。</li>
</ul>
<p>看到BNL算法，你就应该知道这条语句的执行流程其实是这样的：</p>
<ol>
<li>把表a的内容读入join_buffer 中。因为是select * ，所以字段f1和f2都被放入join_buffer了。</li>
<li>顺序扫描表b，对于每一行数据，判断join条件（也就是a.f1&#x3D;b.f1 and a.f2&#x3D;b.f2)是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有where子句，需要先判断where部分满足条件后，再返回。</li>
<li>表b扫描完成后，对于没有被匹配的表a的行（在这个例子中就是(1,1)、(2,2)这两行），把剩余字段补上NULL，再放入结果集中。</li>
</ol>
<p>对应的流程图如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/8f/d7/8fd4b4b179fb84caaecece84b6406ad7.jpg"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图3 left join -BNL算法</b>
    </div>
    <br>
</center>

<p>可以看到，这条语句确实是以表a为驱动表，而且从执行效果看，也和使用straight_join是一样的。</p>
<p>你可能会想，语句Q2的查询结果里面少了最后两行数据，是不是就是把上面流程中的步骤3去掉呢？我们还是先看一下语句Q2的expain结果吧。</p>
<p><img src="https://static001.geekbang.org/resource/image/f5/9c/f5712c56dc84d331990409a5c313ea9c.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图4 Q2的explain结果</b>
    </div>
    <br>
</center>

<p>这里先和你说一句题外话，专栏马上就结束了，我也和你一起根据explain结果“脑补”了很多次一条语句的执行流程了，所以我希望你已经具备了这个能力。今天，我们再一起分析一次SQL语句的explain结果。</p>
<p>可以看到，这条语句是以表b为驱动表的。而如果一条join语句的Extra字段什么都没写的话，就表示使用的是Index Nested-Loop Join（简称NLJ）算法。</p>
<p>因此，语句Q2的执行流程是这样的：顺序扫描表b，每一行用b.f1到表a中去查，匹配到记录后判断a.f2&#x3D;b.f2是否满足，满足条件的话就作为结果集的一部分返回。</p>
<p>那么，<strong>为什么语句Q1和Q2这两个查询的执行流程会差距这么大呢？</strong> 其实，这是因为优化器基于Q2这个查询的语义做了优化。</p>
<p>为了理解这个问题，我需要再和你交代一个背景知识点：在MySQL里，NULL跟任何值执行等值判断和不等值判断的结果，都是NULL。这里包括， select NULL &#x3D; NULL 的结果，也是返回NULL。</p>
<p>因此，语句Q2里面where a.f2&#x3D;b.f2就表示，查询结果里面不会包含b.f2是NULL的行，这样这个left join的语义就是“找到这两个表里面，f1、f2对应相同的行。对于表a中存在，而表b中匹配不到的行，就放弃”。</p>
<p>这样，这条语句虽然用的是left join，但是语义跟join是一致的。</p>
<p>因此，优化器就把这条语句的left join改写成了join，然后因为表a的f1上有索引，就把表b作为驱动表，这样就可以用上NLJ 算法。在执行explain之后，你再执行show warnings，就能看到这个改写的结果，如图5所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/d7/ab/d74878e7469edb8b713a18c6158530ab.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图5 Q2的改写结果</b>
    </div>
    <br>
</center>

<p>这个例子说明，即使我们在SQL语句中写成left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用left join时，左边的表不一定是驱动表。</strong></p>
<p>这样看来，<strong>如果需要left join的语义，就不能把被驱动表的字段放在where条件里面做等值判断或不等值判断，必须都写在on里面。</strong>那如果是join语句呢？</p>
<p>这时候，我们再看看这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">and</span> (a.f2<span class="operator">=</span>b.f2); <span class="comment">/*Q3*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">on</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">where</span> (a.f2<span class="operator">=</span>b.f2);<span class="comment">/*Q4*/</span></span><br></pre></td></tr></table></figure>

<p>我们再使用一次看explain 和 show warnings的方法，看看优化器是怎么做的。</p>
<p><img src="https://static001.geekbang.org/resource/image/d9/f5/d9952e4c2150bc649c7f2977e6ea80f5.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图6 join语句改写</b>
    </div>
    <br>
</center>

<p>可以看到，这两条语句都被改写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">join</span> b <span class="keyword">where</span> (a.f1<span class="operator">=</span>b.f1) <span class="keyword">and</span> (a.f2<span class="operator">=</span>b.f2);</span><br></pre></td></tr></table></figure>

<p>执行计划自然也是一模一样的。</p>
<p>也就是说，在这种情况下，join将判断条件是否全部放在on部分就没有区别了。</p>
<h1 id="Simple-Nested-Loop-Join-的性能问题"><a href="#Simple-Nested-Loop-Join-的性能问题" class="headerlink" title="Simple Nested Loop Join 的性能问题"></a>Simple Nested Loop Join 的性能问题</h1><p>我们知道，join语句使用不同的算法，对语句的性能影响会很大。在第34篇文章<a href="https://time.geekbang.org/column/article/79700">《到底可不可以使用join？》</a>的评论区中，@书策稠浊 和 @朝夕心 两位同学提了一个很不错的问题。</p>
<p>我们在文中说到，虽然BNL算法和Simple Nested Loop Join 算法都是要判断M*N次（M和N分别是join的两个表的行数），但是Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上BNL算法执行起来会快很多。</p>
<p>为了便于说明，我还是先为你简单描述一下这两个算法。</p>
<p>BNL算法的执行逻辑是：</p>
<ol>
<li>首先，将驱动表的数据全部读入内存join_buffer中，这里join_buffer是无序数组；</li>
<li>然后，顺序遍历被驱动表的所有行，每一行数据都跟join_buffer中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li>
</ol>
<p>Simple Nested Loop Join算法的执行逻辑是：顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p>
<p>这两位同学的疑问是，Simple Nested Loop Join算法，其实也是把数据读到内存里，然后按照匹配条件进行判断，为什么性能差距会这么大呢？</p>
<p>解释这个问题，需要用到MySQL中索引结构和Buffer Pool的相关知识点：</p>
<ol>
<li>在对被驱动表做全表扫描的时候，如果数据没有在Buffer Pool中，就需要等待这部分数据从磁盘读入；<br>从磁盘读入数据到内存中，会影响正常业务的Buffer Pool命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到Buffer Pool的头部（请参考<a href="https://time.geekbang.org/column/article/80147">第35篇文章</a>中的相关内容)；</li>
<li>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而join_buffer中是数组，遍历的成本更低。</li>
</ol>
<p>所以说，BNL算法的性能会更好。</p>
<h1 id="distinct-和-group-by的性能"><a href="#distinct-和-group-by的性能" class="headerlink" title="distinct 和 group by的性能"></a>distinct 和 group by的性能</h1><p>在第37篇文章<a href="https://time.geekbang.org/column/article/80477">《什么时候会使用内部临时表？》</a>中，@老杨同志 提了一个好问题：如果只需要去重，不需要执行聚合函数，distinct 和group by哪种效率高一些呢？</p>
<p>我来展开一下他的问题：如果表t的字段a上没有索引，那么下面这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure>

<p>的性能是不是相同的?</p>
<p>首先需要说明的是，这种group by的写法，并不是SQL标准的写法。标准的group by语句，是需要在select部分加一个聚合函数，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句的逻辑是：按照字段a分组，计算每组的a出现的次数。在这个结果里，由于做的是聚合计算，相同的a只出现一次。</p>
<blockquote>
<p>备注：这里你可以顺便复习一下<a href="https://time.geekbang.org/column/article/80477">第37篇文章</a>中关于group by的相关内容。</p>
</blockquote>
<p>没有了count(*)以后，也就是不再需要执行“计算总数”的逻辑时，第一条语句的逻辑就变成是：按照字段a做分组，相同的a的值只返回一行。而这就是distinct的语义，所以不需要执行聚合函数时，distinct 和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。</p>
<p>这两条语句的执行流程是下面这样的。</p>
<ol>
<li>创建一个临时表，临时表有一个字段a，并且在这个字段a上创建一个唯一索引；</li>
<li>遍历表t，依次取数据插入临时表中：<ul>
<li>如果发现唯一键冲突，就跳过；</li>
<li>否则插入成功；</li>
</ul>
</li>
<li>遍历完成后，将临时表作为结果集返回给客户端。</li>
</ol>
<h1 id="备库自增主键问题"><a href="#备库自增主键问题" class="headerlink" title="备库自增主键问题"></a>备库自增主键问题</h1><p>除了性能问题，大家对细节的追问也很到位。在第39篇文章<a href="https://time.geekbang.org/column/article/80531">《自增主键为什么不是连续的？》</a>评论区，@帽子掉了 同学问到：在binlog_format&#x3D;statement时，语句A先获取id&#x3D;1，然后语句B获取id&#x3D;2；接着语句B提交，写binlog，然后语句A再写binlog。这时候，如果binlog重放，是不是会发生语句B的id为1，而语句A的id为2的不一致情况呢？</p>
<p>首先，这个问题默认了“自增id的生成顺序，和binlog的写入顺序可能是不同的”，这个理解是正确的。</p>
<p>其次，这个问题限定在statement格式下，也是对的。因为row格式的binlog就没有这个问题了，Write row event里面直接写了每一行的所有字段的值。</p>
<p>而至于为什么不会发生不一致的情况，我们来看一下下面的这个例子。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://static001.geekbang.org/resource/image/b5/25/b55b2167aa301d899ccc86a00b496b25.png"></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: # 999;padding: 2px;">
        <b>图7 insert 语句的binlog</b>
    </div>
    <br>
</center>

<p>可以看到，在insert语句之前，还有一句SET INSERT_ID&#x3D;1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用1这个值。</p>
<p>这个SET INSERT_ID语句是固定跟在insert语句之前的，比如@帽子掉了同学提到的场景，主库上语句A的id是1，语句B的id是2，但是写入binlog的顺序先B后A，那么binlog就变成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> INSERT_ID<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">语句B；</span><br><span class="line"><span class="keyword">SET</span> INSERT_ID<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">语句A；</span><br></pre></td></tr></table></figure>

<p>你看，在备库上语句B用到的INSERT_ID依然是2，跟主库相同。</p>
<p>因此，即使两个INSERT语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>今天这篇答疑文章，我选了4个好问题和你分享，并做了分析。在我看来，能够提出好问题，首先表示这些同学理解了我们文章的内容，进而又做了深入思考。有你们在认真的阅读和思考，对我来说是鼓励，也是动力。</p>
<p>说实话，短短的三篇答疑文章无法全部展开同学们在评论区留下的高质量问题，之后有的同学还会二刷，也会有新的同学加入，大家想到新的问题就请给我留言吧，我会继续关注评论区，和你在评论区交流。</p>
<p>老规矩，答疑文章也是要有课后思考题的。</p>
<p>在<a href="https://time.geekbang.org/column/article/70562">第8篇文章</a>的评论区， @XD同学提到一个问题：他查看了一下innodb_trx，发现这个事务的trx_id是一个很大的数（281479535353408），而且似乎在同一个session中启动的会话得到的trx_id是保持不变的。当执行任何加写锁的语句后，trx_id都会变成一个很小的数字（118378）。</p>
<p>你可以通过实验验证一下，然后分析看看，事务id的分配规则是什么，以及MySQL为什么要这么设计呢？</p>
<p>你可以把你的结论和分析写在留言区，我会在下一篇文章和你讨论这个问题。感谢你的收听，也欢迎你把这篇文章分享给更多的朋友一起阅读。</p>
<h1 id="上期问题时间"><a href="#上期问题时间" class="headerlink" title="上期问题时间"></a>上期问题时间</h1><p>上期的问题是，怎么给分区表t创建自增主键。由于MySQL要求主键包含所有的分区字段，所以肯定是要创建联合主键的。</p>
<p>这时候就有两种可选：一种是(ftime, id)，另一种是(id, ftime)。</p>
<p>如果从利用率上来看，应该使用(ftime, id)这种模式。因为用ftime做分区key，说明大多数语句都是包含ftime的，使用这种模式，可以利用前缀索引的规则，减少一个索引。</p>
<p>这时的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ftime`,`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> MyISAM,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> MyISAM);</span><br></pre></td></tr></table></figure>

<p>当然，我的建议是你要尽量使用InnoDB引擎。InnoDB表要求至少有一个索引，以自增字段作为第一个字段，所以需要加一个id的单独索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ftime`,`id`),</span><br><span class="line">  KEY `id` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br></pre></td></tr></table></figure>

<p>当然把字段反过来，创建成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`,`ftime`),</span><br><span class="line">  KEY `id` (`ftime`)</span><br></pre></td></tr></table></figure>

<p>也是可以的。</p>
<p>评论区留言点赞板：</p>
<blockquote>
<p>@夹心面包 、@郭江伟 同学提到了最后一种方案。</p>
</blockquote>
<blockquote>
<p>@aliang 同学提了一个好问题，关于open_files_limit和innodb_open_files的关系，我在回复中做了说明，大家可以看一下。</p>
</blockquote>
<blockquote>
<p>@万勇 提了一个好问题，实际上对于现在官方的版本，将字段加在中间还是最后，在性能上是没差别的。但是，我建议大家养成习惯（如果你是DBA就帮业务开发同学养成习惯），将字段加在最后面，因为这样还是比较方便操作的。这个问题，我也在评论的答复中做了说明，你可以看一下。</p>
</blockquote>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 网站 DNS 被污染解决方法</title>
    <url>/posts/e029a9b3.html</url>
    <content><![CDATA[<p>报错 <code>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</code></p>
<span id="more"></span>

<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>参考：<br><a href="https://bbs.huaweicloud.com/blogs/143682">https://bbs.huaweicloud.com/blogs/143682</a><br>很多方法都没用，这个解决了问题。希望对你有用。</p>
<p>原因：由于某些你懂的因素，导致GitHub的<code>raw.githubusercontent.com</code>域名解析被污染了。</p>
<p>解决方法：通过修改hosts解决此问题。</p>
<h2 id="查询真实IP"><a href="#查询真实IP" class="headerlink" title="查询真实IP"></a>查询真实IP</h2><p>在<code>https://www.ipaddress.com/</code>查询<code>raw.githubusercontent.com</code>的真实IP。<br><img src="http://cdn.qmzbe.top/images/blog/2144266394.png" alt="image"><br>修改hosts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">199.232.68.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure>

<p>重新执行命令即可，但是下载会比较慢。</p>
<p>最后提一嘴，电脑连上你的手机热点有可能会有奇效。</p>
<p>原文链接：<a href="https://blog.csdn.net/sscc_learning/article/details/105574354">https://blog.csdn.net/sscc_learning/article/details/105574354</a></p>
<h2 id="github-com无法访问"><a href="#github-com无法访问" class="headerlink" title="github.com无法访问"></a>github.com无法访问</h2><p>也是在<code>https://www.ipaddress.com/</code>查询<code>github.com</code>的真实IP。</p>
<h2 id="mac和windows系统的hosts位置"><a href="#mac和windows系统的hosts位置" class="headerlink" title="mac和windows系统的hosts位置"></a>mac和windows系统的hosts位置</h2><p>mac系统:&#x2F;etc&#x2F;hosts<br>win: C:\Windows\System32\drivers\etc\HOSTS<br>windows系统设置完要刷新一下dns，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure>

<h2 id="Hosts自动刷新工具-SwitchHosts"><a href="#Hosts自动刷新工具-SwitchHosts" class="headerlink" title="Hosts自动刷新工具 SwitchHosts"></a>Hosts自动刷新工具 SwitchHosts</h2><p>SwitchHosts 是一个管理、切换多个 hosts 方案的工具。<br>它是一个免费开源软件。</p>
<p><img src="http://cdn.qmzbe.top/images/blog/SwitchHosts.png"></p>
<p>网站：<a href="https://swh.app/zh/">https://swh.app/zh/</a></p>
<h2 id="查询-GitHub-最新-Hosts"><a href="#查询-GitHub-最新-Hosts" class="headerlink" title="查询 GitHub 最新 Hosts"></a>查询 GitHub 最新 Hosts</h2><p><a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></p>
<h2 id="dev-sidecar"><a href="#dev-sidecar" class="headerlink" title="dev-sidecar"></a>dev-sidecar</h2><p><a href="https://gitee.com/docmirror/dev-sidecar">https://gitee.com/docmirror/dev-sidecar</a><br>开发者边车，命名取自service-mesh的service-sidecar，意为为开发者打辅助的边车工具<br>通过本地代理的方式将https请求代理到一些国内的加速通道上</p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Halo</title>
    <url>/posts/88d26380.html</url>
    <content><![CDATA[<h2 id="Hello-Halo"><a href="#Hello-Halo" class="headerlink" title="Hello Halo"></a>Hello Halo</h2><p>如果你看到了这一篇文章，那么证明你已经安装成功了，感谢使用 <a href="https://halo.run/">Halo</a> 进行创作，希望能够使用愉快。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>官网：<a href="https://halo.run/">https://halo.run</a></li>
<li>文档：<a href="https://docs.halo.run/">https://docs.halo.run</a></li>
<li>社区：<a href="https://bbs.halo.run/">https://bbs.halo.run</a></li>
<li>主题仓库：<a href="https://halo.run/themes.html">https://halo.run/themes.html</a></li>
<li>开源地址：<a href="https://github.com/halo-dev/halo">https://github.com/halo-dev/halo</a></li>
</ul>
<p>在使用过程中，有任何问题都可以通过以上链接找寻答案，或者联系我们。</p>
<blockquote>
<p>这是一篇自动生成的文章，请删除这篇文章之后开始你的创作吧！</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>Halo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 主题 Shoka &amp; multi-markdown-it 渲染器使用说明</title>
    <url>/posts/4377897e.html</url>
    <content><![CDATA[<blockquote>
<p><a href="/4377897e.html">🚀快速开始</a> - <a href="/3d4c8438.html">💌依赖插件</a> - <a href="/e61f91f5.html">📌基本配置</a> - <a href="/59273b39.html">🌈界面显示</a> - <a href="/833e67b8.html">🦄特殊功能</a></p>
</blockquote>
<h1 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h1><p>在博客根目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>打开主题目录，内有 <code>example</code> 文件夹，提供了配置文件的 demo 供参考。</p>
<h1 id="安装依赖插件"><a href="#安装依赖插件" class="headerlink" title="安装依赖插件"></a>安装依赖插件</h1><p>在应用主题之前，必须至少安装 <a href="https://github.com/amehime/hexo-renderer-multi-markdown-it" title="hexo-renderer-multi-markdown-it">hexo-renderer-multi-markdown-it</a> 渲染插件和 <a href="https://www.npmjs.com/package/hexo-autoprefixer" title="hexo-autoprefixer">hexo-autoprefixer</a>。</p>
<p><a href="/4377897e.html">插件安装与配置教程戳此</a></p>
<h1 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h1><h2 id="修改站点配置"><a href="#修改站点配置" class="headerlink" title="修改站点配置"></a>修改站点配置</h2><p>修改站点配置文件 <code>&lt;root&gt;/_config.yml</code> ，把主题改为 <code>shoka</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: shoka</span><br></pre></td></tr></table></figure>

<h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><p>主题配置的所有参数在 <code>&lt;root&gt;/themes/shoka/_config.yml</code> 文件中。</p>
<p>为了方便主题升级，请在根目录新建一个 yml 文件，命名为 <code>_config.shoka.yml</code> 。<br>也就是说，所有主题的自定义配置均保存于 <code>&lt;root&gt;/_config.shoka.yml</code> 文件。</p>
<p><a href="/e61f91f5.html">主题的基础配置可以参考这里</a><br><a href="/59273b39.html">界面显示相关的配置参考这里</a></p>
<p>本文作者： <a href="https://shoka.lostyu.me/">優萌初華</a><br>原文链接：<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/">传送门</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Shoka</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客主题整理，绝对精品~</title>
    <url>/posts/cee822cc.html</url>
    <content><![CDATA[<h2 id="Hexo-官方主题链接"><a href="#Hexo-官方主题链接" class="headerlink" title="Hexo 官方主题链接"></a>Hexo 官方主题链接</h2><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<h2 id="筛选主题链接"><a href="#筛选主题链接" class="headerlink" title="筛选主题链接"></a>筛选主题链接</h2><p><a href="https://github.com/ppoffice/hexo-theme-minos">https://github.com/ppoffice/hexo-theme-minos</a><br><a href="https://github.com/dusign/hexo-theme-snail">https://github.com/dusign/hexo-theme-snail</a><br><a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a><br><a href="https://github.com/renbaoshuo/hexo-theme-pure">https://github.com/renbaoshuo/hexo-theme-pure</a><br><a href="https://github.com/chaooo/hexo-theme-BlueLake[%E7%A7%8B%E8%BF%87%E5%86%AC%E6%BC%AB%E9%95%BF](https://chaoo.oschina.io/)">https://github.com/chaooo/hexo-theme-BlueLake[秋过冬漫长](https://chaoo.oschina.io/)</a><br><a href="https://github.com/iTimeTraveler/hexo-theme-hipaper">https://github.com/iTimeTraveler/hexo-theme-hipaper</a><br><a href="https://github.com/wujun234/hexo-theme-tree">https://github.com/wujun234/hexo-theme-tree</a><br><a href="https://github.com/zthxxx/hexo-theme-Wikitten">https://github.com/zthxxx/hexo-theme-Wikitten</a><br><a href="https://github.com/KevinOfNeu/hexo-theme-xoxo">https://github.com/KevinOfNeu/hexo-theme-xoxo</a> <a href="https://blog.0xff000000.com/">叫兽</a><br><a href="https://github.com/jangdelong/hexo-theme-xups[Jelon](https://jelon.info)">https://github.com/jangdelong/hexo-theme-xups[Jelon](https://jelon.info)</a><br><a href="https://github.com/iTimeTraveler/hexo-theme-hiero">https://github.com/iTimeTraveler/hexo-theme-hiero</a><br><a href="https://github.com/Vevlins/hexo-theme-toki">https://github.com/Vevlins/hexo-theme-toki</a><br><a href="https://github.com/mango-tree/hexo-theme-mango">https://github.com/mango-tree/hexo-theme-mango</a><br><a href="https://github.com/Bulandent/hexo-theme-bubuzou">https://github.com/Bulandent/hexo-theme-bubuzou</a><br><a href="https://github.com/XPoet/hexo-theme-keep">https://github.com/XPoet/hexo-theme-keep</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客通用设置</title>
    <url>/posts/75d8272f.html</url>
    <content><![CDATA[<p>这里是 Hexo 博客通用设置的一些技巧。</p>
<span id="more"></span>

<h2 id="hexo-d后-Custom-domain-被置空"><a href="#hexo-d后-Custom-domain-被置空" class="headerlink" title="hexo d后 Custom domain 被置空"></a><code>hexo d</code>后 Custom domain 被置空</h2><p>Hexo 博客部署在 GitHub 上，当手动填写了 Custom domain 后，在下一次 hexo d 后会被置空。<br>解决方案是：在 Hexo 目录下的 source 文件夹下创建名称为 CNAME 得文件，将域名<code>blog.qmzbe.top</code>写在里面（只能写一个）。然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>GitHub Pages 出现以下显示就可以了。<br><img src="https://user-images.githubusercontent.com/35981799/157800439-0b7b58f7-5d02-4b2d-ab8b-39a2c634fa90.png" alt="image"></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Midway 使用手册</title>
    <url>/posts/d0f62edf.html</url>
    <content><![CDATA[<p>社区版网址：<a href="http://www.midwayjs.org/">http://www.midwayjs.org/</a><br>使用版本：v3<br>类型：faas</p>
<span id="more"></span>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init midway</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm init midway</span><br><span class="line">? Hello, traveller.</span><br><span class="line">  Which template do you like? …</span><br><span class="line"></span><br><span class="line"> ⊙ v3</span><br><span class="line">  koa-v3 - A web application boilerplate with midway v3(koa)</span><br><span class="line">  egg-v3 - A web application boilerplate with midway v3(egg)</span><br><span class="line">❯ faas-v3 - A serverless application boilerplate with midway v3(faas)</span><br><span class="line">  component-v3 - A midway component boilerplate for v3</span><br><span class="line">  quick-start - A midway quickstart exmaple for v3</span><br><span class="line"></span><br><span class="line"> ⊙ v2</span><br><span class="line">  web - A web application boilerplate with midway and Egg.js</span><br><span class="line">  koa - A web application boilerplate with midway and koa</span><br></pre></td></tr></table></figure>
<p>选择 <code>faas-v3 </code>，创建完成如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">✔ Hello, traveller.</span><br><span class="line">  Which template do you like? · faas-v3 - A serverless application boilerplate with midway v3(faas)</span><br><span class="line">✔ What name would you like to use for the new project? · midway-faas-test</span><br><span class="line">Successfully created project midway-faas-test</span><br><span class="line">Get started with the following commands:</span><br><span class="line"></span><br><span class="line">$ cd midway-faas-test</span><br><span class="line">$ npm run dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thanks for using Midway</span><br><span class="line"></span><br><span class="line">Document ❤ Star: https://github.com/midwayjs/midway</span><br></pre></td></tr></table></figure>
<p>用 <code>tree -L 4</code> 指令查看目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── f.yml</span><br><span class="line">├── jest.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   ├── config.default.ts</span><br><span class="line">│   │   └── config.prod.ts</span><br><span class="line">│   ├── configuration.ts</span><br><span class="line">│   └── function</span><br><span class="line">│       └── hello.ts</span><br><span class="line">├── test</span><br><span class="line">│   └── hello.test.ts</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<p>成功显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  midway-faas-test npm run dev</span><br><span class="line"></span><br><span class="line">&gt; midway_faas_project@1.0.0 dev</span><br><span class="line">&gt; cross-env NODE_ENV=local midway-bin dev --ts</span><br><span class="line"></span><br><span class="line">[ Midway ] Start Server at  http://127.0.0.1:7001</span><br><span class="line">[ Midway ] Start on LAN http://30.24.115.81:7001</span><br></pre></td></tr></table></figure>
<p>默认端口号为 7001。<br>访问<code>http://127.0.0.1:7001</code> 会返回 Hello midwayjs 。<br>至此，一个 Midway FaaS 服务创建好了。</p>
<h2 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h2><p>如果需要修改开发的启动端口，可以在 package.json 的 scripts 段落里修改，如修改为 6001：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;cross-env NODE_ENV=local midway-bin dev --ts --port=6001&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
        <category>Midway</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>Midway</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的SQL执行分析和性能优化</title>
    <url>/posts/99e12db8.html</url>
    <content><![CDATA[<p>MySQL的SQL执行分析和性能优化<br>一、SQL 执行时间分析通过找到执行时间长的 SQL 语句，可以直观的发现数据层的效率问题。<br>1.通过show processlist来查看系统的执行情况。</p>
<span id="more"></span>


<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br><span class="line">+<span class="literal">----</span>+<span class="literal">------</span>+<span class="literal">-----------</span>+<span class="literal">------</span>+<span class="literal">---------</span>+<span class="literal">------</span>+<span class="literal">-------</span>+<span class="literal">------------------</span>+</span><br><span class="line">| Id | User | Host      | db   | Command | Time | State | Info             |</span><br><span class="line">+<span class="literal">----</span>+<span class="literal">------</span>+<span class="literal">-----------</span>+<span class="literal">------</span>+<span class="literal">---------</span>+<span class="literal">------</span>+<span class="literal">-------</span>+<span class="literal">------------------</span>+</span><br><span class="line">|  <span class="number">2</span> | root | localhost | NULL | Query   |    <span class="number">0</span> | init  | show processlist |</span><br><span class="line">+<span class="literal">----</span>+<span class="literal">------</span>+<span class="literal">-----------</span>+<span class="literal">------</span>+<span class="literal">---------</span>+<span class="literal">------</span>+<span class="literal">-------</span>+<span class="literal">------------------</span>+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>2.通过profiling来进行查看这个命令是查看 SQL 的执行时间，能很直观的看出快慢。<br>2.1 查看profiling是否开启0代表还是关闭着分析功能</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> <span class="selector-tag">@</span>@profiling;</span><br><span class="line">+<span class="literal">-------------</span>+</span><br><span class="line">| <span class="selector-tag">@</span>@profiling |</span><br><span class="line">+<span class="literal">-------------</span>+</span><br><span class="line">|           <span class="number">0</span> |</span><br><span class="line">+<span class="literal">-------------</span>+</span><br></pre></td></tr></table></figure>
<p>2.2 打开工具</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> profiling=<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> rows affected, <span class="number">0</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">select</span> <span class="selector-tag">@</span>@profiling;</span><br><span class="line">+<span class="literal">-------------</span>+</span><br><span class="line">| <span class="selector-tag">@</span>@profiling |</span><br><span class="line">+<span class="literal">-------------</span>+</span><br><span class="line">|           <span class="number">1</span> |</span><br><span class="line">+<span class="literal">-------------</span>+</span><br></pre></td></tr></table></figure>
<p>2.3 查看 SQL 的执行时间</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="literal">----------</span>+<span class="literal">------------</span>+<span class="literal">----------------------------</span>+</span><br><span class="line">| Query_ID | Duration   | Query                      |</span><br><span class="line">+<span class="literal">----------</span>+<span class="literal">------------</span>+<span class="literal">----------------------------</span>+</span><br><span class="line">|        <span class="number">1</span> | <span class="number">0.00173700</span> | <span class="built_in">select</span> * from ip           |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00057500</span> | <span class="built_in">select</span> porxy, port from ip |</span><br><span class="line">+<span class="literal">----------</span>+<span class="literal">------------</span>+<span class="literal">----------------------------</span>+</span><br></pre></td></tr></table></figure>
<p>2.4 查看 SQL 执行耗时详细信息语法：<code>show profile for query Query_ID</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br><span class="line">+<span class="literal">----------------------</span>+<span class="literal">----------</span>+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+<span class="literal">----------------------</span>+<span class="literal">----------</span>+</span><br><span class="line">| starting             | <span class="number">0.000073</span> |</span><br><span class="line">| checking permissions | <span class="number">0.000031</span> |   <span class="literal">---</span>检查是否在缓存中  </span><br><span class="line">| Opening tables       | <span class="number">0.000207</span> |   <span class="literal">---</span>打开表</span><br><span class="line">| init                 | <span class="number">0.000067</span> |   <span class="literal">---</span>初始化</span><br><span class="line">| System lock          | <span class="number">0.000040</span> |   <span class="literal">---</span>锁系统</span><br><span class="line">| optimizing           | <span class="number">0.000005</span> |   <span class="literal">---</span>优化查询</span><br><span class="line">| statistics           | <span class="number">0.000021</span> |</span><br><span class="line">| preparing            | <span class="number">0.000015</span> |   <span class="literal">---</span>准备</span><br><span class="line">| executing            | <span class="number">0.000003</span> |   <span class="literal">---</span>执行</span><br><span class="line">| Sending <span class="keyword">data</span>         | <span class="number">0.000993</span> |</span><br><span class="line">| <span class="keyword">end</span>                  | <span class="number">0.000006</span> |</span><br><span class="line">| query <span class="keyword">end</span>            | <span class="number">0.000007</span> |</span><br><span class="line">| closing tables       | <span class="number">0.000011</span> |</span><br><span class="line">| freeing items        | <span class="number">0.000169</span> |</span><br><span class="line">| cleaning up          | <span class="number">0.000089</span> |</span><br><span class="line">+<span class="literal">----------------------</span>+<span class="literal">----------</span>+</span><br></pre></td></tr></table></figure>
<p>以上具体的信息都是从<code>INFORMATION_SCHEMA.PROFILING</code>这张表中取得的。这张表记录了所有的各个步骤的执行时间及相关信息。语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INFORMATION_SCHEMA.PROFILING <span class="keyword">where</span> query_id <span class="operator">=</span> Query_ID;</span><br></pre></td></tr></table></figure>
<p>3.慢查询日志MySQL 的慢查询日志，顾名思义就是把执行时间超过设定值（默认为10s）的 SQL 记录到日志中。这项功能需要手动开启，但是开启后会造成一定的性能损耗。<br>3.1 查看慢日志是否开启默认情况下<code>slow_query_log</code>的值为<code>OFF</code>，表示慢查询日志是禁用的，可以通过设置<code>slow_query_log</code>的值来开启。语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables  like <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line">+<span class="literal">---------------------</span>+<span class="literal">------------------------------------------------------</span>+</span><br><span class="line">| Variable_name       | Value                                                |</span><br><span class="line">+<span class="literal">---------------------</span>+<span class="literal">------------------------------------------------------</span>+</span><br><span class="line">| slow_query_log      | OFF                                                  |</span><br><span class="line">| slow_query_log_file | /usr/local/var/mysql/xueweihandeMacBook<span class="literal">-Air-slow</span>.log |</span><br><span class="line">+<span class="literal">---------------------</span>+<span class="literal">------------------------------------------------------</span>+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global slow_query_log=<span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables  like <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line">+<span class="literal">---------------------</span>+<span class="literal">------------------------------------------------------</span>+</span><br><span class="line">| Variable_name       | Value                                                |</span><br><span class="line">+<span class="literal">---------------------</span>+<span class="literal">------------------------------------------------------</span>+</span><br><span class="line">| slow_query_log      | ON                                                   |</span><br><span class="line">| slow_query_log_file | /usr/local/var/mysql/xueweihandeMacBook<span class="literal">-Air-slow</span>.log |</span><br><span class="line">+<span class="literal">---------------------</span>+<span class="literal">------------------------------------------------------</span>+</span><br></pre></td></tr></table></figure>
<p>3.2 设置超时时间<br>设置语法：<code>set global long_query_time=4</code><br>查看语法：<code>show variables like &#39;long_query_time&#39;</code></p>
<blockquote>
<p>注意：修改后，需要重新连接或新开一个会话才能看到修改值。</p>
</blockquote>
<p>永久生效，修改<code>my.cnf</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">slow_query_log=<span class="number">1</span></span><br><span class="line">long_query_time=<span class="number">10</span></span><br><span class="line">slow_query_log_file=/path/mysql_slow.log</span><br></pre></td></tr></table></figure>
<p>3.3 其他参数<br>3.3.1 log_output参数是指定日志的存储方式。log_output&#x3D;’FILE’表示将日志存入文件，默认值是’FILE’。log_output&#x3D;’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output&#x3D;’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。<br>3.3.2 log-queries-not-using-indexes<br>未使用索引的查询也被记录到慢查询日志中（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用full index scan的sql也会被记录到慢查询日志。<br>3.3.3 log_slow_admin_statements<br>表示是否将慢管理语句例如ANALYZE TABLE和ALTER TABLE等记入慢查询日志<br>3.4 分析工具mysqldumpslow<br>MySQL 提供了慢日志分析工具mysqldumpslow。</p>
<blockquote>
<p>-s 表示按照何种方式排序；<br>    c: 访问计数<br>    l: 锁定时间<br>    r: 返回记录<br>    t: 查询时间<br>    al:平均锁定时间<br>    ar:平均返回记录数<br>    at:平均查询时间<br>-t 是top n的意思，即为返回前面多少条的数据；<br>-g 后边可以写一个正则匹配模式，大小写不敏感的；</p>
</blockquote>
<p>3.4.1 命令示例得到返回记录集最多的10个SQL：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow <span class="literal">-s</span> <span class="built_in">r</span> <span class="literal">-t</span> <span class="number">10</span> /database/mysql/mysql06_slow.log</span><br></pre></td></tr></table></figure>
<p>得到访问次数最多的10个SQL：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow <span class="literal">-s</span> c <span class="literal">-t</span> <span class="number">10</span> /database/mysql/mysql06_slow.log</span><br></pre></td></tr></table></figure>
<p>得到按照时间排序的前10条里面含有左连接的查询语句：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow <span class="literal">-s</span> t <span class="literal">-t</span> <span class="number">10</span> <span class="literal">-g</span> “left join” /database/mysql/mysql06_slow.log</span><br></pre></td></tr></table></figure>
<p>另外建议在使用这些命令时结合 | 和 more 使用 ，否则有可能出现刷屏的情况：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow <span class="literal">-s</span> <span class="built_in">r</span> <span class="literal">-t</span> <span class="number">20</span> /mysqldata/mysql/mysql06<span class="literal">-slow</span>.log | more</span><br></pre></td></tr></table></figure>

<p>二、SQL 执行情况分析使用 explain 分析 SQL 执行情况。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">explain <span class="built_in">select</span> * from ip;</span><br><span class="line">+<span class="literal">----</span>+<span class="literal">-------------</span>+<span class="literal">-------</span>+<span class="literal">------</span>+<span class="literal">---------------</span>+<span class="literal">------</span>+<span class="literal">---------</span>+<span class="literal">------</span>+<span class="literal">------</span>+<span class="literal">-------</span>+</span><br><span class="line">| id | select_type | table | <span class="built_in">type</span> | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+<span class="literal">----</span>+<span class="literal">-------------</span>+<span class="literal">-------</span>+<span class="literal">------</span>+<span class="literal">---------------</span>+<span class="literal">------</span>+<span class="literal">---------</span>+<span class="literal">------</span>+<span class="literal">------</span>+<span class="literal">-------</span>+</span><br><span class="line">|  <span class="number">1</span> | SIMPLE      | ip    | ALL  | NULL          | NULL | NULL    | NULL |  <span class="number">400</span> | NULL  |</span><br><span class="line">+<span class="literal">----</span>+<span class="literal">-------------</span>+<span class="literal">-------</span>+<span class="literal">------</span>+<span class="literal">---------------</span>+<span class="literal">------</span>+<span class="literal">---------</span>+<span class="literal">------</span>+<span class="literal">------</span>+<span class="literal">-------</span>+</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>表示查询的类型</td>
<td>输出结果集的表</td>
<td>表示表的连接类型</td>
<td>表示查询时，可能使用的索引</td>
<td>表示实际使用的索引</td>
<td>索引字段的长度</td>
<td>扫描出的行数(估算的行数)</td>
<td>执行情况的描述和说明</td>
</tr>
</tbody></table>
<p><a href="https://www.cnblogs.com/xueweihan/p/6864401.html">原文链接</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 事件循环机制</title>
    <url>/posts/637b87fa.html</url>
    <content><![CDATA[<h2 id="Node-js-事件循环机制"><a href="#Node-js-事件循环机制" class="headerlink" title="Node.js 事件循环机制"></a>Node.js 事件循环机制</h2><p><code>Node.js</code>采用事件驱动和异步<code>I/O</code>的方式，实现了一个单线程、高并发的<code>JavaScript</code>运行时环境，而单线程就意味着同一时间只能做一件事，那么<code>Node.js</code>如何通过单线程来实现高并发和异步<code>I/O</code>？本文将围绕这个问题来探讨<code> Node.js</code> 的单线程模型 。</p>
<span id="more"></span>

<h2 id="高并发策略"><a href="#高并发策略" class="headerlink" title="高并发策略"></a>高并发策略</h2><p>一般来说，高并发的解决方案就是提供多线程模型，服务器为每个客户端请求分配一个线程，使用同步<code>I/O</code>，系统通过线程切换来弥补同步<code>I/O</code> 调用的时间开销。比如<code>Apache</code>就是这种策略，由于<code>I/O</code>一般都是耗时操作，因此这种策略很难实现高性能，但非常简单，可以实现复杂的交互逻辑。</p>
<p>而事实上，大多数网站的服务器端都不会做太多的计算，它们接收到请求以后，把请求交给其它服务来处理（比如读取数据库），然后等着结果返回，最后再把结果发给客户端。因此，Node.js 针对这一事实采用了单线程模型来处理，它不会为每个接入请求分配一个线程，而是用一个主线程处理所有的请求，然后对<code>I/O</code> 操作进行异步处理，避开了创建、销毁线程以及在线程间切换所需的开销和复杂性。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><code>Node.js</code>在主线程里维护了一个<code>事件队列</code>，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非<code>I/O</code>任务，就亲自处理，并通过回调函数返回到上层调用；如果是<code>I/O</code>任务，就从<code>线程池</code>中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p>
<p>当线程中的<code>I/O</code>任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫<code>事件循环(Event Loop)</code>，其运行原理如下图所示：<br><img src="https://flzc.gitee.io/mynote/blog/955921-20210425171651176-144580716.png" alt="image"><br>这个图是整个<code>Node.js</code> 的运行原理，从左到右，从上到下，<code>Node.js</code>被分为了四层，分别是<code>应用层</code>、<code>V8引擎层</code>、<code>Node API层</code>和 <code>LIBUV层</code>。</p>
<blockquote>
<p><code>应用层</code>：   即<code>JavaScript</code>交互层，常见的就是<code>Node.js</code>的模块，比如<code>http</code>，<code>fs</code><br><code>V8引擎层</code>：  即利用<code>V8引擎</code>来解析<code>JavaScript</code>语法，进而和下层<code>API</code>交互<br><code>NodeAPI层</code>：  为上层模块提供系统调用，一般是由<code>C语言</code>来实现，和操作系统进行交互 。<br><code>LIBUV层</code>： 是跨平台的底层封装，实现了<code>事件循环</code>、<code>文件操作</code>等，是<code>Node.js</code>实现异步的核心 。</p>
</blockquote>
<p>无论是<code>Linux</code>平台还是<code>Windows</code>平台，<code>Node.js</code> 内部都是通过<code>线程池</code>来完成异步<code>I/O</code>操作的，而<code>LIBUV</code>针对不同平台的差异性实现了统一调用。因此，<code>Node.js的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程</code>。</p>
<p>工作原理<br><code>Node.js</code>实现异步的核心是事件，也就是说，它把每一个任务都当成<code>事件</code>来处理，然后通过<code>Event Loop</code>模拟了异步的效果，为了更具体、更清晰的理解和接受这个事实，下面我们用伪代码来描述一下其工作原理 。</p>
<h3 id="【1】定义事件队列"><a href="#【1】定义事件队列" class="headerlink" title="【1】定义事件队列"></a>【1】定义事件队列</h3><p>既然是队列，那就是一个先进先出(<code>FIFO</code>)的数据结构，我们用<code>JS数组</code>来描述，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义事件队列</span></span><br><span class="line"><span class="comment"> * 入队：push()</span></span><br><span class="line"><span class="comment"> * 出队：shift()</span></span><br><span class="line"><span class="comment"> * 空队列：length == 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">globalEventQueue</span>: []</span><br></pre></td></tr></table></figure>
<p>我们利用数组来模拟队列结构：数组的第一个元素是队列的头部，数组的最后一个元素是队列的尾部，push() 就是在队列尾部插入一个元素，shift() 就是从队列头部弹出一个元素。这样就实现了一个简单的事件队列。</p>
<h3 id="【2】定义接收请求入口"><a href="#【2】定义接收请求入口" class="headerlink" title="【2】定义接收请求入口"></a>【2】定义接收请求入口</h3><p>每一个请求都会被拦截并进入处理函数，如下所示： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收用户请求</span></span><br><span class="line"><span class="comment"> * 每一个请求都会进入到该函数</span></span><br><span class="line"><span class="comment"> * 传递参数request和response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">processHttpRequest</span>: <span class="keyword">function</span>(<span class="params">request, response</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个事件对象</span></span><br><span class="line">  <span class="keyword">var</span> event = <span class="title function_">createEvent</span>(&#123;</span><br><span class="line">    <span class="attr">params</span>: request.<span class="property">params</span>, <span class="comment">// 传递请求参数</span></span><br><span class="line">    <span class="attr">result</span>: <span class="literal">null</span>, <span class="comment">// 存放请求结果</span></span><br><span class="line">    <span class="attr">callback</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125; <span class="comment">// 指定回调函数</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在队列的尾部添加该事件  </span></span><br><span class="line">  globalEventQueue.<span class="title function_">push</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数很简单，就是把用户的请求包装成事件，放到队列里，然后继续接收其他请求。</p>
<h3 id="【3】定义-Event-Loop"><a href="#【3】定义-Event-Loop" class="headerlink" title="【3】定义 Event Loop"></a>【3】定义 Event Loop</h3><p>当主线程处于空闲时就开始循环事件队列，所以我们还要定义一个函数来循环事件队列： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件循环主体，主线程择机执行</span></span><br><span class="line"><span class="comment"> * 循环遍历事件队列</span></span><br><span class="line"><span class="comment"> * 处理非IO任务</span></span><br><span class="line"><span class="comment"> * 处理IO任务</span></span><br><span class="line"><span class="comment"> * 执行回调，返回给上层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">eventLoop</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果队列不为空，就继续循环</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">globalEventQueue</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列的头部拿出一个事件</span></span><br><span class="line">    <span class="keyword">var</span> event = <span class="variable language_">this</span>.<span class="property">globalEventQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是耗时任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isIOTask</span>(event)) &#123;</span><br><span class="line">      <span class="comment">// 从线程池里拿出一个线程</span></span><br><span class="line">      <span class="keyword">var</span> thread = <span class="title function_">getThreadFromThreadPool</span>();</span><br><span class="line">      <span class="comment">// 交给线程处理</span></span><br><span class="line">      thread.<span class="title function_">handleIOTask</span>(event)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非耗时任务处理后，直接返回结果</span></span><br><span class="line">      <span class="keyword">var</span> result = <span class="title function_">handleEvent</span>(event);</span><br><span class="line">      <span class="comment">// 最终通过回调函数返回给V8，再由V8返回给应用程序</span></span><br><span class="line">      event.<span class="property">callback</span>.<span class="title function_">call</span>(<span class="literal">null</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程不停的检测事件队列，对于 I&#x2F;O 任务，就交给线程池来处理，非 I&#x2F;O 任务就自己处理并返回。</p>
<h3 id="【4】处理-I-O-任务"><a href="#【4】处理-I-O-任务" class="headerlink" title="【4】处理 I&#x2F;O 任务"></a>【4】处理 I&#x2F;O 任务</h3><p>线程池接到任务以后，直接处理IO操作，比如读取数据库：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理IO任务</span></span><br><span class="line"><span class="comment"> * 完成后将事件添加到队列尾部</span></span><br><span class="line"><span class="comment"> * 释放线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">handleIOTask</span>: <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">//当前线程</span></span><br><span class="line">  <span class="keyword">var</span> curThread = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 操作数据库</span></span><br><span class="line">  <span class="keyword">var</span> optDatabase = <span class="keyword">function</span> (<span class="params">params, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="title function_">readDataFromDb</span>(params);</span><br><span class="line">    callback.<span class="title function_">call</span>(<span class="literal">null</span>, result)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行IO任务</span></span><br><span class="line">  <span class="title function_">optDatabase</span>(event.<span class="property">params</span>, <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="comment">// 返回结果存入事件对象中</span></span><br><span class="line">    event.<span class="property">result</span> = result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO完成后，将不再是耗时任务</span></span><br><span class="line">    event.<span class="property">isIOTask</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该事件重新添加到队列的尾部</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">globalEventQueue</span>.<span class="title function_">push</span>(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放当前线程</span></span><br><span class="line">    <span class="title function_">releaseThread</span>(curThread)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当I&#x2F;O任务完成以后就执行回调，把请求结果存入事件中，并将该事件重新放入队列中，等待循环，最后释放当前线程，当主线程再次循环到该事件时，就直接处理了。</p>
<p>总结以上过程我们发现，Node.js 只用了一个主线程来接收请求，但它接收请求以后并没有直接做处理，而是放到了事件队列中，然后又去接收其他请求了，空闲的时候，再通过 Event Loop 来处理这些事件，从而实现了异步效果，当然对于IO类任务还需要依赖于系统层面的线程池来处理。</p>
<p>因此，我们可以简单的理解为：<code>Node.js 本身是一个多线程平台，而它对 JavaScript 层面的任务处理是单线程的</code>。</p>
<h2 id="CPU密集型是短板"><a href="#CPU密集型是短板" class="headerlink" title="CPU密集型是短板"></a>CPU密集型是短板</h2><p>至此，对于 Node.js 的单线程模型，我们应该有了一个简单而又清晰的认识，它通过事件驱动模型实现了高并发和异步 I&#x2F;O，然而也有 Node.js 不擅长做的事情：</p>
<p>上面提到，如果是 I&#x2F;O 任务，Node.js 就把任务交给线程池来异步处理，高效简单，因此 Node.js 适合处理I&#x2F;O密集型任务。但不是所有的任务都是 I&#x2F;O 密集型任务，当碰到CPU密集型任务时，即只用CPU计算的操作，比如要对数据加解密(node.bcrypt.js)，数据压缩和解压(node-tar)，这时 Node.js 就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着 。如下图所示：<br><img src="https://flzc.gitee.io/mynote/blog/955921-20210425173510518-507922165.png" alt="image"></p>
<p>在事件队列中，如果前面的 CPU 计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，如果操作系统本身就是单核，那也就算了，但现在大部分服务器都是多 CPU 或多核的，而 Node.js 只有一个 EventLoop，也就是只占用一个 CPU 内核，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。</p>
<p>因此，Node.js 并不适合 CPU 密集型任务。</p>
<p>适用场景<br>RESTful API - 请求和响应只需少量文本，并且不需要大量逻辑处理， 因此可以并发处理数万条连接。</p>
<p>聊天服务 - 轻量级、高流量，没有复杂的计算逻辑。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Shoka 主题使用教程：Step.1 依赖插件</title>
    <url>/posts/3d4c8438.html</url>
    <content><![CDATA[<blockquote>
<p>请务必将 hexo-renderer-multi-markdown-it 升级到最新版，目前为 0.1.5</p>
</blockquote>
<span id="more"></span>

<p>Theme Shoka 依赖以下 Hexo 插件</p>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>npm 地址</th>
<th>功能</th>
<th>依赖程度</th>
</tr>
</thead>
<tbody><tr>
<td>hexo-renderer-multi-markdown-it</td>
<td><a href="https://www.npmjs.com/package/hexo-renderer-multi-markdown-it" title="链接">链接</a></td>
<td>md 文件渲染器，压缩 css&#x2F;js&#x2F;html</td>
<td>必需</td>
</tr>
<tr>
<td>hexo-autoprefixer</td>
<td><a href="https://www.npmjs.com/package/hexo-autoprefixer" title="链接">链接</a></td>
<td>给生成的 css 文件们添加浏览器前缀</td>
<td>必需</td>
</tr>
<tr>
<td>hexo-algoliasearch</td>
<td><a href="https://www.npmjs.com/package/hexo-algoliasearch" title="链接">链接</a></td>
<td>站内搜索功能</td>
<td>搜索按钮失灵</td>
</tr>
<tr>
<td>hexo-symbols-count-time</td>
<td><a href="https://www.npmjs.com/package/hexo-symbols-count-time" title="链接">链接</a></td>
<td>文章或站点字数及阅读时间统计</td>
<td>统计没有</td>
</tr>
<tr>
<td>hexo-feed</td>
<td><a href="https://www.npmjs.com/package/hexo-feed" title="链接">链接</a></td>
<td>生成 Feed 文件</td>
<td>Feed 文件没有</td>
</tr>
</tbody></table>
<blockquote>
<p>没有正确安装以上插件的话，本主题会报错 or 无法正确显示 or 部分功能失效。<br><code>hexo-renderer-multi-markdown-it</code> 请注意升级到最新版</p>
</blockquote>
<p>安装完以上插件后，修改站点配置文件，加入相关配置。</p>
<h1 id="multi-markdown-it-安装与配置"><a href="#multi-markdown-it-安装与配置" class="headerlink" title="multi-markdown-it 安装与配置"></a>multi-markdown-it 安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装前，记得务必卸载掉默认的 <code>hexo-renderer-marked</code> ，以及别的 markdown 文件渲染器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn remove hexo-renderer-marked</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-multi-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add hexo-renderer-multi-markdown-it</span><br></pre></td></tr></table></figure>
<p>如果安装缓慢，或者失败<br>如报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: Failed to download Chromium r515411! Set &quot;PUPPETEER_SKIP_CHROMIUM_DOWNLOAD&quot; env variable to skip download.</span><br></pre></td></tr></table></figure>
<p>因为有一步需要下载 puppeteer 里的 Chromium 内核，基于天朝内部网络现状，这一步能不能成功要靠科学和运气，所以为了避免安装失败，需要加上 <code>--ignore-scripts</code> 跳过 Chromium 内核的下载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-multi-markdown-it --save --ignore-scripts</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add hexo-renderer-multi-markdown-it --ignore-scripts</span><br></pre></td></tr></table></figure>
<p>puppeteer 主要是用来渲染 mermaid 流程图，只要文章中不使用 mermaid 就没有任何问题，如果要使用 mermaid 建议还是想办法完全安装。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>加入 <code>markdown</code> 配置，用来渲染 md 文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span> <span class="comment"># 渲染器设置</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">false</span> <span class="comment"># 过滤 HTML 标签</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">true</span> <span class="comment"># 使用 &#x27;/&#x27; 来闭合单标签 （比如 &lt;br /&gt;）。</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span> <span class="comment"># 转换段落里的 &#x27;\n&#x27; 到 &lt;br&gt;。</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span> <span class="comment"># 将类似 URL 的文本自动转换为链接。</span></span><br><span class="line">    <span class="attr">typographer:</span> </span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="comment"># markdown-it 插件设置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">markdown-it-toc-and-anchor</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">options:</span> <span class="comment"># 文章目录以及锚点应用的 class 名称，shoka 主题必须设置成这样</span></span><br><span class="line">          <span class="attr">tocClassName:</span> <span class="string">&#x27;toc&#x27;</span></span><br><span class="line">          <span class="attr">anchorClassName:</span> <span class="string">&#x27;anchor&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">markdown-it-multimd-table</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">          <span class="attr">multiline:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">rowspan:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">headerless:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">./markdown-it-furigana</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">          <span class="attr">fallbackParens:</span> <span class="string">&quot;()&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">./markdown-it-spoiler</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">          <span class="attr">title:</span> <span class="string">&quot;你知道得太多了&quot;</span></span><br></pre></td></tr></table></figure>
<p>加入 <code>minify</code> 配置，压缩 css&#x2F;js&#x2F;html</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">minify:</span></span><br><span class="line">  <span class="attr">html:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="comment"># 排除 hexo-feed 用到的模板文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**/json.ejs&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**/atom.ejs&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**/rss.ejs&#x27;</span></span><br><span class="line">  <span class="attr">css:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">exclude:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br><span class="line">  <span class="attr">js:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">mangle:</span></span><br><span class="line">      <span class="attr">toplevel:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">output:</span></span><br><span class="line">    <span class="attr">compress:</span></span><br><span class="line">    <span class="attr">exclude:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**/*.min.js&#x27;</span></span><br></pre></td></tr></table></figure>
<p>停用默认代码高亮功能，否则代码块的 mac 样式不能正常显示。<br>找到 <code>highlight</code> 和 <code>prismjs</code> ，把 <code>enable</code> 改成 <code>false</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment">#autoprefixer 配置建议</span></span><br><span class="line"><span class="attr">autoprefixer:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;*.min.css&#x27;</span></span><br></pre></td></tr></table></figure>
<p>缺少这个插件，首页卡片翻转效果在部分浏览器中无法正确显示。</p>
<h1 id="algolia-配置建议"><a href="#algolia-配置建议" class="headerlink" title="algolia 配置建议"></a>algolia 配置建议</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="comment">#Your appId</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="comment">#Your apiKey</span></span><br><span class="line">  <span class="attr">adminApiKey:</span> <span class="comment">#Your adminApiKey</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="comment">#&quot;shoka&quot;</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">title</span> <span class="comment">#必须配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">path</span> <span class="comment">#必须配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">categories</span> <span class="comment">#推荐配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">content:strip:truncate,0,2000</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gallery</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">photos</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure>
<h1 id="feed-配置建议"><a href="#feed-配置建议" class="headerlink" title="feed 配置建议"></a>feed 配置建议</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">keywords:</span> <span class="comment">#站点关键词，用 “,” 分隔</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">order_by:</span> <span class="string">&quot;-date&quot;</span></span><br><span class="line">    <span class="attr">tag_dir:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">category_dir:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">rss:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">&quot;themes/shoka/layout/_alternate/rss.ejs&quot;</span></span><br><span class="line">        <span class="attr">output:</span> <span class="string">&quot;rss.xml&quot;</span></span><br><span class="line">    <span class="attr">atom:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">&quot;themes/shoka/layout/_alternate/atom.ejs&quot;</span></span><br><span class="line">        <span class="attr">output:</span> <span class="string">&quot;atom.xml&quot;</span></span><br><span class="line">    <span class="attr">jsonFeed:</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">&quot;themes/shoka/layout/_alternate/json.ejs&quot;</span></span><br><span class="line">        <span class="attr">output:</span> <span class="string">&quot;feed.json&quot;</span></span><br></pre></td></tr></table></figure>
<p>本文作者： Ruri Shimotsuki @優萌初華<br>本文链接： <a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/">https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Shoka</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL使用技巧总结</title>
    <url>/posts/2158f55d.html</url>
    <content><![CDATA[<h2 id="JSON-数据的使用"><a href="#JSON-数据的使用" class="headerlink" title="JSON 数据的使用"></a>JSON 数据的使用</h2><p>首先有一张 test 表，content 字段保存的是 JSON 数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` json <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>插入几条测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	( <span class="keyword">NULL</span>, <span class="string">&#x27;标题1&#x27;</span>, <span class="string">&#x27;&#123; &quot;key1&quot; : &quot;内容1&quot;, &quot;key2&quot; : &quot;内容1&quot;, &quot;123&quot; : &quot;内容1&quot; &#125;&#x27;</span> ),</span><br><span class="line">	( <span class="keyword">NULL</span>, <span class="string">&#x27;标题2&#x27;</span>, <span class="string">&#x27;&#123; &quot;key1&quot; : &quot;内容2&quot;, &quot;key2&quot; : &quot;内容2&quot;, &quot;123&quot; : &quot;内容2&quot; &#125;&#x27;</span> ),</span><br><span class="line">	( <span class="keyword">NULL</span>, <span class="string">&#x27;标题3&#x27;</span>, <span class="string">&#x27;&#123; &quot;key1&quot; : &quot;内容3&quot;, &quot;key2&quot; : &quot;内容3&quot;, &quot;123&quot; : &quot;内容3&quot; &#125;&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>查询字段 key1 为“内容1”的数据，这里使用<a href="https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html" title="JSON_EXTRACT()">JSON_EXTRACT()</a>，更多点击：<a href="https://dev.mysql.com/doc/refman/5.7/en/json-function-reference.html" title="MySQL 官方文档">MySQL 官方文档</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> JSON_EXTRACT(content,<span class="string">&#x27;$.key1&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;内容1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查询字段为“123”的内容为“内容1”的数据</p>
<blockquote>
<p>因为字段为纯数字，所以需要加双引号(“”)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> JSON_EXTRACT(content,<span class="string">&#x27;$.&quot;123&quot;&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;内容1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>为 JSON 内部字段 key1 加索引<br>第一步：添加<strong>虚拟字段</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `key1_virtual` <span class="type">VARCHAR</span> (<span class="number">20</span>) GENERATED ALWAYS <span class="keyword">AS</span> (json_unquote(json_extract(content,<span class="string">&#x27;$.key1&#x27;</span>))) VIRTUAL;</span><br></pre></td></tr></table></figure>
<p>第二步：创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">ADD</span> INDEX `idx_key1`(key1_virtual) <span class="keyword">USING</span> BTREE;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> key1_virtual<span class="operator">=</span><span class="string">&#x27;内容1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果如下，idx_key1 索引生效了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | test  | NULL       | ref  | idx_key1      | idx_key1 | 83      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>另外还有一种添加索引的方法：<a href="https://blog.csdn.net/qq_38688267/article/details/119383103" title="查看">查看</a></p>
<hr>
<p>参考文章：<br><a href="https://developer.aliyun.com/article/303208">https://developer.aliyun.com/article/303208</a></p>
<h2 id="mysql更新-A-表的字段等于-B-表的字段"><a href="#mysql更新-A-表的字段等于-B-表的字段" class="headerlink" title="mysql更新 A 表的字段等于 B 表的字段"></a>mysql更新 A 表的字段等于 B 表的字段</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> </span><br><span class="line">	article a1,</span><br><span class="line">	article a2 </span><br><span class="line"><span class="keyword">SET</span> a1.name1 <span class="operator">=</span> a2.name </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	a1.id <span class="operator">=</span> a2.id </span><br><span class="line">	<span class="keyword">AND</span> a1.name1 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> </span><br><span class="line">	<span class="keyword">AND</span> a2.name1 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Shoka 主题使用教程：Step.2 基本配置</title>
    <url>/posts/e61f91f5.html</url>
    <content><![CDATA[<h1 id="站点别称"><a href="#站点别称" class="headerlink" title="站点别称"></a>站点别称</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">alternate:</span> <span class="string">Yume</span> <span class="string">Shoka</span></span><br></pre></td></tr></table></figure>
<p>这里设置的名称代替 Logo，显示在页面顶部，以及页尾©️处</p>
<span id="more"></span>

<h1 id="静态文件目录"><a href="#静态文件目录" class="headerlink" title="静态文件目录"></a>静态文件目录</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">statics:</span> <span class="string">/</span> <span class="comment">#//cdn.jsdelivr.net/gh/amehime/shoka@latest/</span></span><br></pre></td></tr></table></figure>
<p>默认值是 <code>/</code> ，指使用本地静态文件<br>可以修改成 <code>//cdn.jsdelivr.net/gh/您的github用户名/您的项目名@latest/</code> 这种形式，以使用 jsDelivr 进行加速。<br>PS：jsDelivr 并不是实时更新，重新生成文件后需要耐心等待</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br></pre></td></tr></table></figure>
<p>静态文件所处目录的实际目录名，这些一般不改。</p>
<h1 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">darkmode:</span> <span class="comment"># true</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，是否开启夜间模式取决于（优先级从高到低）：</p>
<ol>
<li>访客点击页面头部切换按钮的自行选择</li>
<li>访客切换了浏览设备的主题色调</li>
<li>您的 <code>darkmode</code> 配置项</li>
</ol>
<h1 id="自动定位"><a href="#自动定位" class="headerlink" title="自动定位"></a>自动定位</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_scroll:</span> <span class="comment"># false</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，再次打开页面时，会自动滚动到上次浏览的位置。<br>这个选项设为 <code>false</code> 时将停用此功能。</p>
<h1 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否显示页面加载动画 loading-cat</span></span><br><span class="line"><span class="attr">loader:</span></span><br><span class="line">  <span class="attr">start:</span> <span class="literal">true</span> <span class="comment"># 当初次打开页面时，显示加载动画</span></span><br><span class="line">  <span class="attr">switch:</span> <span class="literal">true</span> <span class="comment"># tab 切换到其他页面时，显示加载动画</span></span><br></pre></td></tr></table></figure>

<p>tab 切换后只是显示 loading 动画，实际并未重新加载页面</p>
<h1 id="页面特效"><a href="#页面特效" class="headerlink" title="页面特效"></a>页面特效</h1><p>单击页面的烟花效果配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fireworks:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否启用</span></span><br><span class="line">  <span class="attr">color:</span> <span class="comment"># 烟花颜色</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;rgba(255,182,185,.9)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;rgba(250,227,217,.9)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;rgba(187,222,214,.9)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;rgba(138,198,209,.9)&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="加载谷歌字体"><a href="#加载谷歌字体" class="headerlink" title="加载谷歌字体"></a>加载谷歌字体</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Mulish</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for alternate title.</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Fredericka</span> <span class="string">the</span> <span class="string">Great</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">3.5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title.</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">JP</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts.</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Inconsolata</span></span><br></pre></td></tr></table></figure>

<p>此功能基本参考 NexT。<br>加粗标题的字体总是使用 <code>Noto Serif</code> ，为了正确友好的显示日文中的汉字，会先后加载 <code>headings</code> 和 <code>title</code> 的字体设置。</p>
<h1 id="iconfont-图标"><a href="#iconfont-图标" class="headerlink" title="iconfont 图标"></a><code>iconfont</code> 图标</h1><p>主题没有直接使用 Font Awesome，是因为用不到那么多 icon 感觉非常浪费，因此在 Iconfont 上重新建立了一个项目。<br><code>font-family</code> 设为 <code>ic</code> ，所有字体样式前缀为 <code>i-</code> ，具体参见 <code>&lt;root&gt;/themes/shoka/source/css/_iconfont.styl</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># project of https://www.iconfont.cn/</span></span><br><span class="line"><span class="comment"># //at.alicdn.com/t/font_1832207_c8i9n1ulxlt.css =&gt; 1832207_c8i9n1ulxlt</span></span><br><span class="line"><span class="attr">iconfont:</span> <span class="string">&quot;1832207_c8i9n1ulxlt&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果需要添加或修改，请留言告诉我您的 <a href="https://www.iconfont.cn/" title=" Iconfont">Iconfont</a> 用户名，我将把您添加到目前的<a href="https://www.iconfont.cn/manage/index?manage_type=myprojects&amp;projectId=1832207" title="项目">项目</a>中。</p>
<p>添加权限为 <code>只读</code> ，此后您可以任意全选，批量保存到购物车中，添加至您自己的项目里，并将主题配置文件中的 <code>iconfont</code> 值改为您的项目。</p>
<p>注意，您的项目应设置 <code>FontClass/Symbol 前缀</code> 为 <code>i-</code> 。</p>
<p>在 <code>&lt;root&gt;/source/_data/</code> 目录新建文件 <code>iconfont.styl</code> ，把新增或修改的图标样式复制到这个文件中。</p>
<blockquote>
<p>自定义 <code>iconfont.styl</code> 文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。</p>
</blockquote>
<h1 id="菜单与社交按钮"><a href="#菜单与社交按钮" class="headerlink" title="菜单与社交按钮"></a>菜单与社交按钮</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">default:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">feather</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">list-alt</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="comment"># friends: /friends/ || heart</span></span><br><span class="line">  <span class="comment"># links: /links/ || magic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">github:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">github</span> <span class="string">||</span> <span class="string">&quot;#191717&quot;</span></span><br><span class="line">  <span class="comment">#google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="attr">twitter:</span> <span class="string">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">twitter</span> <span class="string">||</span> <span class="string">&quot;#00aff0&quot;</span></span><br><span class="line">  <span class="attr">zhihu:</span> <span class="string">https://www.zhihu.com/people/yourname</span> <span class="string">||</span> <span class="string">zhihu</span> <span class="string">||</span> <span class="string">&quot;#1e88e5&quot;</span></span><br><span class="line">  <span class="attr">music:</span> <span class="string">https://music.163.com/#/user/home?id=yourid</span> <span class="string">||</span> <span class="string">cloud-music</span> <span class="string">||</span> <span class="string">&quot;#e60026&quot;</span></span><br><span class="line">  <span class="attr">weibo:</span> <span class="string">https://weibo.com/yourname</span> <span class="string">||</span> <span class="string">weibo</span> <span class="string">||</span> <span class="string">&quot;#ea716e&quot;</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">https://about.me/yourname</span> <span class="string">||</span> <span class="string">address-card</span> <span class="string">||</span> <span class="string">&quot;#3b5998&quot;</span></span><br><span class="line">  <span class="comment">#email: mailto:yourname@mail.com || envelope || &quot;#55acd5&quot;</span></span><br><span class="line">  <span class="comment">#facebook: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#stackoverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#youtube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#skype: skype:yourname?call|chat || skype</span></span><br><span class="line">  <span class="comment">#douban: https://www.douban.com/people/yourname/ || douban</span></span><br></pre></td></tr></table></figure>

<p>如上，使用 <code>||</code> 作为分隔符，依次为 <code>链接 || 图标 || 颜色</code> 。<br>注意，只需要写图标名称，如 <code>github</code> ，则会自动转换为 <code>ic i-github</code> 。<br>十六进制颜色码需要 <code>&quot;&quot;</code> 包绕。</p>
<p><code>menu</code> 支持一级子目录，子目录设置中的第一项必须为 <code>default</code> ，用来定义父级按钮的样式。</p>
<p>菜单显示文字可以在语言包中定义，<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%E5%8C%85">具体请戳这里</a></p>
<h1 id="边栏配置"><a href="#边栏配置" class="headerlink" title="边栏配置"></a>边栏配置</h1><p>边栏可以选择在左侧，或右侧<br>修改头像文件的地址，相对于静态文件目录 <code>images</code> 中配置的路径。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line">  <span class="comment"># Replace the default avatar image and set the url here.</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">avatar.jpg</span></span><br></pre></td></tr></table></figure>

<p>可以将自己的图片放在 <code>&lt;root&gt;/source/_data/images/</code> 目录，甚至以同名覆盖主题内默认的头像图片，<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E5%9B%BE%E7%89%87">具体请戳这里</a></p>
<h1 id="底部-widgets"><a href="#底部-widgets" class="headerlink" title="底部 widgets"></a>底部 widgets</h1><p>目前页面底部可以显示两个小部件，即 <code>随机文章</code> 和 <code>最近评论</code> 。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">widgets:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">random_posts:</span> <span class="literal">true</span> <span class="comment"># 显示随机文章</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">recent_comments:</span> <span class="literal">true</span> <span class="comment"># 显示最近评论</span></span><br></pre></td></tr></table></figure>
<h1 id="字数及阅读时间统计"><a href="#字数及阅读时间统计" class="headerlink" title="字数及阅读时间统计"></a>字数及阅读时间统计</h1><p>安装好 <code>hexo-symbols-count-time</code> 插件后，不需要修改站点配置文件，直接使用插件默认配置就行。</p>
<p>需要修改主题配置文件，找到两处 <code>cout</code> ，修改为 <code>true</code> ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 页尾全站统计</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2010</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章界面统计</span></span><br><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="文章评论"><a href="#文章评论" class="headerlink" title="文章评论"></a>文章评论</h1><p><a href="https://valine.js.org/quickstart.html" title="如何获取 LeanCloud 的 appId 和 appKey">如何获取 LeanCloud 的 appId 和 appKey</a>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="comment">#Your_appId</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment">#Your_appkey</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">ヽ(○´∀`)ﾉ♪</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mp</span> <span class="comment"># Gravatar style : mp, identicon, monsterid, wavatar, robohash, retro</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章访问量统计</span></span><br><span class="line">  <span class="attr">NoRecordIP:</span> <span class="literal">false</span> <span class="comment"># 不记录 IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="attr">powerMode:</span> <span class="literal">true</span> <span class="comment"># 默认打开评论框输入特效</span></span><br><span class="line">  <span class="attr">tagMeta:</span></span><br><span class="line">    <span class="attr">visitor:</span> <span class="string">新朋友</span></span><br><span class="line">    <span class="attr">master:</span> <span class="string">主人</span></span><br><span class="line">    <span class="attr">friend:</span> <span class="string">小伙伴</span></span><br><span class="line">    <span class="attr">investor:</span> <span class="string">金主粑粑</span></span><br><span class="line">  <span class="attr">tagColor:</span></span><br><span class="line">    <span class="attr">master:</span> <span class="string">&quot;var(--color-orange)&quot;</span></span><br><span class="line">    <span class="attr">friend:</span> <span class="string">&quot;var(--color-aqua)&quot;</span></span><br><span class="line">    <span class="attr">investor:</span> <span class="string">&quot;var(--color-pink)&quot;</span></span><br><span class="line">  <span class="attr">tagMember:</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="comment"># - hash of master@email.com</span></span><br><span class="line">      <span class="comment"># - hash of master2@email.com</span></span><br><span class="line">    <span class="attr">friend:</span></span><br><span class="line">      <span class="comment"># - hash of friend@email.com</span></span><br><span class="line">      <span class="comment"># - hash of friend2@email.com</span></span><br><span class="line">    <span class="attr">investor:</span></span><br><span class="line">      <span class="comment"># - hash of investor1@email.com</span></span><br></pre></td></tr></table></figure>


<p>tag 标签显示在评论者名字的后面，默认是 <code>tagMeta.visitor</code> 对应的值。<br>在 <code>tagMeta</code> 和 <code>tagColor</code> 中，除了 <code>visitor</code> 这个 key 不能修改外，其他 key 都可以换一换，但需要保证一致性。</p>
<p>举个栗子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tagMeta:</span></span><br><span class="line">    <span class="attr">visitor:</span> <span class="string">游客</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">管理员</span></span><br><span class="line">    <span class="attr">waifu:</span> <span class="string">我老婆</span></span><br><span class="line">  <span class="attr">tagColor:</span></span><br><span class="line">    <span class="attr">visitor:</span> <span class="string">&quot;#855194&quot;</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="string">&quot;#a77c59&quot;</span></span><br><span class="line">    <span class="attr">waifu:</span> <span class="string">&quot;#ed6ea0&quot;</span></span><br><span class="line">  <span class="attr">tagMember:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="comment"># - hash of admin@email.com</span></span><br><span class="line">    <span class="attr">waifu:</span></span><br><span class="line">      <span class="comment"># - hash of waifu@email.com</span></span><br></pre></td></tr></table></figure>

<p>在文章 Front Matter 中也可以配置上述参数，访问该文章页面时，将覆盖全局配置。<br>尤其可以用来配置一个特殊的 placeholder。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">&quot;1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>评论通知与管理工具建议使用这个 <a href="https://github.com/DesertsP/Valine-Admin" title=" Valine-Admin">Valine-Admin</a>。<br>注意 <code>SITE_URL</code> 需要以 <code>/</code> 结尾。</p>
<p>如果某一篇文章需要关闭评论功能，则在文章 Front Matter 中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关闭评论</span></span><br><span class="line"><span class="attr">comment:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<h1 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h1><p>在主题配置文件中，设置全局播放列表。<br>在文章的 Front Matter 中，设置文章专有播放列表，访问该文章页面时，将覆盖全局配置。</p>
<p>单列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">audio:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://music.163.com/song?id=1387098940</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://music.163.com/#/playlist?id=2088001742</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://www.xiami.com/collect/250830668</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://y.qq.com/n/yqq/playsquare/3535982902.html</span></span><br></pre></td></tr></table></figure>
<p>如上，可以直接使用网易云、虾米、QQ 音乐的播放列表、单曲，可以同时填写多个。</p>
<p>多列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">audio:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">列表1</span></span><br><span class="line">    <span class="attr">list:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://music.163.com/#/playlist?id=2943811283</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://music.163.com/#/playlist?id=2297706586</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">列表2</span></span><br><span class="line">    <span class="attr">list:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https://music.163.com/#/playlist?id=2031842656</span></span><br></pre></td></tr></table></figure>

<p>如果需要自定义媒体文件，可以按照以下格式填写：</p>
<p>单列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">audio:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;曲目1&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;播放地址&quot;</span></span><br><span class="line">    <span class="attr">artist:</span> <span class="string">&quot;艺术家&quot;</span></span><br><span class="line">    <span class="attr">cover:</span> <span class="string">&quot;封面&quot;</span></span><br><span class="line">    <span class="attr">lrc:</span> <span class="string">&quot;歌词&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;曲目2&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;播放地址&quot;</span></span><br><span class="line">    <span class="attr">artist:</span> <span class="string">&quot;艺术家&quot;</span></span><br><span class="line">    <span class="attr">cover:</span> <span class="string">&quot;封面&quot;</span></span><br><span class="line">    <span class="attr">lrc:</span> <span class="string">&quot;歌词&quot;</span></span><br></pre></td></tr></table></figure>

<p>多列表</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">audio:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">列表1</span></span><br><span class="line">      <span class="attr">list:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;曲目1&quot;</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">&quot;播放地址&quot;</span></span><br><span class="line">          <span class="attr">artist:</span> <span class="string">&quot;艺术家&quot;</span></span><br><span class="line">          <span class="attr">cover:</span> <span class="string">&quot;封面&quot;</span></span><br><span class="line">          <span class="attr">lrc:</span> <span class="string">&quot;歌词&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;曲目2&quot;</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">&quot;播放地址&quot;</span></span><br><span class="line">          <span class="attr">artist:</span> <span class="string">&quot;艺术家&quot;</span></span><br><span class="line">          <span class="attr">cover:</span> <span class="string">&quot;封面&quot;</span></span><br><span class="line">          <span class="attr">lrc:</span> <span class="string">&quot;歌词&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">title:</span> <span class="string">列表2</span></span><br><span class="line">      <span class="attr">list:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://music.163.com/#/playlist?id=2031842656</span></span><br></pre></td></tr></table></figure>

<p>如果要关闭当前页面的背景音乐播放器，则在文章 Front Matter 中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关闭背景音乐</span></span><br><span class="line"><span class="attr">audio:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<h1 id="随机图库"><a href="#随机图库" class="headerlink" title="随机图库"></a>随机图库</h1><ul>
<li><p>默认的图片列表位于 <code>&lt;root&gt;/themes/shoka/_images.yml</code> 中。<br>  使用了渣浪图库，使用一些上传工具，比如<a href="https://pic.gimhoy.com/" title="这里">这里</a><br>  上传后图片的链接是 <code>http://wx4.sinaimg.cn/large/6833939bly1gicmnywqgpj20zk0m8dwx.jpg</code> 。<br>  只需要新一行写上 <code>- 6833939bly1gicmnywqgpj20zk0m8dwx.jpg</code> 。</p>
<p>  如果想要自定义，则在 <code>&lt;root&gt;/source/_data/</code> 目录新建一个 <code>images.yml</code> 文件，这个文件中的图片至少 6 枚，将完全覆盖默认的图片列表。</p>
</li>
<li><p>也可以直接在图片列表 yml 文件中，写上任意外链图片地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">https://i.loli.net/2020/10/30/qAMYEFXxJcKRsiG.gif</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">https://i.loli.net/2020/10/30/rjdhcSgEN8COBPA.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">https://i.loli.net/2020/10/30/HKyzSd7NI3mlBpt.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">https://i.loli.net/2020/10/30/Y1CBXqgeokEs457.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">https://i.loli.net/2020/10/30/Z5W6r2BSoiThHG1.jpg</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以在主题配置文件中，设置图床 API：</p>
</li>
</ul>
<p>比如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image_server:</span> <span class="string">&quot;https://acg.xydwz.cn/api/api.php&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="加载第三方组件"><a href="#加载第三方组件" class="headerlink" title="加载第三方组件"></a>加载第三方组件</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">css:</span></span><br><span class="line">    <span class="comment"># 略略略</span></span><br><span class="line">  <span class="attr">js:</span></span><br><span class="line">    <span class="comment"># 略略略</span></span><br></pre></td></tr></table></figure>

<p>包括</p>
<table><tbody><tr><td><code>pace</code></td><td>加载进度条</td><td>全局</td></tr><tr><td><code>pjax</code></td><td>页面无刷新加载</td><td>全局</td></tr><tr><td><code>anime</code></td><td>js 动画效果</td><td>全局</td></tr><tr><td><code>algolia</code> <code>instantsearch</code></td><td>基于 algolia 的站内搜索</td><td>全局</td></tr><tr><td><code>lazyload</code></td><td>图片懒加载</td><td>全局</td></tr><tr><td><code>quicklink</code></td><td>链接资源预加载</td><td>全局</td></tr><tr><td><code>fetch</code></td><td>获取播放列表</td><td>全局</td></tr><tr><td><code>katex</code> <code>copy_tex</code></td><td>数学公式显示及复制</td><td>按需</td></tr><tr><td><code>fancybox</code></td><td>图片放大显示及排列</td><td>按需</td></tr><tr><td><code>valine</code></td><td>基于 LeanCloud 的评论系统及文章阅读次数统计</td><td>按需</td></tr><tr><td><code>chart</code></td><td>图表显示</td><td>按需</td></tr></tbody></table>

<p>以上文件加载全部基于 jsDelivr，并对全局加载的组件进行了文件合并。<br>如果不明白啥意思，则不要轻易修改。</p>
<blockquote>
<p>主题版本升级的时候，可能会修改这里。<br>如果修改过主题默认 <code>_config.yml</code> ，记得更新主题时，末尾的 <code>vendors</code> 也要及时修改。</p>
</blockquote>
<p>本文作者： Ruri Shimotsuki @優萌初華<br>本文链接： <a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/">https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Shoka</tag>
      </tags>
  </entry>
  <entry>
    <title>Shoka 主题使用教程：Step.5 自定义优化技巧</title>
    <url>/posts/9176777a.html</url>
    <content><![CDATA[<p>这里是 Shoka 主题的自定义优化技巧，不是官方的。</p>
<span id="more"></span>

<h2 id="关闭复制的时候出现版权信息"><a href="#关闭复制的时候出现版权信息" class="headerlink" title="关闭复制的时候出现版权信息"></a>关闭复制的时候出现版权信息</h2><p>文件路径：<code>themes/shoka/source/js/_app/page.js</code>,<br>注释掉以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> copyright = $(<span class="string">&#x27;#copyright&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>().<span class="property">length</span> &gt; <span class="number">30</span> &amp;&amp; copyright) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">var</span> author = <span class="string">&quot;# &quot;</span> + copyright.<span class="title function_">child</span>(<span class="string">&#x27;.author&#x27;</span>).<span class="property">innerText</span></span><br><span class="line">  <span class="keyword">var</span> link = <span class="string">&quot;# &quot;</span> + copyright.<span class="title function_">child</span>(<span class="string">&#x27;.link&#x27;</span>).<span class="property">innerText</span></span><br><span class="line">  <span class="keyword">var</span> license = <span class="string">&quot;# &quot;</span> + copyright.<span class="title function_">child</span>(<span class="string">&#x27;.license&#x27;</span>).<span class="property">innerText</span></span><br><span class="line">  <span class="keyword">var</span> htmlData = author + <span class="string">&quot;&lt;br&gt;&quot;</span> + link + <span class="string">&quot;&lt;br&gt;&quot;</span> + license + <span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span> + <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\r\n/g</span>, <span class="string">&quot;&lt;br&gt;&quot;</span>);;</span><br><span class="line">  <span class="keyword">var</span> textData = author + <span class="string">&quot;\n&quot;</span> + link + <span class="string">&quot;\n&quot;</span> + license + <span class="string">&quot;\n\n&quot;</span> + <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\r\n/g</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">clipboardData</span>) &#123;</span><br><span class="line">      event.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text/html&quot;</span>, htmlData);</span><br><span class="line">      event.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text/plain&quot;</span>, textData);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">clipboardData</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>, textData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Shoka</tag>
      </tags>
  </entry>
  <entry>
    <title>Shoka 主题使用教程：Step.3 界面显示</title>
    <url>/posts/59273b39.html</url>
    <content><![CDATA[<h1 id="首页置顶文章"><a href="#首页置顶文章" class="headerlink" title="首页置顶文章"></a>首页置顶文章</h1><p>在文章的 Front Matter 设置 <code>sticky: true</code> ，则该文章将显示在首页最上方的 <code>置顶文章</code> 列。<br>多篇文章按照发布时间倒序排列，不分页。</p>
<span id="more"></span>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">置顶文章</span></span><br><span class="line"><span class="attr">sticky:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<h1 id="首页精选分类"><a href="#首页精选分类" class="headerlink" title="首页精选分类"></a>首页精选分类</h1><p>想要在首页显示分类翻转块，需要按照以下示例的方式，给需要显示的分类加上封面图。</p>
<p>首先，修改站点配置：<br>找到 <code>category_map</code>: ，配置每个分类对应的英文映射，比如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">计算机科学:</span> <span class="string">computer-science</span></span><br><span class="line">  <span class="attr">Java:</span> <span class="string">java</span></span><br><span class="line">  <span class="string">C++:</span> <span class="string">cpp</span></span><br><span class="line">  <span class="string">二进制杂谈:</span> <span class="string">note</span></span><br><span class="line">  <span class="string">计算机程序设计（C++）-西安交通大学:</span> <span class="string">course-1</span></span><br><span class="line">  <span class="string">零基础学Java语言-浙江大学-翁恺:</span> <span class="string">course-1</span></span><br><span class="line">  <span class="string">面向对象程序设计-Java语言-浙江大学-翁恺:</span> <span class="string">course-2</span></span><br><span class="line"><span class="string">```</span>  </span><br><span class="line"><span class="string">&gt;</span> <span class="string">注意：hexo</span> <span class="string">会自动处理路径中的特殊字符，~!@#$%^&amp;*()-_+=&#123;&#125;|\;:&quot;&#x27;&lt;&gt;,.?</span> <span class="string">以及空格，这些全部会被替换成</span> <span class="string">`-`</span></span><br><span class="line"><span class="string">所以避免在设置中使用上述字符，否则可导致无法抓取到目录下的</span> <span class="string">`cover.jpg`</span></span><br><span class="line"></span><br><span class="line"><span class="string">在</span> <span class="string">`&lt;root&gt;/source/_posts`</span> <span class="string">文件夹相应的目录里，存放封面图</span></span><br><span class="line"><span class="string">例子：如</span> [<span class="string">第</span> <span class="number">1</span> <span class="string">周</span> <span class="string">计算</span>]<span class="string">(https://shoka.lostyu.me/computer-science/java/course-1/week-1/)</span> <span class="string">这篇文章。</span></span><br><span class="line"><span class="string">所处的分类是</span></span><br><span class="line"><span class="string">```yaml</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">计算机科学</span>, <span class="string">Java</span>, <span class="string">零基础学Java语言-浙江大学-翁恺</span>]</span><br></pre></td></tr></table></figure>
<p>现在需要在首页显示 <code>零基础学Java语言-浙江大学-翁恺</code> 这个分类，翻转卡片后，显示这个分类下的文章们。<br>而该分类经过英文映射，它的路径将是 <code>/computer-science/java/course-1/</code> 。</p>
<p>那么，请在 <code>&lt;root&gt;/source/_posts/computer-science/java/course-1/</code> 的目录下放置 <code>cover.jpg</code> 文件。<br>只要 分类路径 对应的目录下存在 <code>cover.jpg</code> 文件，这个分类就会在首页显示。<br>在进行 <code>hexo </code>g 时，本分类的封面图会自动被复制到 public 目录里相应的位置。</p>
<p>事实上，为了方便文章管理，这个分类下所有文章的 md 文件，我都会放在 <code>&lt;root&gt;/source/_posts/computer-science/java/course-1/</code> 这个目录下。</p>
<p>且站点配置文件里，永久链接设置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure>
<p><code>hexo g</code> 后，文章的 html 文件们将全部生成到 <code>&lt;root&gt;/public/computer-science/java/course-1/</code> 目录。<br>具体可以查看<a href="https://github.com/amehime/shoka">本博客的 github 仓库</a>。</p>
<p>文章详情界面中的 系列文章 ，显示的是与当前文章同一分类的其他文章，并按照文章名正序排序。</p>
<blockquote>
<p>o (<em>￣▽￣</em>) ゞ<br>其实，不设置 <code>category_map</code> 也可以，只要在分类路径对应的文件夹下存在 <code>cover.jpg</code> 文件就行。<br>现在，这项功能与 <code>category_dir</code> 的配置也无关， <code>hexo g</code> 生成后，图片会自动被转移到 <code>category_dir</code> 的相关子目录下。</p>
</blockquote>
<h1 id="文章封面图"><a href="#文章封面图" class="headerlink" title="文章封面图"></a>文章封面图</h1><p>如果文章的 Front Matter 设置了 <code>cover: image path</code> ，则封面会显示这张图片。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Images</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">assets/wallpaper-2572384.jpg</span></span><br><span class="line"><span class="comment"># 或者写成</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">http://placehold.it/350x150.jpg</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>cover</code> 的值可以是位于 <code>source</code> 目录里的图片文件，此处是 <code>&lt;root&gt;/source/assets/wallpaper-2572384.jpg</code> 文件，也可以是一个某网址。</p>
<p>如果文章是一个 <code>gallery post</code> ，即 Front Matter 设置了 <code>photos</code> ，则会封面会显示设置的第一张图片。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Gallery</span> <span class="string">Post</span></span><br><span class="line"><span class="attr">photos:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">assets/wallpaper-2572384.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">assets/wallpaper-2311325.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">assets/wallpaper-878514.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">http://placehold.it/350x150.jpg</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>此时默认会显示第一个图片，即位于 <root>&#x2F;source&#x2F;assets&#x2F; 目录里的 wallpaper-2572384.jpg 。</p>
<p>如果站点配置中设置了 post_asset_folder: true ，那么上述本地图片路径应为 <root>&#x2F;source&#x2F;_posts&#x2F;文章同名的文件夹&#x2F;assets&#x2F;wallpaper-2572384.jpg ，当然此时 assets 目录可以省掉。</p>
<p>如果以上设置均不存在，将显示一张随机图片，<a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/#%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%93">随机图库配置戳此</a>。</p>
<h1 id="图片展示与相册"><a href="#图片展示与相册" class="headerlink" title="图片展示与相册"></a>图片展示与相册</h1><p>在文章的 Front Matter 设置 fancybox: false ，可以关闭文章页的图片展示功能。<br>使用 Justified-Gallery 对 Gallery Post 内图案进行排列。</p>
<p>下面介绍一些小技巧：</p>
<p>让图案下方显示 title 的 markdown 代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![这里是 alt](https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg &quot;这里是 title&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg" alt="这里是 alt" title="这里是 title"></p>
<p>设置图片的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg &quot;定义图片大小 - 固定宽度和高度&quot;)&#123;height=&quot;100px&quot; width=&quot;400px&quot;&#125;</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg &quot;定义图片大小 - 固定宽度&quot;)&#123;width=&quot;400px&quot;&#125;</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg &quot;定义图片大小 - 固定高度&quot;)&#123;height=&quot;100px&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg" title="定义图片大小 - 固定宽度和高度">{height&#x3D;”100px” width&#x3D;”400px”}<br><img src="https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg" title="定义图片大小 - 固定宽度">{width&#x3D;”400px”}<br><img src="https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg" title="定义图片大小 - 固定高度">{height&#x3D;”100px”}</p>
<p>除了在 Front Matter 里配置 photos 可以显示相册图案列表外，还可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 图案列表 No.1</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg &quot;这里是 title&quot;)</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg)</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg)</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg)</span><br><span class="line">&#123;.gallery&#125;</span><br><span class="line">## 图案列表 No.2</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg)</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg)</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg)</span><br><span class="line">![](https://tva3.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg)</span><br><span class="line">&#123;.gallery data-height=&quot;120&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>data-height 用来设置每行的高度，默认为 220</p>
<h2 id="图案列表-No-1"><a href="#图案列表-No-1" class="headerlink" title="图案列表 No.1"></a>图案列表 No.1</h2><p><img src="https://tva3.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg" title="这里是 title"><br><img src="https://tva3.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"><br><img src="https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"><br><img src="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"><br>{.gallery}</p>
<h2 id="图案列表-No-2"><a href="#图案列表-No-2" class="headerlink" title="图案列表 No.2"></a>图案列表 No.2</h2><p><img src="https://tva3.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"><br><img src="https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"><br><img src="https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"><br><img src="https://tva3.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg"><br>{.gallery data-height&#x3D;”120”}</p>
<h1 id="自定义页面配色"><a href="#自定义页面配色" class="headerlink" title="自定义页面配色"></a>自定义页面配色</h1><p>主题配色全部在 <root>&#x2F;themes&#x2F;shoka&#x2F;source&#x2F;css&#x2F;_colors.styl 文件中，可以自行查看。</p>
<p>在 <root>&#x2F;source&#x2F;_data&#x2F; 目录新建文件 colors.styl ，在此文件中添改样式。</p>
<blockquote>
<p>自定义 colors.styl 文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。</p>
</blockquote>
<p>主题支持在 <root>&#x2F;source&#x2F;_data&#x2F; 目录建立三个自定义 styl 文件：</p>
<table>
<thead>
<tr>
<th>自定义文件名</th>
<th>对应默认样式文件</th>
<th>样式功能</th>
</tr>
</thead>
<tbody><tr>
<td>colors.styl</td>
<td>_colors.styl</td>
<td>页面配色</td>
</tr>
<tr>
<td>iconfont.styl</td>
<td>_iconfont.styl</td>
<td>图标样式</td>
</tr>
<tr>
<td>custom.styl</td>
<td>-</td>
<td>任意自定义样式</td>
</tr>
</tbody></table>
<h1 id="自定义主题图片"><a href="#自定义主题图片" class="headerlink" title="自定义主题图片"></a>自定义主题图片</h1><p>如果想要修改主题的 <root>&#x2F;themes&#x2F;shoka&#x2F;source&#x2F;images&#x2F; 目录内的某张图片，请在 <root>&#x2F;source&#x2F;_data&#x2F; 目录新建目录 images ，并在这个文件夹中添加同名文件，部署时将自动覆盖主题内的默认图片。</p>
<p>可以用此方法自定义头像、打赏二维码等图片，并且避免覆盖更新主题时遗失自定义文件。</p>
<h1 id="自定义语言包"><a href="#自定义语言包" class="headerlink" title="自定义语言包"></a>自定义语言包</h1><p>本功能参考 NexT，主要可以用来定义菜单等处显示的文字，且可以方便主题无脑覆盖升级。</p>
<p>在 <root>&#x2F;source&#x2F;_data&#x2F; 目录新建文件 languages.yml 。</p>
<p>按照以下格式添加配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># language</span></span><br><span class="line"><span class="attr">zh-CN:</span></span><br><span class="line">  <span class="comment"># items</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">copyright:</span></span><br><span class="line">      <span class="comment"># the translation you perfer</span></span><br><span class="line">      <span class="attr">author:</span> <span class="string">本文博主</span></span><br><span class="line"><span class="attr">en:</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">travellings:</span> <span class="string">Travellings</span></span><br></pre></td></tr></table></figure>
<p>可以参考主题目录下的 example&#x2F;source&#x2F;_data 文件夹。</p>
<blockquote>
<p>站点配置及文件的 Front Matter 中， language 项只支持 zh-CN 、 zh-HK 、 zh-TW 、 ja 、 en 。<br>类似写成 zh_CN 这样是不可以的。</p>
</blockquote>
<p>本文作者： Ruri Shimotsuki @優萌初華<br>本文链接： <a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/">https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Shoka</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <url>/posts/d213c60c.html</url>
    <content><![CDATA[<p>今天看了一篇关于TCP三次握手和四次挥手的博文，经不住喜爱，特意把文章COPY下来了。<a href="https://blog.csdn.net/wwl012345/article/details/90261423">原文传送门</a></p>
<p>TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP的运输连接有三个过程，即建立连接、数据传输和连接释放。</p>
<span id="more"></span>

<p>TCP连接建立过程中要解决以下三个问题：</p>
<ul>
<li>1.要使每一方都能够确认对方的存在。</li>
<li>2.要允许双方协商一些参数</li>
<li>3.能够对运输实体资源进行分配</li>
</ul>
<p>TCP连接的建立采用客户机／服务器模式，主动发起连接建立的应用进程叫做客户机，而被动等待连接建立的应用进程叫做服务器。</p>
<p>TCP的连接建立：<br><img src="https://img2020.cnblogs.com/blog/955921/202104/955921-20210406164857647-1421360202.png" alt="image"></p>
<p>１.首先，客户机与服务器的TCP进程都处于CLOSED（关闭）状态，当要进行TCP连接时，客户机主动打开连接，服务器被动打开连接（这是因为服务请求总是由客户机向服务器发起，因为想要请求的资源都在服务器上，所以客户机想要获取资源就必须主动向服务器发起请求，而不能是等待服务器向自己（客户机）发起请求）。</p>
<p>２.然后，服务器的TCP进程先创建传输控制块TCB（传输控制块TCB存储了每一个连接中的重要信息，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号，等等），此时，服务器就处于LISTEN（收听）状态。同样的，客户机也会首先创建一个传输控制块TCB发送给服务器。这样，准备工作就做好了。</p>
<p>３.现在就可以开始真正的三次握手了。首先，客户机先向服务器发送连接请求报文段，该报文段中将首部中的同步位SYN置为１（只有当SYN置为１时，才能表明客户机想要和服务器建立连接），并且随机选择一个初始序号ｘ，注意此时的SYN数据报中并没有携带数据，但是仍旧要消耗掉一个序号（意思就是下次客户机发送数据的时候，序号为x+１），此时客户机进入到SYN-SENT（同步已发送）状态。</p>
<p>４.此时，服务器收到客户机的请求时，如果同意与该客户机进行连接，则需要向客户机发送确认报文。在发送报文中需要将SYN与ACK都置为１（当ACK置为1时，表明服务器同意与客户机进行连接；同时将SYN置为1，表明服务器想要和客户机建立连接），并且随机选择一个初始序号y，确认号为x+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了x，所以下一个序号为x+1），注意此时的SYN数据报中并没有携带数据，但是也要消耗掉一个序号（同样的，也就是说服务器下次发送数据的时候，序号为y+1），此时TCP服务器进程进入到SYN-RCVD（同步收到）阶段。</p>
<p>顺便提一句，在这两个阶段会发送SYN　Flooding攻击。</p>
<p>5.TCP客户端收到服务器的确认后，还要再向服务器给出确认。确认报文段中ACK置为1，确认号为ack&#x3D;y+1(因为之前服务器给客户机发送的序号为y，因此现在客户机向服务器发送的确认号为ack&#x3D;y+1，意思是客户机渴望收到的下一个报文段的第一个数据字节为y+1)此时客户机的发送序号为x+1（这是因为刚才刚才客户机向服务器发送连接请求时消耗了序号x，因此此时的序号为x+1）注意：在进行第三次握手时，ACK报文段可以携带数据，也可以不携带数据，如果携带数据，则消耗一个序列，这样客户机下次发送报文段时的序号为x+2，如果不携带数据则不消耗序号，下次客户机发送报文段时的序号为x+1。这时TCP连接已经建立，客户机和服务器都进入到ESTABLISHED（已建立连接）状态。</p>
<p>其实上面的三次握手实质上就相当于是下列的对话：</p>
<p>－客户机：服务器，我想要和你建立连接，你同意吗？（SYN＝１）</p>
<p>－服务器：客户机，我同意和你建立连接（ACK＝１）；我也想和你建立连接，你同意吗？（SYN＝１）</p>
<p>－客户机：服务器，我同意和你建立连接。（ACK＝１）</p>
<p>其实，在进行第二次握手时（即服务器向客户机进行应答时），可以看作时发了两次包，先回答客户机的服务请求（ACK＝１，ａｃｋ＝x+１），然后再向客户机发出请求（SYN＝１，ｓｅｑ＝ｙ）</p>
<p>常见面试问题：</p>
<p>问：三次握手中，为什么客户机最后还要再向服务器发送一次确认呢？</p>
<p>答：这是为了防止已失效的连接请求报文段突然又传到了服务器。所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常的情况，客户机发出连接请求，但因为连接请求报文丢失而未收到确认。于是客户机再重传了一次连接请求，后来收到了确认，建立了连接。数据传输完后，就释放了连接。客户机共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器，没有所谓的“已失效的连接请求报文段”。</p>
<p>但是如果出现了一种异常情况，即客户机发出的第一个报文段并没有丢失，而是在某个节点上长时间滞留了，直至客户机向服务器发送了第二个报文段并且已经完成数据传输释放了连接，此时，第一个报文到达服务器后会被误以为是客户机重新发起的一次连接请求，实质上是一个早已失效的连接请求。如果没有第三次握手，那么这个连接就建立了，但是客户机并不会向服务器发送任何请求，这样连接就会一直持续，白白的消耗网络资源。</p>
<p>TCP的连接释放：<br><img src="https://img2020.cnblogs.com/blog/955921/202104/955921-20210406164922288-1940126940.png" alt="image"></p>
<p>１.数据传输结束后，通信的双方都可以释放连接。此时，客户机和服务器都处于ESTABLISHED（已建立连接）状态。</p>
<p>２.假设客户机请求完资源了，想要释放连接。首先，客户机的应用进程先向服务器发出连接释放报文段，该报文段中将首部的终止控制位FIN置为１（只有当FIN置为１时，才能表明客户机想要和服务器断开连接），并且序号为ｕ（注意：此时的ｕ不是随机产生的，而是之前客户机传送的数据的最后一个字节的序号加１）。此时客户机进入到FIN－WAIT－１（终止等待１）状态，等待服务器的确认。</p>
<p>３.服务器收到连接释放报文后发出确认，在发送报文中将首部中的ACK置为１（ACK置为１，表面服务器同意与客户机释放连接），并且产生序号ｖ（注意：此时的v不是随机产生的，而是之前服务器传送的数据的最后一个字节的序号加１），并且发出确认号为u+１（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了u，所以下一个序号为u+1）。此时服务器就进入CLOSE－WAIT（关闭等待）状态，客户机进入FIN-WAIT-2状态。</p>
<p>此时，从客户机到服务器这个方向的连接就被释放了，也就是说，客户机已经没有数据要向服务器发送了，但是如果服务器向客户机发送数据，客户机仍要接收数据。也就是说：从客户机到服务器的连接已经被释放了，但是从服务器到客户机的连接还没被释放。此时，TCP连接处于半关闭状态。</p>
<p>4.如果服务器向客户机也没有要发送的数据的话，那么服务器的应用进程就可以向客户机发出连接释放报文段（注意此时还是服务器向客户机发送数据），该报文段中将首部的终止控制位FIN置为1（只有当FIN置为１时，才能表明客户机想要和服务器断开连接），ACK也置为1，并且序号为w（重点注意，此时的w不一定等于v+1。如果在客户机释放了连接之后，服务器向客户机仍旧发送了一部分数据，那么此时w不等于v+1，但是如果期间没有再发送数据，那么w就等于v+1。总而言之，这个w等于服务器上一次发送的数据的最后一个字节加1），并且发送确认号为u+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了u，所以下一个序号为u+1）。此时服务器就进入了LAST-ACK（最后确认）状态。</p>
<p>5.客户机收到服务器的连接释放报文后，必须对此报文进行确认。在该报文段中将ACK置为1，确认号为w+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了w，所以下一个序号为w+1），产生序号为u+1（因为上一个发送的数据的序号为u）。此时服务器进入到TIME-WAIT（等待时间）状态。但是，此时TCP连接还没有被释放掉。必须经过2MSL后服务器才能进入到CLOSED状态。（注：MSL叫做最长报文段寿命，RFC建议为两分钟，也就是说，要经过四分钟才能进入到CLOSED状态）。</p>
<p>其实上面的四次挥手实质上就相当于是下列的对话：</p>
<p>-客户机：服务器，我想和你断开连接，你同意吗？（FIN&#x3D;1）</p>
<p>-服务器：我同意（ACK&#x3D;1）</p>
<p>（在此期间，服务器可能还会向客户机发送数据，但是客户机却不能再向服务器发送数据）</p>
<p>-服务器：客户机，我想要和你断开连接，你同意吗？（FIN&#x3D;1）</p>
<p>-客户机：我同意。（ACK&#x3D;1）</p>
<p>再等待2MSL时间后就真正断开了连接。</p>
<p>常见面试问题：</p>
<p>问：为什么客户机发送完最后一个数据后要在TIME-WAIT状态等待 2MSL（四分钟）的时间呢？</p>
<p>答：第一：为了保证客户机最后发送的那个ACK报文段能够到达服务器。这个ACK报文段可能会丢失。因而使处在LAST-ACK状态的B收不到对已发送的FIN＋ACK报文段的确认。服务器会超时重传这个FIN＋ACK报文段，而客户机就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着客户机重传一次确认，重新启动2MSL计时器，最后客户机和服务器都可以进入到CLOSED（关闭）状态。如果没有2MSL等待时间，那么就无法收到重传的FIN+ ACK包，无法进入正常的CLOSED状态。</p>
<p>第二，防止“已失效的连接请求报文段”出现在本连接中。客户机在发送完最后一个ACK报文段，再经过时间2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 相关资料（未整理）</title>
    <url>/posts/36eef1d8.html</url>
    <content><![CDATA[<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://start.spring.io&size=32"> <a href="https://start.spring.io/">Spring Initializr</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=tomcat%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B&oq=tomcat&rsv_pq=e4b616100020b44c&rsv_t=b27bV6tuL8tkeRVtAnl3+LClQK8lFQ5ZvRM4LPl0NBgjyKXEa8/FXm/MShM&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_btype=t&rsv_sug3=8&rsv_sug1=10&rsv_sug7=100&rsv_sug2=1&prefixsug=tomcat&rsp=0&rsv_sug4=3622">tomcat安装及配置教程_百度搜索</a></p>
<span id="more"></span>



<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://cnblogs.com&size=32"> <a href="https://www.cnblogs.com/022414ls/p/16418740.html">Tomcat安装及配置教程 - 谜语+ - 博客园</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://apache.org&size=32"> <a href="https://tomcat.apache.org/download-80.cgi">Apache Tomcat® - Apache Tomcat 8 Software Downloads</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_40527797/article/details/122813537">(20条消息) springBoot+JSP搭建项目_那清澈的漓江的博客-CSDN博客_springboot+jsp</a></p>
<p><img src="https://www.one-tab.com/web/images/default-bookmark-icon.png"> <a href="http://localhost:8080/demo/">HTTP状态 404 - 未找到</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/superfreak/article/details/115212488">(20条消息) 手把手教你：SpringBoot开发JSP_superfreak的博客-CSDN博客_springbootjsp开发</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/superfreak/article/details/115082381">(20条消息) 手把手教你：创建一个SpringBoot项目并打包为war_superfreak的博客-CSDN博客</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_36182135/article/details/81507639">(20条消息) Spring Boot（一）： 快速构建web项目_方木丶的博客-CSDN博客_springboot创建web项目</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/weixin_56281219/article/details/117121783?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117121783-blog-122772127.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117121783-blog-122772127.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=2">(20条消息) springboot搭建web项目完整步骤(简易，一看就会！)_不想掉头发+1的博客-CSDN博客_springbootweb项目</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd=tomcat%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%5B/demo-0.0.1-SNAPSHOT/%5D%E4%B8%8D%E5%8F%AF%E7%94%A8&oq=%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E8%25B5%2584%25E6%25BA%2590%255B%252Fdemo-0.0.1-SNAPSHOT%252F%255D%25E4%25B8%258D%25E5%258F%25AF%25E7%2594%25A8&rsv_pq=d2623d2d004461d5&rsv_t=ac958VzvbGkIZN55nJiD5Ld6AMr6Zf/LUtJVmiaticSJKMSDi38wpsu+OOY&rqlang=cn&rsv_enter=0&rsv_dl=tb&rsv_btype=t&inputT=3173&rsv_sug3=17&rsv_sug2=0&prefixsug=tomcat%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E8%25B5%2584%25E6%25BA%2590%255B%252Fdemo-0.0.1-SNAPSHOT%252F%255D%25E4%25B8%258D%25E5%258F%25AF%25E7%2594%25A8&rsp=1&rsv_sug4=4269">tomcat请求的资源[&#x2F;demo-0.0.1-SNAPSHOT&#x2F;]不可用_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://kaotop.com&size=32"> [Tomcat出现404的解决方法[类型 状态报告 消息 请求的资源[&#x2F;]不可用 描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源]_Linux-考高分网](<a href="http://www.kaotop.com/it/914810.html">http://www.kaotop.com/it/914810.html</a>)</p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://656463.com&size=32"> <a href="https://www.656463.com/wenda/TomcatqqdzybkyIntelliJIDEAJavaEE_263">Tomcat - 请求的资源不可用 - IntelliJ IDEA - Java EE [重复](Tomcat - The requested resource is not available - IntelliJ IDEA - Java EE [duplicate])_电脑培训</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> [(20条消息) Tomcat出现404的解决方法[类型 状态报告 消息 请求的资源[&#x2F;]不可用 描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源]_代码匪徒的博客-CSDN博客_tomcat404请求的资源不可用](<a href="https://blog.csdn.net/munangs/article/details/120259865">https://blog.csdn.net/munangs/article/details/120259865</a>)</p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_40306266/article/details/116563024?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-116563024-blog-120259865.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-116563024-blog-120259865.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">(20条消息) tomcat运行web项目报错：请求的资源[&#x2F;]不可用_你知道爬上树的感觉吗的博客-CSDN博客_tomcat请求的资源不可用</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> [(20条消息) Tomcat出现404的解决方法[类型 状态报告 消息 请求的资源[&#x2F;]不可用 描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源]_代码匪徒的博客-CSDN博客_tomcat404请求的资源不可用](<a href="https://blog.csdn.net/munangs/article/details/120259865?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-120259865-blog-116563024.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-120259865-blog-116563024.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">https://blog.csdn.net/munangs/article/details/120259865?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120259865-blog-116563024.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120259865-blog-116563024.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=2</a>)</p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://pianshen.com&size=32"> <a href="https://www.pianshen.com/article/50601950656/">SpringBoot项目打war包2种方法 - 程序员大本营</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/Luo_Tuo/article/details/108734675">(20条消息) SpringBoot项目打war包2种方法_Luo_Tuo的博客-CSDN博客_springboot 打war包命令</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://cnblogs.com&size=32"> <a href="https://www.cnblogs.com/dengsir39/p/16496813.html">IDEA中web项目打成war包并在本地tomcat部署(超细版) - 艾码的日常生活 - 博客园</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://zoukankan.com&size=32"> <a href="http://t.zoukankan.com/dsn727455218-p-11363458.html">IDEA中将工程打包成war包及部署到Tomcat流程 - 走看看</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/weixin_50596156/article/details/114284993">(20条消息) 使用idea打包war包部署_Mr°卢的博客-CSDN博客_idea打war包部署</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/weixin_38560145/article/details/86530401?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-86530401-blog-114284993.t5_download_0_7w&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-86530401-blog-114284993.t5_download_0_7w&utm_relevant_index=1">(20条消息) idea中项目打war包的方式_小姜戈的博客-CSDN博客_idea打war包方式</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/jiong9412/article/details/126551794">(20条消息) war包部署到Tomcat下运行步骤_无薪法师的博客-CSDN博客_war包部署到tomcat如何启动</a></p>
<p><img src="https://www.one-tab.com/web/images/default-bookmark-icon.png"> <a href="http://localhost:9090/">Title</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd=springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90war%E5%8C%85%E9%83%A8%E7%BD%B2%E5%88%B0tomcat%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98&oq=idea%25E5%259C%25A8%25E6%2589%2593war%25E5%258C%2585%25E4%25B9%258B%25E5%2589%258D%25E9%259C%2580%25E8%25A6%2581%25E4%25BF%25AE%25E6%2594%25B9%25E4%25BB%2580%25E4%25B9%2588&rsv_pq=952d2a95004aa4a4&rsv_t=7deetCMSsKkBq6MaGJP+Ca2v8xipFyCiLZmiCLf6WY/5mzkXBURfFOiO/d0&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_btype=t&inputT=811&rsv_n=2&rsv_sug3=24&rsv_sug1=25&rsv_sug7=100&rsv_sug2=0&rsv_sug4=811">springboot项目打成war包部署到tomcat遇到的一些问题_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/m0_67392409/article/details/123683958">(20条消息) springboot打war包部署到tomcat后无法访问的解决方法_普通网友的博客-CSDN博客_tomcat运行war包后无法访问</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://wjhsh.net&size=32"> <a href="http://wjhsh.net/wangxuemei-p-8360398.html">IDEA 工具项目的配置及如何打war包</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/wupan6688/article/details/103629664">(20条消息) springboot项目用maven打包生成的.jar.original是什么？_清风烈酒的博客-CSDN博客_jar.original</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=UTF-8&wd=tomcat10%E5%85%BC%E5%AE%B9java8%E5%90%97">tomcat10兼容java8吗_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://thinbug.com&size=32"> <a href="https://www.thinbug.com/q/46859797">java - 哪个tomcat版本适合java 8 - Thinbug</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=UTF-8&wd=idea%E6%89%93%E5%8C%85war%E5%8C%85%EF%BC%8Ctomcat%E9%83%A8%E7%BD%B2%E8%AE%BF%E9%97%AE%E5%87%BA%E7%8E%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%5B/demo-0.0.1-SNAPSHOT/%5D%E4%B8%8D%E5%8F%AF%E7%94%A8">idea打包war包,tomcat部署访问出现请求的资源[&#x2F;demo-0.0.1-SNAPSHOT&#x2F;]不可用_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://ask.csdn.net/questions/7597551?locationNum=5">(20条消息) Java idea打包war包部署到tomcat无法访问-Java-CSDN问答</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=UTF-8&wd=%E9%85%8D%E7%BD%AE%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E6%98%A0%E5%B0%84">配置下静态资源访问路径的映射_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://cnblogs.com&size=32"> <a href="https://www.cnblogs.com/KJXY/articles/15133988.html">Springboot 静态资源路径虚拟映射配置 - KJXY - 博客园</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/Acer2016/article/details/103530287">(20条消息) IntelliJ IDEA 项目打WAR包（步奏），部署到Tomcat（解决不能加载项目静态资源文件的方法）_BU凡的博客-CSDN博客_tomcat部署war包找不到文件</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd=html%E6%80%8E%E4%B9%88%E7%94%A8tomcat%E9%83%A8%E7%BD%B2&oq=%2526%252339%253Borg.springframework.web.servlet.config.annotation.WebMvc%2526lt%253Bonfigurer%2526%252339%253B%2520%25E4%25B8%258D%25E6%2598%25AF%25E5%25B0%2581&rsv_pq=daba554b0068fbf5&rsv_t=5057MOdpQlXa16CnjPZ+zTuDN+bmOdBuG6dHNRK7rvM3ATJ1TSF2i8IOJWs&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=18&rsv_sug1=17&rsv_sug7=101&rsv_sug2=0&rsv_btype=t&inputT=9145&rsv_sug4=11616">html怎么用tomcat部署_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/wqs147258/article/details/116167807">(20条消息) HTML页面部署到Tomcat_manson欧文的博客-CSDN博客_html部署到tomcat</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://cnblogs.com&size=32"> <a href="https://www.cnblogs.com/zj-0909/p/15108419.html">Tomcat部署html静态网站的五种方式 - 屠剑 - 博客园</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/wuyomhchang/article/details/123640035">(20条消息) tomact上部署HTML静态页面的方法—教程超详细_吴永畅的博客-CSDN博客_tomcat部署静态html</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_32828777/article/details/105611542">(20条消息) SpringMVC之接口WebMvcConfigurer_像我这么帅的一般都是主角哦的博客-CSDN博客</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/prettyboy2ge/article/details/108470611?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-108470611-blog-105611542.pc_relevant_multi_platform_whitelistv6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-108470611-blog-105611542.pc_relevant_multi_platform_whitelistv6&utm_relevant_index=2">(20条消息) SpringBoot 使用 WebMvcConfigurer接口或者WebMvcConfigureSupport定义静态资源地址不生效_朝阳前的黑暗的博客-CSDN博客</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_44503987/article/details/110806124">(20条消息) springboot解决WebMvcConfigurerAdapter失效问题_良木66的博客-CSDN博客_webmvcconfigureradapter不能用了</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_38164123/article/details/80392904?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80392904-blog-110806124.t5_download_comparev1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80392904-blog-110806124.t5_download_comparev1&utm_relevant_index=1">(20条消息) SpringBoot2.0 以上 WebMvcConfigurerAdapter 方法过时 解决办法_java_代码搬运工的博客-CSDN博客</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E9%83%A8%E7%BD%B2%E5%88%B0tomcat&rsf=100631202&rsp=0&f=1&rs_src=0&rsv_pq=db8943f8006d23dd&rsv_t=8aaeSdJBVK7dejPwd0h/nEAyeKjX9B6kxWO0ts3juYZYiSBcjBBshSEPoko">静态网页部署到tomcat_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/weixin_45046181/article/details/125031646">(20条消息) tomcat部署静态网页_漠上尘的博客-CSDN博客_tomcat部署静态页面</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://likecs.com&size=32"> <a href="https://www.likecs.com/show-204524070.html">Tomcat+solr 请求的资源[&#x2F;solr&#x2F;index.html]不可用 - 爱码网</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> [(20条消息) Tomcat出现404的解决方法[类型 状态报告 消息 请求的资源[&#x2F;]不可用 描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源]_代码匪徒的博客-CSDN博客_tomcat404请求的资源不可用](<a href="https://blog.csdn.net/munangs/article/details/120259865">https://blog.csdn.net/munangs/article/details/120259865</a>)</p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/munangs/article/details/120261733?spm=1001.2014.3001.5502">(20条消息) 配置javaweb 和tomcat环境和一些注意事项_代码匪徒的博客-CSDN博客</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_40306266/article/details/116563024?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-116563024-blog-120259865.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-116563024-blog-120259865.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">(20条消息) tomcat运行web项目报错：请求的资源[&#x2F;]不可用_你知道爬上树的感觉吗的博客-CSDN博客_tomcat请求的资源不可用</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=UTF-8&wd=tomcat%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Cwar">tomcat如何运行war_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/m0_54849873/article/details/124095072">(20条消息) war包部署到Tomcat下运行步骤_普通网友的博客-CSDN博客_tomcat运行war包</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_40062320/article/details/81393326?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-81393326-blog-124095072.topnsimilarv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-81393326-blog-124095072.topnsimilarv1&utm_relevant_index=5">(20条消息) 使用war包部署在Tomcat中运行_a xin-pc的博客-CSDN博客_war包部署到tomcat</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/inter_peng/article/details/42833587?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-9-42833587-blog-81393326.relrec_prioritylanding&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~ESLANDING~default-9-42833587-blog-81393326.relrec_prioritylanding&utm_relevant_index=16">(20条消息) 将Web项目War包部署到Tomcat服务器基本步骤_inter_peng的博客-CSDN博客_tomcat运行war包</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://baidu.com&size=32"> <a href="https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=eclipse%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&oq=eclipse%25E4%25B8%258B%25E8%25BD%25BD%25E6%2585%25A2&rsv_pq=e63b5d3c00182d61&rsv_t=97477L29jE5R86oIdHLevf7OPkGpNzq08R8uZlZG8Dh1TnSYCT7gBuoyu6s&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_btype=t&rsv_sug3=4&rsv_sug1=5&rsv_sug7=100&rsv_sug2=1&prefixsug=eclipse%25E5%25AE%2589%25E8%25A3%2585&rsp=0&inputT=2766&rsv_sug4=4963">eclipse安装教程_百度搜索</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_45344586/article/details/123942685">(20条消息) 超详细Eclipse安装教程_极小白的博客-CSDN博客_eclipse安装教程</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_38566465/article/details/79484286?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-79484286-blog-123942685.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-79484286-blog-123942685.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=5">(20条消息) Eclipse安装教程 ——最详细安装java_命里良人的博客-CSDN博客_eclipse安装教程</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://xierulucky.blog.csdn.net/article/details/82914600?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-82914600-blog-79484286.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-82914600-blog-79484286.pc_relevant_aa&utm_relevant_index=2">(20条消息) Eclipse最新最简最详细安装教程_rothschildlhl的博客-CSDN博客_eclipse安装教程</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://eclipse.org&size=32"> <a href="https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2022-09/R/eclipse-jee-2022-09-R-win32-x86_64.zip&mirror_id=1290">Thank You for Downloading Eclipse | The Eclipse Foundation</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/qq_51013944/article/details/116142472?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-116142472-blog-79484286.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-116142472-blog-79484286.pc_relevant_aa&utm_relevant_index=1">(20条消息) eclipse安装教程（2021最新版）超级易懂到吐血_肌肉猛男ing的博客-CSDN博客_eclipse安装教程</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://csdn.net&size=32"> <a href="https://blog.csdn.net/weixin_44963853/article/details/121688690">(20条消息) eclipse下载速度过慢的解决方法_一个写代码的骚年的博客-CSDN博客_eclipse下载慢</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://pianshen.com&size=32"> <a href="https://www.pianshen.com/article/9386748353/">www.pianshen.com</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://oschina.net&size=32"> <a href="https://www.oschina.net/p/eclipse?hmsr=aladdin1e1">Eclipse首页、文档和下载 - 跨平台开源集成开发环境 - OSCHINA - 中文开源技术交流社区</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://oschina.net&size=32"> <a href="https://www.oschina.net/news/118726/eclipse-4-17-released">Eclipse 4.17 稳定版发布 - OSCHINA - 中文开源技术交流社区</a></p>
<p><img src="https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://eclipse.org&size=32"> <a href="https://download.eclipse.org/eclipse/downloads/drops4/R-4.17-202009021800/">Not Found | The Eclipse Foundation</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>《人民日报》任仲平：三年抗疫，我们这样同心走过（ 2022年12月15日 01 版）</title>
    <url>/posts/afe25c5d.html</url>
    <content><![CDATA[<p>（一）</p>
<p>　　工厂车间，机器轰鸣；大街小巷，人来人往；公路铁路，车辆穿梭；超市商场，物丰价稳；广袤田野，生机勃勃……壬寅岁末，神州大地正升腾着澎湃活力，展现出万千气象。</p>
<span id="more"></span>



<p>　　事非经过不知难。回首过去近三年时间，我们进行了一场惊心动魄的抗疫大战，经历了一场艰苦卓绝的历史大考。有效处置百余起聚集性疫情，有效应对五波全球疫情的冲击，在病毒最凶猛的阶段有效保护14亿多人民的生命安全和身体健康……以习近平同志为核心的党中央始终坚持人民至上、生命至上，因时因势不断优化调整疫情防控措施，团结带领全党全国各族人民坚定不移开展抗击疫情斗争，统筹疫情防控和经济社会发展取得重大积极成果。</p>
<p>　　近三年来，我们以争分夺秒的速度，提升防控救治的能力，提升科学战疫的本领，等到了新冠病毒毒力、致病力的下降，迎来了疫苗接种的普及和人民群众健康意识的提升，赢得了抗击疫情的主动。</p>
<p>　　近三年来，我们以枕戈待旦的坚守，最大程度保护了人民群众生命安全，用最小的代价实现了最大的防控效果，为充分开发药物和疫苗创造了有利条件，迎来了全人群疫苗完全接种率超过90%，赢得了抗击疫情的优势。</p>
<p>　　近三年来，我们以风雨同舟的意志，淬炼抗击疫情的精神力量，无惧困难、砥砺前行，铸就了伟大抗疫精神，赢得了抗击疫情的信心。</p>
<p>　　大战大考炼真金。我们以防控战略的稳定性、防控措施的灵活性，有效应对疫情形势的不确定性。近三年鏖战，稳扎稳打、步步为营，病毒弱了、我们强了，疫情防控面临新形势新任务。从二十条到新十条，我们因时而动、顺势而为，抓住时机优化疫情防控政策，新的气象正在呈现，新的变化正在发生。面对世纪疫情，我们更有实力，更有底气，更有斗志！</p>
<p>　　抗疫斗争，最大程度保障了亿万人民的生命安全，最大程度创造了生产生活条件和投资发展环境，最大程度彰显了我国社会主义制度的优越性。事实充分证明，我们的疫情防控政策是正确的、科学的、有效的，得到了人民认可，经得起历史检验。</p>
<p>　　（二）</p>
<p>　　惟其艰难，更显勇毅；惟其艰难，更彰初心。回首近三年抗疫历程，真可谓千磨万击还坚劲，越是艰险越向前！</p>
<p>　　犹记2020年1月，新冠肺炎疫情突如其来，湖北武汉这座千万级人口的特大城市经济社会发展不少方面按下“暂停键”。党中央果断决策、沉着应对，举全国之力实施规模空前的生命大救援。我们用1个多月的时间初步遏制疫情蔓延势头，用2个月左右的时间将本土每日新增病例控制在个位数以内，用3个月左右的时间取得武汉保卫战、湖北保卫战的决定性成果，在全球率先控制住疫情、率先复工复产、率先恢复经济社会发展。</p>
<p>　　犹记2021年10月，一场疫情突至内蒙古额济纳旗，让这个边陲小城成为全国的关注焦点。快速流调、风险分类、封控管理、大规模转运……一系列精准防控措施迅速落地，短时间内斩断社区传播链，保障近万名滞留游客“疫”时无忧、上百名确诊病例得到有效治疗。大约2周时间，额济纳旗疫情就得到初步控制。</p>
<p>　　犹记2022年4月，奥密克戎变异株来势汹汹，拥有2500万人口的上海面临前所未有的严峻考验。关键时刻，党中央发出了打赢大上海保卫战的动员令，25个省份的5万余名医务人员以及军队医疗队员驰援，上海党员干部群众团结一心、连续奋战。2022年6月1日，上海进入全面恢复正常生产生活秩序阶段，“那个熟悉的上海，又回来了”。</p>
<p>　　…………</p>
<p>　　沧海横流显砥柱，万山磅礴看主峰。面对百年来全球发生的最严重的传染病大流行，面对新中国成立以来我国遭遇的传播速度最快、感染范围最广、防控难度最大的重大突发公共卫生事件，面对病毒变异带来的一次又一次冲击，以习近平同志为核心的党中央审时度势、果敢抉择，锐意进取、攻坚克难，以科学之策应对非常之难，以举国之力抗击重大疫情。正是因为有党中央的坚强领导，有我国社会主义制度优势的充分发挥，亿万人民同舟共济、团结一致，打赢了一场又一场硬仗，守住了人民生命健康的坚实防线，保持了经济社会发展和疫情防控全球领先地位。</p>
<p>　　重大历史关头，党中央的判断力、决策力、行动力具有决定性作用。第一时间作出指示“要把人民群众生命安全和身体健康放在第一位”“采取切实有效措施，坚决遏制疫情蔓延势头”；农历正月初一主持召开中央政治局常委会会议，对疫情防控工作进行再研究、再部署、再动员；疫情防控关键时刻飞赴武汉决胜之地，发出“坚决打赢湖北保卫战、武汉保卫战”的总攻号令；准确把握疫情形势变化，及时作出统筹疫情防控和经济社会发展的重大决策；因时因势、科学决策，研究部署进一步优化防控工作的措施……习近平总书记高瞻远瞩的判断、科学果断的决策，彰显着人民领袖的责任担当，为打赢疫情防控的人民战争、总体战、阻击战指明前进方向、提供重要遵循。</p>
<p>　　实践充分证明，中国共产党具有无比坚强的领导力，是风雨来袭时中国人民最可靠的主心骨。只要我们毫不动摇坚持和加强党的全面领导，不断增强党的政治领导力、思想引领力、群众组织力、社会号召力，就一定能够形成强大合力，不断从胜利走向新的胜利。</p>
<p>　　重大考验面前，制度优势是形成共克时艰磅礴力量的根本保障。衡量一个国家的制度是否成功、是否优越，一个重要方面就是看其在重大风险挑战面前，能不能号令四面、组织八方共同应对。从第一时间科学果断作出决策，领导组织党政军民学、东西南北中大会战，到成立中央应对疫情工作领导小组，派出中央指导组，建立国务院联防联控机制；从迅速建立全国疫情信息发布机制，健全及时发现、快速处置、精准管控、有效救治的常态化防控机制，到坚持全国一盘棋，形成统一指挥、全面部署、立体防控的战略布局……在抗击世纪疫情的大战大考中，中国共产党领导和我国社会主义制度优势进一步彰显，展现出抗击疫情、化解危机、应对变局的强大效能。</p>
<p>　　实践充分证明，我国社会主义制度具有非凡的组织动员能力、统筹协调能力、贯彻执行能力，能够充分发挥集中力量办大事、办难事、办急事的独特优势。只要我们坚持和完善我国社会主义制度，推进国家治理体系和治理能力现代化，善于运用制度力量应对风险挑战冲击，就一定能够经受住一次次考验，不断化危为机。</p>
<p>　　在中国共产党历史展览馆里，一面面写着“党员突击队”的鲜红旗帜，诠释着战胜疫情的重要密码。难以忘记除夕夜的逆行出征，346支国家医疗队、4万多名医务人员毅然奔赴武汉前线，“我是党员我先上”折射一方有难八方支援的担当；难以忘记风雪中的默默坚守，460多万个基层党组织冲锋陷阵，400多万名社区工作者在全国65万个城乡社区日夜值守，让党旗在抗疫第一线高高飘扬；难以忘记复工复产的争分夺秒，数以百万的扶贫干部一鼓作气、尽锐出战啃下贫中之贫、坚中之坚的“硬骨头”，无数人在自己的岗位上“奋力把失去的时间抢回来、把疫情造成的损失补回来”……广大党员以不变的初心与人民同心，想人民之所想，行人民之所嘱，用行动践行着人民至上、生命至上的理念。</p>
<p>　　“物有甘苦，尝之者识；道有夷险，履之者知。”波澜壮阔的抗疫斗争，书写经得起历史和人民检验的合格答卷。一个结论分外清晰：中国共产党的坚强领导、我国社会主义制度所具有的显著优势，能够集聚起万众一心、共克时艰的磅礴力量，这是中国战疫的根本保证。</p>
<p>　　（三）</p>
<p>　　2022年10月，全国规模以上工业增加值同比增长5.0%，比三季度加快0.2个百分点；前10月，我国一般贸易进出口总值同比增长13.3%，保持两位数增长；三季度，GDP同比增长3.9%，比二季度加快3.5个百分点，回稳向上基础不断得到巩固。面对世纪疫情，中国经济“稳住了”的背后，正是科学精准的防控与有力有效的统筹。</p>
<p>　　科学决策和创造性应对是化危为机的根本方法。在同不断变异的毒株较量中，坚持边防控、边研究、边总结、边调整，走小步、不停步，是我们的必然选择，也是实践证明行之有效的重要经验。从武汉保卫战、湖北保卫战到常态化疫情防控，再到迎战德尔塔、奥密克戎……以习近平同志为核心的党中央始终把人民群众生命安全和身体健康放在第一位，实事求是、因时因势、科学决策，九版防控方案和诊疗方案先后印发，二十条优化措施和新十条优化措施先后出台，确保了疫情防控的科学路径、正确方向。</p>
<p>　　——正确的战略策略，为应对疫情提供了根本遵循。常态化疫情防控后，我国始终坚持人民至上、生命至上，以“外防输入、内防反弹”为总策略，以“动态清零”为总方针，健全及时发现、快速处置、精准管控、有效救治的常态化防控机制，守住了不出现疫情规模性反弹的底线。2021年，德尔塔变异株疫情短时间内多点发生，一度波及20余个省份，我们全面激活应急指挥系统，迅速扑灭30余起本土聚集性疫情；今年3月份以来，奥密克戎变异株传播速度快、感染人数多，我们与病毒赛跑，快速有效处置了吉林、天津、陕西等地的聚集性疫情，打赢了大上海保卫战；随着奥密克戎病毒致病性的减弱、疫苗接种的普及、防控经验的积累，我们先后及时制定了二十条优化措施和新十条优化措施，最大限度减少疫情对经济社会发展的影响。实践充分证明，我们的抗疫战略策略是符合我国国情、经过实践检验的有效举措，是综合社会成本最低的抗疫方案。</p>
<p>　　——精准的战术措施，为应对疫情提供了行动指南。2020年至2022年，疫情防控经历了突发疫情应急围堵、常态化疫情防控探索、全方位综合防控等不同阶段。从早发现、早报告、早隔离、早治疗，到科学划定中高风险地区和管控风险人群；从推广“抗原筛查、核酸诊断”监测模式，到“应检尽检”“应隔尽隔”“应治尽治”“应管尽管”……根据病毒的演进变化趋势，根据实际防控能力的改善和提升，以及积累的临床治疗的经验和认识，不断优化和调整疫情防控措施，是尊重科学、尊重规律的必然选择。疫情越是复杂，形势越是多变，越要坚持因时因势、以变应变。实践充分证明，我们的抗疫各项措施是科学精准、及时高效的，有效遏制了疫情大面积蔓延，有力改变了病毒传播的危险进程。</p>
<p>　　抗疫实践启示，尊重科学是我们抗疫的有效武器。面对前所未知的新型传染性疾病，我们秉持科学精神、科学态度，把遵循科学规律贯穿到决策指挥、病患治疗、技术攻关、社会治理各方面全过程。我们实行中西医结合，先后推出九版全国新冠肺炎诊疗方案，筛选出“三药三方”等临床有效的中药西药和治疗办法，被多个国家借鉴和使用。无论是抢建方舱医院，还是多条技术路线研发疫苗；无论是开展大规模核酸检测、大数据追踪溯源和健康码识别，还是分区分级差异化防控、高效统筹疫情防控和经济社会发展，都是对科学精神的尊崇和弘扬，都为战胜疫情提供了强大科技支撑。</p>
<p>　　抗疫实践启示，实事求是是我们抗疫的重要法宝。我们坚持一切从实际出发，根据实际情况精准施策，根据病毒毒性、社会经济、治疗手段等综合评判再制定相应政策、采取行动措施。我们不断优化防控措施，每一次优化都十分审慎，都建立在此前防控实践的基础上，根据实践发现的新情况新问题，进行深入的科学研究论证；每一次优化都更加科学精准，聚焦病毒特性、国际国内疫情形势和国内外防控策略变化，因时因势进行调整；每一次优化都坚持以人民为中心，为了更好地保障人民群众正常生产生活秩序，更好地为老年人、婴幼儿等重点人群提供保障。</p>
<p>　　世异则事异，事异则备变。根据对疫情趋势的研判、对防控措施的成效评价，综合考虑各方因素，我们及时出台的新十条优化措施，通过加强全人群特别是老年人群免疫接种，加强药物和医疗资源的准备等，进一步提升防控能力，能够更好地适应疫情防控的新形势和新冠病毒变异株的新特点，进一步提高疫情防控的科学性和精准性，使防控更具可操作性和针对性，更高效地利用防控资源，更好地统筹疫情防控和经济社会发展，更好地保障正常的生产生活和医疗卫生需求。这正是贯彻以人民为中心、把人民群众生命安全和身体健康放在第一位的具体实践，将为今后继续优化调整防控策略和措施、最终战胜疫情创造更为有利的条件。</p>
<p>　　抗疫斗争贯穿求真务实的实践品格和科学精准的防控要求，我们不仅保护了亿万人民的生命安全和身体健康，而且探索出了疫情防控的“中国方案”。实践充分证明：以习近平同志为核心的党中央确定的疫情防控方针政策是完全正确的，我们的防控措施是科学有效的，是最经济的、效果最好的，这是中国战疫的根本支撑。</p>
<p>　　（四）</p>
<p>　　近三年来，面对世纪疫情，我们主动应对挑战、不断积累经验，增强了防疫的本领、积累了抗疫的资源。抗疫斗争，我们赢得了主动，应对疫情更有实力。</p>
<p>　　“只有构建起强大的公共卫生体系，健全预警响应机制，全面提升防控和救治能力，织密防护网、筑牢筑实隔离墙，才能切实为维护人民健康提供有力保障。”2020年6月2日，一场专家学者座谈会在北京召开。习近平总书记语重心长地要求，“针对疫情防控中暴露出来的问题和不足，抓紧补短板、堵漏洞、强弱项”。</p>
<p>　　各方面体制机制更加成熟，拥有了有效的诊疗技术和药物，医疗救治、病原检测、流行病学调查等能力在持续提升，疫苗研发和接种取得了积极进展……抗击疫魔，我们的医疗卫生和疾控体系经受住了考验，应对能力显著增强、救治能力不断提升、防疫屏障更加巩固，让我们无惧病毒不断变异，为不断优化疫情防控措施创造了条件，为亿万人民最终赢得抗击疫情的全面胜利筑牢了坚定信心。</p>
<p>　　——持续完善，应对能力显著增强，让我们掌握了战疫主动。</p>
<p>　　我们建立起中央统一指挥、统一协调、统一调度，各地区各方面各负其责、协调配合，集中统一、上下协同、运行高效的指挥体系，为应对疫情提供了有力保证。全国各地成立由党政主要负责人挂帅的应急指挥机制，自上而下构建统一指挥、一线指导、统筹协调的应急决策指挥体系。有令必行、有禁必止，横向到边、纵向到底，这样的疫情防控指挥体系，保证了我们能应对好各种复杂局面。</p>
<p>　　在应对疫情的过程中，我们不断补上公共卫生体系的短板。这样的数据，见证为亿万人民构筑起的健康堤坝：成立32万个村（居）民委员会公共卫生委员会，基本公共卫生服务经费人均财政补助标准2022年达到84元，截至2021年底累计建成社区医院超过2600家、基层医疗卫生机构97.7万个……统一布局、关口前移，分级分层、有效协同，这样的公共卫生防护网，保证了能稳稳兜住14亿多中国人民的生命安全和身体健康。</p>
<p>　　——持续攻关，救治能力不断提升，为我们带来了战疫时机。</p>
<p>　　2021年3月，国家药监局应急批准清肺排毒颗粒、化湿败毒颗粒、宣肺败毒颗粒“三方”成为“三药”上市。“三方”是治疗各型新冠肺炎的通用方剂，来源于张仲景《伤寒杂病论》的几个经典名方，是新冠肺炎救治“利器”。面对大考，中医药交出了一份出色的抗疫答卷。《抗击新冠肺炎疫情的中国行动》白皮书指出：“中医药参与救治确诊病例的占比达到92%。湖北省确诊病例中医药使用率和总有效率超过90%。”从中西医结合、中西药并用，到检测试剂快速问世，再到诊疗方案接续更新，我们对重症病毒型肺炎的救治能力已经提高到了一个新的水平。</p>
<p>　　不打无准备之仗。2022年12月9日，国务院联防联控机制发布的一组数据，让人们更有信心：目前，全国的重症医学床位总数是13.81万张，接近10张&#x2F;10万人的水平，重症医学的医师总数是8.05万人，重症专业的护士达22万人。同时，各地的方舱医院，也正在“升级改造”中，将变身成为具备一定的治疗功能的亚定点医院。医疗资源的准备，正是我们做好下一阶段医疗服务工作的“先手棋”和“关键棋”。</p>
<p>　　——持续努力，防控屏障不断巩固，使我们培厚了战疫家底。</p>
<p>　　“让我们一起苗苗苗苗苗……”这句改编自网红歌曲的接种新冠疫苗口号，让很多人印象颇深。国内外研究和防控实践证明，接种疫苗是在疫情广泛传播情况下降低人群重症和死亡的最有效手段，是直接决定一个社会能否抵御疫情冲击的关键变量。遭遇疫情以来，我们加强疫苗研发科技攻关，超常规开展新冠疫苗应急审批，已有13款新冠疫苗获国家药监局批准附条件上市或被纳入紧急使用。同时，科学规范、安全有序地开展疫苗接种工作，启动新冠疫苗序贯加强免疫接种。截至目前，我国全人群的疫苗接种率，3—17岁已经达到97.5%，18—59岁已经超过了95%，在全世界属于比较高的水平，规模和速度超过全世界其他任何国家。</p>
<p>　　每个人都是自身健康的第一责任人。群众掌握疫情防控知识，这是切断传染病传播、控制流行的重要环节。近三年来，我国持续加强健康科普，开展健康教育，对公众关心的病毒传播途径、规范消毒、个人防护等方面知识进行解读，推动广大群众掌握防控的健康知识，减少恐慌情绪，增强防控信心。“勤洗手、戴口罩、多通风、不聚集”，广大居民养成文明健康、绿色环保生活方式，营造卫生整洁、文明有序、健康祥和的环境，用千千万万个文明健康的小环境筑牢疫情防控的社会大防线。</p>
<p>　　阿尔法、贝塔、伽马、德尔塔、奥密克戎……面对不断出现的新冠病毒变异株，我国经受住了全球多轮疫情流行的冲击。经过近三年努力，我们有条件、有机制、有体系、有队伍、有药物，为夺取抗击疫情全面胜利奠定了基础。</p>
<p>　　（五）</p>
<p>　　近三年来，面对世纪疫情，我们不断调整措施、做好统筹兼顾，最大程度保护了人民群众生命安全，最大限度减少了疫情对经济社会发展的影响，用最小的代价实现了最大的防控效果。抗疫斗争，我们赢得了优势，应对疫情更有底气。</p>
<p>　　惊涛骇浪中把舵导向，大战大考前运筹帷幄。今年4月，习近平总书记在主持召开中共中央政治局会议时指出“疫情要防住、经济要稳住、发展要安全，这是党中央的明确要求”，强调要“高效统筹疫情防控和经济社会发展”，彰显了我们坚决夺取疫情防控和经济社会发展双胜利的信心和决心。事关亿万人民群众的生命健康安全，就没有商量的余地；事关经济社会发展大局，就要全力以赴落实。</p>
<p>　　“生命重于泰山。”把人民生命安全和身体健康放在第一位是中国制定疫情防控政策的首要考量，也是衡量疫情防控成效的重要标准。全国范围调集最优秀的医生、最先进的设备、最急需的资源，全力以赴投入疫病救治，救治费用全部由国家承担；从出生仅30多个小时的婴儿到100多岁的老人，从在华外国留学生到来华外国人员，每一个生命都得到全力护佑，人的生命、人的价值、人的尊严得到悉心呵护。从世界范围来看，中国人受到疫情的影响是全球最小的。事实证明，始终坚持人民至上、生命至上，我们有效应对了五波全球疫情的冲击，让人民生命安全和身体健康得到最大程度的保护，为优化疫情防控政策赢得了宝贵时间、创造了有利条件。</p>
<p>　　防疫关乎生命，发展关乎生计。要防疫还是要经济？对阔步行进的新时代中国而言，这从来不是一道单选题。习近平总书记强调：“全面落实疫情要防住、经济要稳住、发展要安全的要求是一个整体，要一体认识、一体落实、一体评估，巩固经济回升向好趋势，力争实现最好结果。”应对世纪疫情的一个重要方面，就是既要保生命、保安全，也要保经济、保民生，精准处理疫情防控和经济社会发展的辩证关系。2020年，中国率先控制住疫情，率先复工复产，率先实现经济增长由负转正，成为全球唯一实现正增长的主要经济体；2021年，中国经济总量达114.4万亿元，占全球经济总量比重超过18%；今年国民经济总体延续恢复态势，经济社会发展大局保持稳定。疫情防得住，经济才能稳得住，人民生活才能平平安安，经济社会发展才能平稳健康。确保疫情不失控、经济不失速、安全不失守，这是统筹疫情防控和经济社会发展的题中之义。</p>
<p>　　如何看待我国近三年抗疫斗争？关键要算大账，算总账。</p>
<p>　　——抗疫斗争要算经济账，更要算生命账。人命关天，生命无价。在大流行的疫情面前，保障更广范围、更大人群、更为长远的利益，是最符合成本效益的。疫情不可避免对经济运行造成冲击，但是为了保护人民生命安全和身体健康，我们不惜一切代价，什么都可以豁得出来！与发达国家相比，我国人均医疗资源数量、医学技术水平虽然都有一定差距，但这两年人均预期寿命稳步上升，2020年我国居民人均预期寿命达到77.93岁，较2019年上升0.63岁，2021年则提高到78.2岁。能取得这样的成绩，科学有力的疫情防控政策举措功不可没。</p>
<p>　　——抗疫斗争要算眼前账，更要算长远账。从短期看，每次以快制快处置突发疫情，严防外溢扩散和规模性反弹，难免会对发展造成一定的暂时影响，但放眼长远，换来的则是更健康持久的发展。疫情给我国经济发展带来新的挑战，同时也给我国加快科技发展、推动产业优化升级带来新的机遇。智能制造、无人配送、医疗健康等新兴产业展现出巨大成长潜力，网络购物、生鲜电商、在线教育等新兴业态快速发展，为科学防控、复工复产、民生保障等提供了有力支撑。危和机总是同生并存的，克服了危即是机。准确识变、科学应变、主动求变，就能从眼前的危机、眼前的困难中捕捉和创造机遇。</p>
<p>　　——抗疫斗争要算局部账，更要算整体账。科学分析形势、把握发展大势，就必须坚持用全面、辩证、长远的眼光看待当前的困难、风险、挑战。疫情一定程度上给生产生活造成不便，但是随着疫情防控优化调整措施的逐步有序推进落实，中国经济增速将会持续回升。我国经济韧性强、潜力足、回旋余地广、长期向好的基本面没有变，支撑高质量发展的生产要素条件没有变。</p>
<p>　　让世界瞩目的是，在以习近平同志为核心的党中央坚强领导下，近三年来我国走出了一条精准高效统筹疫情防控和经济社会发展的辩证之道。不仅保护了亿万人民的生命安全，还如期打赢脱贫攻坚战、全面建成小康社会、实现“十四五”良好开局……我们用中国的制度优势和坚实国力，最大程度保护了人民生命安全和身体健康，同时推动经济社会发展，这就是经得起历史检验的成绩。</p>
<p>　　（六）</p>
<p>　　近三年来，面对世纪疫情，我们振奋精神、鼓足士气，亿万人民同舟共济、心手相牵，铸就了伟大抗疫精神。抗疫斗争，我们赢得了信心，应对疫情更有斗志。</p>
<p>　　2020年9月8日，全国抗击新冠肺炎疫情表彰大会举行之际，一段视频在网上刷屏：长安街上，钟南山、张伯礼、张定宇、陈薇四位抗疫英雄乘坐礼宾车，在国宾护卫队的护卫下前往人民大会堂。网友纷纷留言：以国之名，致敬！国家表彰的，是一种悬壶济世、舍己为人的责任担当；人们致敬的，是一种敢于牺牲、无私奉献的精神境界。</p>
<p>　　人无精神则不立，国无精神则不强。习近平总书记强调：“在这场同严重疫情的殊死较量中，中国人民和中华民族以敢于斗争、敢于胜利的大无畏气概，铸就了生命至上、举国同心、舍生忘死、尊重科学、命运与共的伟大抗疫精神。”战风斗雨凝结而成，攻坚克难沉淀而来，一个人拥有了这样的精神，必能一往无前；一个民族拥有了这样的精神，必将战无不胜。</p>
<p>　　——抗疫斗争，激发了团结一心、共克时艰的精神。面对突如其来的严重疫情，中国人民风雨同舟、众志成城，构筑起疫情防控的坚固防线。面对生死考验，面对长时间隔离带来的巨大身心压力，广大人民群众生死较量不畏惧、千难万险不退缩，或向险而行，或默默坚守，以各种方式为疫情防控操心出力。长城内外、大江南北，全国人民心往一处想、劲往一处使，把个人冷暖、集体荣辱、国家安危融为一体，“天使白”“橄榄绿”“守护蓝”“志愿红”迅速集结，“疫情不退我不退”，誓言铿锵，丹心闪耀。14亿多中国人民同呼吸、共命运，肩并肩、心连心，绘就了团结就是力量的时代画卷！在这次抗疫斗争中，14亿多中国人民显示出高度的责任意识、自律观念、奉献精神、友爱情怀，铸就起最强大的精神防线。</p>
<p>　　实践充分证明，中国人民具有不屈不挠的意志力，是战胜前进道路上一切艰难险阻的力量源泉。只要亿万人民在党的旗帜下团结成“一块坚硬的钢铁”，在党的领导下心往一处想、劲往一处使，充分激发广大人民顽强不屈的意志和坚忍不拔的毅力，就一定能够发挥出攻坚克难、推动事业发展的强大能量。</p>
<p>　　——抗疫斗争，坚定了敢于斗争、敢于胜利的信念。2021年初，一张名为“移动的雕塑”的照片刷了屏：十几位大连海洋大学师生志愿者，躬身向前推着一辆满载防疫物资的三轮车，在陡坡上迎着风雪艰难前行。危急时刻，又见遍地英雄。把生的希望留给他人而自己错过救治的医院院长，永远无法向妻子兑现婚礼承诺的丈夫，牺牲在救治岗位留下幼小孩子的妈妈……各条战线的抗疫勇士临危不惧、视死如归，困难面前豁得出、关键时刻冲得上，以生命赴使命，用大爱护众生。面对疫情，中国人民没有被吓倒，而是用明知山有虎、偏向虎山行的壮举，书写下可歌可泣、荡气回肠的壮丽篇章！</p>
<p>　　实践充分证明，中华民族能够经历无数灾厄仍不断发展壮大，正是因为在大灾大难前有千千万万个普通人挺身而出、慷慨前行。只要我们继续发扬担当和斗争精神，以狭路相逢勇者胜的气概，在机遇面前主动出击，在困难面前迎难而上，在风险面前积极应对，就一定能战胜前进道路上的一切艰难险阻，依靠顽强斗争打开事业发展新天地。</p>
<p>　　——抗疫斗争，彰显了天下为公、命运与共的胸怀。“感谢中方为巴基斯坦抗击新冠肺炎疫情提供宝贵帮助，中方提供的疫苗不仅拯救了巴人民，也拯救了巴经济”……2022年2月6日，北京人民大会堂。在同习近平总书记的面对面会晤中，时任巴基斯坦总理伊姆兰·汗表达由衷感激之情。面对全球疫情，中国发起了新中国成立以来最大规模的全球紧急人道主义行动，传递出一个发展中大国既对本国人民生命安全和身体健康负责、也为全球公共卫生事业尽责的大格局、大担当。与180个国家、10多个国际和地区组织分享疫情防控和诊疗方案，向34个国家派出38支医疗专家组，向150多个国家和15个国际组织提供大量抗疫物资，向120多个国家和国际组织提供超过22亿剂次新冠疫苗……中国以实际行动帮助挽救了全球成千上万人的生命，以实际行动彰显了中国推动构建人类命运共同体的真诚愿望！</p>
<p>　　实践充分证明，中国共产党是为中国人民谋幸福、为中华民族谋复兴的党，也是为人类谋进步、为世界谋大同的党。只要我们坚持胸怀天下，共同弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，一道努力落实好全球发展倡议、全球安全倡议，携手同心、行而不辍，就一定能共同坐上新时代的“诺亚方舟”，开创人类更加美好的未来。</p>
<p>　　“中华民族历史上经历过很多磨难，但从来没有被压垮过，而是愈挫愈勇，不断在磨难中成长、从磨难中奋起。” 面对不确定性，我们惟有以自己的确定性去应对。抗疫斗争进一步彰显了责任担当之勇、科学防控之智、统筹兼顾之谋、组织实施之能，中国经济社会大局稳定，中国人民斗志昂扬，我们有充足的底气和能力应对前进道路上的不确定性，在伟大斗争中不断赢得伟大胜利。</p>
<p>　　让我们继续保持战略定力，坚定必胜信心。最可贵的是信心，最需要的是斗志。抗疫斗争具有复杂性、艰巨性、反复性，是实力的较量，更是意志力的比拼。我们既要采取越来越科学、越来越完善、越来越精准、越来越有效的策略举措，也要保持坚定果敢的勇气和坚忍不拔的决心，保持“咬定青山不放松”的韧劲、“越是艰险越向前”的拼劲，凝聚共识、坚定信心、增强斗志，我们有基础、有条件更有信心、有能力夺取抗击疫情的全面胜利。</p>
<p>　　让我们继续凝聚奋进伟力，汇聚战疫合力。团结就是力量，团结才能胜利。世纪疫情防控没有旁观者，没有局外人，全社会都是参与者，每个人都是一道防线。要紧紧依靠人民群众打好人民战争，加强信息发布，主动回应社会关切，及时解决群众实际问题，凝聚同心战疫、共克时艰的强大力量。从优化调整隔离方式，到加快推进老年人新冠疫苗接种，从加强重点人群健康情况摸底及分类管理，到保障社会正常运转和基本医疗服务，我们还需要把各项优化措施抓得更细、做得更实，始终与人民想在一起、干在一起，始终同人民同呼吸、共命运、心连心。</p>
<p>　　“摧伤虽多意愈厉，直与天地争春回。”中国人民和中华民族之所以伟大，根本就在于在任何困难和风险面前都从来不放弃、不退缩、不止步，百折不挠为自己的前途命运而奋斗。从苦难辉煌中走来，奋进在新时代的伟大征程上，中国人民和中华民族实现更加美好生活的前进步伐不可阻挡！</p>
<p>　　（七）</p>
<p>　　历史会镌刻下这一笔。</p>
<p>　　2022年2月4日，北京。第二十四届冬季奥林匹克运动会拉开帷幕，向全世界发出“一起向未来”的和音。这是新冠肺炎疫情背景下首次如期举办的全球综合性体育盛会，国际奥委会主席巴赫表示，在这么严重的新冠肺炎疫情中举办了一次伟大的冬奥会，这是一个非常了不起的成果。</p>
<p>　　2022年11月30日，“天宫”。神舟十五号乘组与神舟十四号乘组“胜利会师”，6名航天员在中国人自己的“家园”里留下一张大合影。激动万分的时刻，承载中华儿女对浩瀚星空的向往，标注中国航天的坚实足迹，续写充满光荣和梦想的远征。</p>
<p>　　回首过去，有涉滩之险，有爬坡之艰，有闯关之难，但我们在战胜一次次考验中成长，在克服一场场危机中发展，让希望的阳光照亮未来。经受世纪疫情大考的中国人民，更加懂得“每个人的前途命运都与国家和民族的前途命运紧密相连”，也更加明白“坚持把中国发展进步的命运牢牢掌握在自己手中”。凝聚奋进伟力，拥有14亿多人民的东方大国必将战胜艰难险阻；坚持团结奋斗，走过5000多年文明历程的古老民族必将永葆生机活力。</p>
<p>　　党的二十大制定了当前和今后一个时期党和国家的大政方针，描绘了以中国式现代化全面推进中华民族伟大复兴的宏伟蓝图。让我们更加紧密团结在以习近平同志为核心的党中央周围，深刻领悟“两个确立”的决定性意义，增强“四个意识”、坚定“四个自信”、做到“两个维护”，把人民群众生命安全和身体健康放在第一位，科学精准做好疫情防控各项工作，全力扫除新冠疫情阴霾，全力促进经济社会恢复发展，在全面建设社会主义现代化国家的新征程上创造新的历史伟业——</p>
<p>　　胜利终将属于英雄的中国人民！</p>
<p>　　《 人民日报 》（ 2022年12月15日 01 版）</p>
]]></content>
      <categories>
        <category>人民日报</category>
        <category>任仲平</category>
      </categories>
      <tags>
        <tag>人民日报</tag>
        <tag>任仲平</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>《人民日报》任仲平：恢宏史诗的力量之源——论弘扬伟大建党精神（ 2021年07月20日 01 版）</title>
    <url>/posts/8b467cbf.html</url>
    <content><![CDATA[<p>（一）天下将兴，其积必有源。</p>
<p>　　“你诞生在一百年前风雨飘摇，从不怕迎面而来的浊浪滔滔……我沐浴着新时代的温暖阳光，从不曾记忆模糊地将你遗忘”，修葺一新的中共一大会址前，上海小荧星合唱团唱响一首《百年号角》。悠扬旋律、天籁童声，穿越百年风雨，唱出薪火相传。</p>
<span id="more"></span>



<p>　　今年是中国共产党成立一百周年。“振衰微于亡国灭种之际，救万民于水深火热之中，建共和于革故鼎新之时，兴百业于一穷二白之上，倡改革于曲折前行之途，成小康于砥砺奋进之中，煌煌然成复兴之大气象……”回望中国共产党的百年征程，无论从哪个角度来看，都堪称伟大。</p>
<p>　　百年风雨，多少悲壮，多少豪迈，多少光荣。</p>
<p>　　一百年前，很少有人能想到，那场从上海石库门紧急转移到浙江嘉兴南湖的会议，尽管当时“似乎什么也没有发生，连报纸上也没有一点报道”，却成为历史上“开天辟地的大事变”；一个初创时只有50多名党员的组织，会发展壮大为拥有9500多万名党员、领导着14亿多人口大国、具有重大全球影响力的世界第一大执政党。</p>
<p>　　从当年“红旗到底打得多久”，到今天“中国共产党为什么能”，疑问正在变为赞叹，时间已经给出答案。</p>
<p>　　“一百年前，中国共产党的先驱们创建了中国共产党，形成了坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，这是中国共产党的精神之源。”在庆祝中国共产党成立100周年大会上，习近平总书记精辟概括了伟大建党精神的深刻内涵，深刻揭示了中国共产党人创造人间奇迹的精神密码。</p>
<p>　　伟大事业孕育伟大精神，伟大精神引领伟大事业。精神的种子里，蕴藏着我们“从哪里来”的基因，更标定我们“走向何方”的路标。</p>
<p>　　1921—2021，一个世纪的伟业辉煌创建；从石库门到天安门，从兴业路到复兴路，一部精神的史诗壮丽书写。在求索和追寻中熔铸，在奋斗和牺牲中砥砺，在奉献和担当中淬炼，伟大建党精神，贯穿于百年征程，彪炳于万里江山，锤炼出中国共产党人的鲜明政治品格，引领着中华民族的伟大复兴航程。</p>
<p>　　问渠那得清如许？为有源头活水来。</p>
<p>　　（二）精神是历史的升华，历史是精神的展开。</p>
<p>　　自1840年以降，列强环伺、民不聊生，九原板荡、百载陆沉，“中国的痛苦与灾难，像这雪夜一样广阔而又漫长”。为了挽救民族危亡、实现中华振兴，形形色色的主义、大大小小的党派，接连登场又纷纷湮灭于历史的烟尘。</p>
<p>　　举目四望，“满地兵燹，疮痍弥目，民生凋敝，亦云极矣”，莽莽神州，谁救中国？环视四周，“人类苦到了极处，社会黑暗到了极处”，苍茫大地，谁主沉浮？</p>
<p>　　在雪夜里率先觉醒，在黑暗中擎起明灯，中国共产党的先驱们义无反顾站了出来。李大钊同志呐喊：“冲决历史之桎梏，涤荡历史之积秽，新造民族之生命，挽回民族之青春！”毛泽东同志誓言：“天下者我们的天下。国家者我们的国家。社会者我们的社会。我们不说，谁说？我们不干，谁干？”</p>
<p>　　1921年6月29日，谢觉哉在日记中写道：“午后六时，叔衡往上海，偕行者润之，赴全国〇〇〇〇〇之招。”这5个圆圈，是为了避免反动派搜查而特意写下，切切而又郑重地代指“共产主义者”。发端于上海石库门的“全国共产主义者之招”，如惊雷、似闪电，划破漫漫长夜。</p>
<p>　　据不完全统计，自1911年武昌起义至1913年底，国内新成立的公开团体有682个，其中政治类团体312个，仅上海一地就有99个之多。在众多政治力量中，新生的中国共产党看上去是如此势单力薄，“除了信仰几乎一无所有”。</p>
<p>　　究竟是怎样与众不同的特质，使得这个新生政党“能够在现代中国各种政治力量的反复较量中脱颖而出”？是何等穿越时空的品格，推动这个百年大党“始终走在时代前列、成为中国人民和中华民族的主心骨”？</p>
<p>　　胜负之征，精神先见。当中国共产党的先驱们开创建党伟业时，答案就已蕴藏在卓尔不凡的伟大精神之中。</p>
<p>　　从为“青春中国之再生”的抗争与期待，到“根本的一个方法，就是民众的大联合”的决断与勇毅，再到“开创一个人人有饭吃、人人有衣穿的新天地”的执着与追求……一个个共产主义者犹如播火者，燃起黑暗中国的点点星火，点亮古老民族的复兴希望，展现着一个政党的行动逻辑、精神力量——</p>
<p>　　中国共产党建党求什么——坚持真理、坚守理想。“对马克思主义的信仰，对社会主义和共产主义的信念，是共产党人的政治灵魂，是共产党人经受任何考验的精神支柱”“一个政党有了远大理想和崇高追求，就会坚强有力，无坚不摧，无往不胜，就能经受一次次挫折而又一次次奋起”；</p>
<p>　　中国共产党立党为什么——践行初心、担当使命。“为中国人民谋幸福，为中华民族谋复兴，是中国共产党人的初心和使命，是激励一代代中国共产党人前赴后继、英勇奋斗的根本动力”“党的初心和使命是党的性质宗旨、理想信念、奋斗目标的集中体现，激励着我们党永远坚守，砥砺着我们党坚毅前行”；</p>
<p>　　中国共产党兴党凭什么——不怕牺牲、英勇斗争。“为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲”“在应对各种困难挑战中，我们党锤炼了不畏强敌、不惧风险、敢于斗争、勇于胜利的风骨和品质。这是我们党最鲜明的特质和特点”；</p>
<p>　　中国共产党强党靠什么——对党忠诚、不负人民。“我们党一路走来，经历了无数艰险和磨难，但任何困难都没有压垮我们，任何敌人都没能打倒我们，靠的就是千千万万党员的忠诚”“江山就是人民、人民就是江山，打江山、守江山，守的是人民的心”。</p>
<p>　　“理想信念之火一经点燃，就永远不会熄灭。”从长征的血战到抗日的烽烟，从建设的探索到改革的攻坚，从发展的事业到复兴的伟业，当中国共产党从小小红船发展成为领航中国行稳致远的巍巍巨轮，当中华民族迎来从站起来、富起来到强起来的伟大飞跃，当中国人民身处“最有理由自信”的伟大时代，伟大建党精神，正是百年辉煌背后的“源代码”“根目录”。</p>
<p>　　凡树有根，方能生发；凡水有源，方能奔涌。只有回溯中国共产党的精神之源，才能洞察百年风华正茂的奥秘；只有找寻中国共产党的历史之根，才能理解立志千秋伟业的雄心。</p>
<p>　　（三）“七一”前夕，中共一大纪念馆开馆。“真理的味道”展陈前，“镇馆之宝”72种版本的《共产党宣言》吸引众多参观者驻足。一百年前，苦苦探寻救亡图存道路的中国，找到了马克思主义；一百年来，无数共产党人“坚持真理、坚守理想”，铸就了伟大建党精神的思想基石。</p>
<p>　　真理的光芒，穿透时光的隧道，照亮过去、现在和未来。</p>
<p>　　多少年来，一个问题让很多人疑惑：20世纪的中国，所有世界上最重要的政治制度、思想主义都被拿来试验过，几乎没有一种能得到满意的结果，为什么唯有中国共产党和马克思主义取得了成功？</p>
<p>　　1921年1月初，长沙大雪纷飞，毛泽东同志在新民学会长沙学员新年大会上发言，赞成用俄国式的革命道路，这是“诸路皆走不通了新发明的一条路”。他比较了社会民主主义、无政府主义等，认为“激烈方法的共产主义，即所谓劳农主义，用阶级专政的方法，是可以预计效果的，故最宜采用”。</p>
<p>　　2020年9月17日，长沙细雨绵绵，习近平总书记走进千年学府岳麓书院，望着书院讲堂檐上的“实事求是”匾额，久久凝思，深刻总结：“共产党怎么能成功呢？当年在石库门，在南湖上那么一条船，那么十几个人，到今天这一步。这里面的道路一定要搞清楚，一定要把真理本土化。”</p>
<p>　　并非每个共产党员，都是天生的马克思主义者。以大历史观之，真理是以真理的精神追求而来，理想是以科学的态度选择而生。</p>
<p>　　自晚清以来，太平天国运动、洋务运动、戊戌变法、义和团运动、清末新政等都未能取得成功；辛亥革命之后，君主立宪制、帝制复辟、议会制、多党制、总统制等各种形式，各种政治势力及其代表人物纷纷登场，也都没能找到正确答案。</p>
<p>　　在反复比较中选择，在世界大潮里追寻，在中华大地上扎根，马克思主义之所以成为中国共产党人的“真经”，就在于它的科学性和真理性在中国得到了充分检验；中国共产党之所以叫共产党，就是因为从成立之日起就把共产主义确立为远大理想。</p>
<p>　　由此可以理解，为什么一百年来中国共产党人在马克思主义的旗帜之下，找到了共同语言，拥有了精神支柱。</p>
<p>　　品味真理之甜，高扬理想之帆，无数共产党人不论风吹雨打、不怕千难万险，迸发出压倒一切敌人而不被敌人所压倒的气概。英勇就义前，方志敏慷慨陈词：“敌人只能砍下我们的头颅，决不能动摇我们的信仰！”冰天雪地里，杨靖宇充满斗志：“革命就像火一样，任凭大雪封山，鸟兽藏迹，只要我们有火种，就能驱赶严寒，带来光明和温暖。”回顾长征胜利，张闻天同志感慨：“没有理想，红军连一千里都走不了。”总结历史经验，邓小平同志强调：“对马克思主义的信仰，是中国革命胜利的一种精神动力。”</p>
<p>　　一百年来，中国共产党人“顶”马克思主义的“天”，“立”中国国情的“地”，以科学的态度对待科学，以真理的精神追求真理，不断推进马克思主义中国化时代化，创立了毛泽东思想、邓小平理论，形成了“三个代表”重要思想、科学发展观，创立了习近平新时代中国特色社会主义思想，为党和人民事业发展提供了科学理论指导，创造了中国式现代化新道路，创造了人类文明新形态。</p>
<p>　　今天，我们实现了第一个百年奋斗目标，在中华大地上全面建成了小康社会，历史性地解决了绝对贫困问题，正在意气风发向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进——当中华民族伟大复兴呈现出前所未有的光明前景，当中国特色社会主义共同理想焕发出无比强大的感召力，我们对习近平总书记的重要论断有了更加深刻的体会：“中国共产党为什么能，中国特色社会主义为什么好，归根到底是因为马克思主义行！”</p>
<p>　　真理之光与理想之光交相辉映，展现着一个政党的恢宏气象，照亮了一个民族的历史天空。</p>
<p>　　（四）一个人也好，一个政党也好，最难得的就是历经沧桑而初心不改、饱经风霜而本色依旧。</p>
<p>　　1925年12月5日，毛泽东同志在为《政治周报》创刊号撰写的发刊理由中指出：“为什么要革命？为了使中华民族得到解放，为了实现人民的统治，为了使人民得到经济的幸福。”</p>
<p>　　2021年7月1日，习近平总书记在庆祝中国共产党成立100周年大会上强调：“中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。”</p>
<p>　　“践行初心、担当使命”，这是跨越时空的精神传承，也是一以贯之的情怀担当。</p>
<p>　　唯物史观认为，只有在一定的社会历史条件下才能理解一个事物的产生与发展。中国近代以后，围绕“救亡”二字，多少次旗竖旗倒，多少次人聚人散，多少英雄饮恨苍天，多少豪杰壮志难酬……</p>
<p>　　1921年3月，李大钊同志在《团体的训练与革新的事业》一文中感慨地写道：“既入民国以来的政党，都是趁火打劫，植党营私，呼朋啸侣，招摇撞骗，捧大老之粗腿，谋自己的饭碗，既无政党之精神，亦无团体的组织，指望由他们做出些改革事为人民谋福利，只和盼望日头由西边出来一样。”</p>
<p>　　当“公理战胜强权”的希望被列强粉碎，当“华人与狗不得入内”的耻辱笼罩古老民族，当苦难深重的中国人民在军阀混战中看不到出路，中国共产党人以深厚的人民情怀、强烈的使命担当，挺立起中华民族的脊梁，以“青春之我”创建“青春之国家”。</p>
<p>　　苦难屈辱的历史，孕育了中国共产党人的初心；救亡图存的热血，铸就了中国共产党人的使命。</p>
<p>　　1937年，一位法国记者在延安采访时发现，医生傅连暲竟放弃每个月400银元的高薪加入红军，爬雪山、过草地，被誉为“红色华佗”。故事刊登在法国《救国时报》上，引发不少国际友人和进步人士慕名前往延安，其中就包括加拿大医生白求恩。傅连暲作出看似不可思议的选择，正是因为他发现，只有跟着中国共产党才能救国救民。</p>
<p>　　中国共产党人的选择，“决非为一衣一食之自为计，而在四万万同胞之均有衣有食也”“亦非自安自足以自乐，而在四万万同胞之均能享安乐也”。为了这样的初心使命，彭湃抛弃“鸦飞不过的田产”投身革命，俞秀松立志“做一个有利于国、有利于民的东南西北的人”，邓中夏在狱中坚信“一个人能为了最多数中国民众的利益，为了勤劳大众的利益而死，这是虽死犹生，比泰山还重”……</p>
<p>　　践行初心、担当使命，长征途中女红军“自己有一条被子，也要剪下半条给老百姓”，是因为红军是老百姓自己的队伍；焦裕禄忍着剧痛坚持工作，是因为他“心中装着全体人民，唯独没有他自己”；廖俊波甘当一位“樵夫”，是因为他坚信“帮老百姓干活、保障群众利益，怎么干都不过分”；钟南山无畏“逆行”，是因为他认定“医院是战场，作为战士，我们不冲上去谁上去”。</p>
<p>　　一部百年党史，既是一部感天动地的史诗，也是一首矢志践行初心使命的赞歌。因永葆赤子之心，这个时代先锋有了薪火相传的制胜法宝；因砥砺复兴之志，这个民族脊梁有了生生不息的动力源泉。</p>
<p>　　“莽莽神州，已倒之狂澜待挽；茫茫华夏，中流之砥柱伊谁？”百余年前的时代之问，早已有了最响亮的回答。在中国共产党的领导下，今天的中国人，可以自信地“平视这个世界了”，找回了做中国人的尊严与荣耀；今天的中华民族，从饱受欺凌走向独立富强，正以不可阻挡的步伐迈向伟大复兴。</p>
<p>　　（五）开天辟地，从来是九死一生；改天换地，注定会风雨兼程。</p>
<p>　　中国共产党历史展览馆，有一件编号为0001的特殊文物——一座绞刑架。1927年4月28日，北京西交民巷京师看守所内，38岁的李大钊同志没有犹豫，没有畏惧，身着长袍、目光坦荡，走向这个绞刑架。“牺牲永是成功的代价”“高尚的生活，常在壮烈的牺牲中”。</p>
<p>　　为有牺牲多壮志，敢教日月换新天。</p>
<p>　　拨开历史烟云，一段段浴血奋战的不屈岁月，依然震撼人心；回望百年历程，一幕幕风云激荡的历史场景，依然让人热泪盈眶：</p>
<p>　　他叫郭亮，牺牲时年仅27岁。1928年3月，郭亮被捕后，在敌人的“法庭”上，面对反动派的死亡威胁，他坚贞不屈地说：“你们就可以杀了，不必多问！”</p>
<p>　　他叫陈树湘，牺牲时年仅29岁。1934年12月，他在湘江战役中身负重伤，不幸被俘。在担架上，不愿做战俘的他，忍着剧痛，从伤口处抠出肠子用力绞断。</p>
<p>　　他叫赵尚志，牺牲时年仅34岁。1942年2月，在率部进行抗日作战中，他身负重伤被俘，誓死不降，“死也要死在东北抗日战场上”。</p>
<p>　　…………</p>
<p>　　“未惜头颅新故国，甘将热血沃中华。”为了理想信仰，多少革命先驱义无反顾、无怨无悔，哪怕付出宝贵生命；多少中国共产党人满腔热情、百折不挠，始终站在攻坚克难最前沿。没有“不怕牺牲、英勇斗争”的精神，就没有鲜红的五星红旗在神州大地高高飘扬。</p>
<p>　　这是一组震撼人心的数字。艰苦卓绝的井冈山斗争，持续两年多，牺牲的英烈平均每天近60人。二万五千里长征路，红一方面军从江西出发时的8.6万人，抵达陕北时只剩6000多人，平均每走1公里就有4名红军战士倒下，每14人只有1人到达陕北。仅新民主主义革命时期，英勇牺牲并有名可查的革命烈士就达370万人。毛泽东同志指出：“中国共产党和中国人民并没有被吓倒，被征服，被杀绝。他们从地下爬起来，揩干净身上的血迹，掩埋好同伴的尸首，他们又继续战斗了。”</p>
<p>　　这是一段不能忘却的记忆。为了保卫新生的共和国，志愿军将士用胸膛堵枪眼，以身躯作人梯，忍饥受冻绝不退缩，烈火烧身岿然不动，以“钢少气多”力克“钢多气少”；为了摘掉“贫油国”的帽子，铁人王进喜在石油大会战中发出“有条件要上，没有条件创造条件也要上”“宁肯少活二十年，拼命也要拿下大油田”的钢铁誓言；为了摆脱核威胁、核讹诈，参与“两弹一星”研制的科学家和科技工作者，远赴大漠深处，以板房帐篷为家，以戈壁黄沙为伴，甘做隐姓埋名人。</p>
<p>　　这是一场风雨无阻的进军。反贫困、建小康、斗洪峰、战疫情、化危机、应变局……进行具有许多新的历史特点的伟大斗争，中国共产党人在滚石上山、爬坡过坎中，蓄积“千磨万击还坚劲”的韧性，砥砺“越是艰险越向前”的品格。在抗击新冠肺炎疫情斗争中，全国3900多万名党员、干部战斗在抗疫一线，近400名党员、干部为保护人民生命安全献出宝贵生命；在脱贫攻坚斗争中，300多万名第一书记和驻村干部，同近200万名乡镇干部和数百万村干部一道奋战在扶贫一线，1800多名同志将生命定格在了脱贫攻坚征程上。</p>
<p>　　谁说历史无言？英雄的事迹就是历史最好的叙述。谁说时间有界？精神的力量总是能够穿越时空的阻隔。</p>
<p>　　习近平总书记指出：“世界上没有哪个党像我们这样，遭遇过如此多的艰难险阻，经历过如此多的生死考验，付出过如此多的惨烈牺牲。”一百年来，一代又一代中国共产党人不怕牺牲、英勇斗争，因为他们深知，自己投身的是民族复兴的千秋伟业，肩负的是人民幸福的万钧重担。</p>
<p>　　“‘延乔路’的尽头，已经通往‘繁华大道’。”建党百年之际，许多人自发来到安徽合肥的延乔路，缅怀中国共产党早期领导人陈延年、陈乔年烈士。90多年前，面对敌人的屠刀，陈延年回答：“革命者光明磊落、视死如归，只有站着死，决不跪下！”面对狱中的酷刑，陈乔年说：“让我们的子孙后代享受前人披荆斩棘的幸福吧！”</p>
<p>　　一路走来，多少枪林弹雨，多少壮怀激烈，多少坚定前行……无数中国共产党人与人民心连心、同呼吸、共命运，用滚烫热血染红了党旗国旗，用牺牲奉献铸就了党魂国魂， 把伟大精神化作一往无前的伟大进军，化作一个古老民族凤凰涅槃的浴火重生。</p>
<p>　　（六）中国国家博物馆珍藏着一幅饱经血与火洗礼的《入党志愿书》，这是井冈山时期保存下来的唯一党证。党证主人在1931年1月25日秘密加入中国共产党时的入党宣誓，尽管24个字中有6个别字，但质朴而无畏的誓言、忠诚而笃定的信念，传递着震撼人心的力量。</p>
<p>　　中国共产党的入党誓词，在党的历史上经历了数次变化，但“永不叛党”是不变的内容。</p>
<p>　　从风雨如晦的年代，到苦难辉煌的岁月，中国共产党之所以能够生生不息，影响因素有很多，但最为关键的是广大党员把对党忠诚、为党分忧、为党尽职、为民造福作为根本政治担当，永葆共产党人政治本色。</p>
<p>　　长征途中，红军战士刘志海冻死在雪山上，在生命的最后一刻，他从雪堆里高举起一只手，紧握着党证和最后的党费——一块银元，期待后面上来的同志替自己向组织缴纳。</p>
<p>　　解放战争时期，西柏坡发出的电报“嘀嗒嘀嗒”声，指挥着千军万马决胜千里。周恩来同志曾说：“我们这个作战室，一不发枪，二不发粮，三不发人，就是每天往前线发电报，就把国民党打败了！”</p>
<p>　　新中国成立前，由于叛徒出卖，党在重庆的地下组织遭受严重破坏。尽管生死未卜，被捕同志仍以对党的赤诚忠心，在狱中秘密总结讨论经验教训，用生命和鲜血写下了“狱中八条”。</p>
<p>　　…………</p>
<p>　　对党忠诚，是共产党人首要的政治品质。正是有了这种忠诚，千千万万党员在大是大非面前旗帜鲜明，在各种诱惑面前立场坚定，在风浪考验面前无所畏惧，使全党淬炼成“一块坚硬的钢铁”。</p>
<p>　　习近平总书记深刻指出：“如果没有对党忠诚作为政治上的‘定海神针’，就很可能在各种考验面前败下阵来。”回顾百年党史，无数革命先烈抛头颅洒热血，但也有一些投机革命和意志薄弱的人，成了令人不齿的叛徒。尤其令人痛惜的是，许多优秀党员的牺牲是由于叛徒出卖造成的。体会到这些教训有多惨痛，才能理解对党忠诚有多重要。</p>
<p>　　对党忠诚，不是抽象的而是具体的，不是有条件的而是无条件的。一百年来，一声声“同志们跟我上”，何其震撼！一次次“为党和人民牺牲一切”，何其赤诚！一句句“功成不必在我”，何其无私！正是胸怀对党的忠诚，无数中国共产党人困难面前不低头、艰险面前不退缩、重任面前不懈怠，在任何时候任何情况下都不改其心、不移其志、不毁其节。</p>
<p>　　“对党忠诚、不负人民”，中国共产党人的忠诚，源于纪律的要求，更因为信仰的塑造。翻开中国共产党章程——“党除了工人阶级和最广大人民群众的利益，没有自己特殊的利益。党在任何时候都把群众利益放在第一位”；聆听习近平总书记重要讲话——“中国共产党始终代表最广大人民根本利益，与人民休戚与共、生死相依，没有任何自己特殊的利益，从来不代表任何利益集团、任何权势团体、任何特权阶层的利益。”</p>
<p>　　在中国历史上，从古到今，只有中国共产党人发自肺腑地坚信“江山就是人民、人民就是江山”，在一百年波澜壮阔的伟大实践中，将“人民利益高于一切”鲜明地写在自己的旗帜上，把“全心全意为人民服务”变为广大党员的自觉行动。正因如此，“对党忠诚”才有了最深厚的价值底蕴，才有了最磅礴的力量源泉。</p>
<p>　　“我将无我，不负人民。”这是大党大国领袖的真情表达，也是中国共产党人的永恒追求。以“小康不小康，关键看老乡”的明确要求，锲而不舍推进脱贫攻坚；以“对子孙后代高度负责”的坚决态度，久久为功建设生态文明；以“不得罪腐败分子，就必然会辜负党、得罪人民”的无畏境界，力度空前进行反腐败斗争……“对党忠诚、不负人民”从来不是一句口号，而是心中的信仰、脚下的行动。</p>
<p>　　新冠肺炎疫情在国内最严峻的时候，那首唱给党的《太阳之歌》，又回荡在江汉平原：“你离我最近，你和我最亲，荆棘中领着我走，风浪中挽着我行；我爱你最深，我信你最真，雾茫茫把你呼唤，路漫漫跟你追寻……”</p>
<p>　　有一种忠诚，不分高潮低潮、顺境逆境；有一种关系，从来血脉相通、生死相依。</p>
<p>　　（七）万里长江、九曲黄河，有源故其流不竭；千里奔涌、万壑归流，有积故其力无穷。</p>
<p>　　在建党一百周年之际，党中央首次颁授“七一勋章”。获奖者中，有百战老兵、基层干部、大国工匠、治沙英雄、教育工作者、科技工作者、守边农牧民……习近平总书记指出：“在他们身上，生动体现了中国共产党人坚定信念、践行宗旨、拼搏奉献、廉洁奉公的高尚品质和崇高精神。”</p>
<p>　　历史从哪里开始，精神就从哪里产生。</p>
<p>　　一百年来，一代代中国共产党人，以信仰充实生命，以担当淬火成钢，不仅成就了伟大的事业，也成就了“精神最富有的政党”，构建起了绚烂夺目的精神谱系——以伟大建党精神为源头，井冈山精神、苏区精神、长征精神、延安精神、抗战精神、抗美援朝精神、兵团精神、雷锋精神、焦裕禄精神、大庆精神、“两弹一星”精神、特区精神、女排精神、抗洪精神、抗击“非典”精神、抗震救灾精神、载人航天精神、劳模精神、劳动精神、工匠精神、科学家精神、抗疫精神、脱贫攻坚精神……这些宝贵精神财富跨越时空、历久弥新，集中体现了党的坚定信念、根本宗旨、优良作风，凝聚着中国共产党人艰苦奋斗、牺牲奉献、开拓进取的伟大品格。</p>
<p>　　这里有信仰之光的永恒照耀。马克思主义和共产主义、社会主义信仰信念是共产党人的命脉和灵魂。一百年来，正是因为擎起革命的火把、点亮信仰的光芒，才造就了“不爱财，不为官，不怕死”的忠贞、“忠诚印寸心，浩然充两间”的坚毅、“砍头不要紧，只要主义真”的无畏、“生是为中国，死是为中国”的凛然。伟大建党精神，熔铸坚如磐石的信仰、坚定不移的信念、坚不可摧的信心，照亮了中国共产党人的奋斗征程，成为一个百年大党的显著标识和独特优势。</p>
<p>　　这里有红色基因的赓续传承。我们从“红米饭南瓜汤”哺育的井冈山精神里，看到“星星之火，可以燎原”的理想和信念；从雪山草地上熔炼的长征精神里，看到“红军不怕远征难”的英勇与坚贞；从同新冠肺炎疫情的殊死较量中铸就的抗疫精神里，看到“人民至上、生命至上”的初心与选择……从南湖红船上寻找光明的求索者，到驾驭世界第二大经济体的领航者，正因为融入血脉的红色基因代代相传，中国共产党人才有了冲锋陷阵的勇气、改天换地的志气、决胜未来的底气。</p>
<p>　　这里有英雄史诗的豪迈书写。高耸陡峭的狼牙山还记得纵身一跃的悲壮，阴森恐怖的渣滓洞还记得手绣红旗的信仰，荒无人烟的戈壁滩还记得深藏功名的奉献，焕然一新的汶川城还记得八方来援的大义，生死竞速的金银潭医院还记得誓死不退的坚守……一百年来，为了民族独立、人民解放，为了国家富强、人民幸福，无数中国共产党人视死如归、顽强奋斗、忘我奉献，把忠诚书写在神州大地，将生命融汇进祖国山河，在党性洗礼中锻造了坚不可摧的钢铁脊梁，在牺牲奉献中谱写了气吞山河的英雄壮歌。</p>
<p>　　这里有民族精神的发扬光大。从传统的“大同”理想到坚定的共产主义信念，从“舍生取义”的义利选择到不畏牺牲的英雄气概，从“摩顶放踵”的付出到艰苦奋斗的精神，从“民为邦本”的思想到“不负人民”的初心……伟大建党精神，是中华民族精神的继承发展，是马克思主义同中华优秀传统文化的价值融通。以伟大建党精神为起源的中国共产党人精神谱系，翻山岳而拓前路，汇溪流而成江海，丰沛了中华历史的万古长河，拓宽了中华文明的精神航道，照亮了中华民族的心灵家园。</p>
<p>　　疾风烈火，碧血丹心；闪电惊雷，精神不灭。唯有把伟大建党精神放入历史的、民族的、时代的大江大河中，才能发现，这一精神拥有怎样的分量、蕴含怎样的价值、孕育怎样的未来。</p>
<p>　　犹记得，1840年鸦片战争以后，随着国家主权的一步步沦丧，中国人在精神上也陷入被动。“无声的中国”“沉默的国民的魂灵”“十全停滞的生活”，鲁迅先生用这样的词语，形容当时中国人的消沉、苦闷和彷徨。</p>
<p>　　今天的中国，雄姿英发于世界的东方；今天的中国人民，自信昂扬于伟大的时代。庆祝中国共产党成立100周年大会上，天安门广场上的党旗国旗，与大江南北的红色盛装呼应，彰显着中华儿女的万丈豪情。中国共产党带领中国人民不仅把一个积贫积弱的国家变成世界第二大经济体，更使一个曾被讥为“东亚病夫”的民族实现了精神上的复兴！</p>
<p>　　我们有自信告慰历史、告慰先辈：今天中华大地上不仅有高楼大厦遍地林立，中华民族精神的大厦也已经巍然耸立！</p>
<p>　　（八）中国共产党员的手是什么样的？</p>
<p>　　“七一勋章”获得者张桂梅贴满膏药的手，塞罕坝三代务林人粗糙皲裂的手，逆行出征的白衣天使戴着厚厚手套的手，“排雷英雄战士”杜富国失去的手……最近，一部名为《携手，为人民》的视频，描绘了千千万万中国共产党员用双手为人民谋幸福的动人画卷。用双手，建设山清水秀的家园；用双手，筑起守护健康的长城；用双手，创造摆脱贫困的奇迹……</p>
<p>　　正是这无数双拼搏的手、创造的手，以一个世纪的伟大接力，汇聚成惊天动地、改天换地的无穷力量；正是这无数双奉献的手、无私的手，让伟大精神的高光闪耀，放射出澄澈玉宇、照亮千秋的璀璨光芒。</p>
<p>　　世纪征程，波澜壮阔；千秋伟业，浩瀚诗篇。</p>
<p>　　今天的世界，正经历百年未有之大变局；今天的中国，正处于中华民族伟大复兴的关键时期。二者相互交织，既意味着前所未有的机遇，也意味着前所未有的挑战。把握历史主动，在各种可以预见和难以预见的狂风暴雨、惊涛骇浪中增强我们的生存力、竞争力、发展力、持续力，尤需顽强的意志，尤需“雄健的精神”。</p>
<p>　　“初心易得，始终难守。”对一个创造了伟大人间奇迹的百年大党来说，在长期执政中，如何防止承平日久、精神懈怠的心态？如何永葆慎终如始、朝乾夕惕的状态？如何保持攻坚克难、奋斗到底的姿态？</p>
<p>　　如果说，伟大建党精神曾经体现在“破坏一个旧世界”的革命之时、闪耀在“建设一个新世界”的建设之时、迸发在“大踏步赶上时代”的改革之时，那么，今天的中国共产党人，更需把伟大建党精神弘扬在“新的赶考之路”上。</p>
<p>　　让我们从伟大建党精神中，汲取真理的力量。今天，马克思主义的命运早已同中国共产党的命运、中国人民的命运、中华民族的命运紧紧连在一起，它的科学性和真理性在中国得到了充分检验，它的人民性和实践性在中国得到了充分贯彻，它的开放性和时代性在中国得到了充分彰显。马克思主义深刻改变了中国，中国也极大丰富了马克思主义，21世纪中国的马克思主义正展现出更强大、更有说服力的真理力量。奋斗新时代、奋进新征程，坚持用习近平新时代中国特色社会主义思想武装头脑、指导实践、推动工作，我们就能以真理光芒照亮前行之路。</p>
<p>　　让我们从伟大建党精神中，汲取实践的力量。“世界上的事情都是干出来的，不干，半点马克思主义都没有。”中国共产党人辉煌灿烂的精神谱系，无一不来自革命、建设、改革的实践，也无一不展示着“行动的力量”。奋斗新时代、奋进新征程，统筹“两个大局”、心怀“国之大者”，向着全面建成社会主义现代化强国的目标进军，我们必须在知行合一中主动担当作为，发扬斗争精神、提高斗争本领，撸起袖子加油干、越是艰险越向前，让伟大建党精神成为全党滋养初心、担当使命的精神之源，成为鼓舞人民风雨无阻、勇毅前行的动力之源。</p>
<p>　　让我们从伟大建党精神中，汲取人格的力量。“吃苦在前、享受在后”“不计得失、甘于奉献”“朴实纯粹、淡泊名利”……一代代中国共产党人以忠诚、奉献、牺牲，展现着中国人的志气、骨气、底气，让人民看到了“兴国之光”，让世界感受着“东方魔力”。奋斗新时代、奋进新征程，始终葆有赤子之心，明大德、守公德、严私德，坚定理想信念、坚定奋斗意志、坚定恒心韧劲，平常时候看得出来、关键时刻站得出来、危难关头豁得出来，才能让中国共产党始终保持持久的向心力，让鲜红的党旗始终凝聚起磅礴力量。</p>
<p>　　回望来路，那些彪炳史册的伟大成就和变革背后，蕴含着多少震撼人心的精神图景；砥砺前行，永远保持“那么一股劲、那么一股革命热情、那么一种拼命精神”，我们将继续在人类的伟大时间历史中创造中华民族的伟大历史时间！</p>
<p>　　历史川流不息，精神代代相传。</p>
<p>　　（九）真正属于历史的，也属于未来。</p>
<p>　　2021年仲夏，北京，展示中国共产党百年历史的精神殿堂——中国共产党历史展览馆巍然矗立，气势恢宏。面向鲜红的党旗，习近平总书记举起右拳，带领党员领导同志重温入党誓词。神圣誓言，穿越百年非凡征程，传承伟大精神根脉，激励全体共产党员凯歌以行。</p>
<p>　　今天，中国共产党的精神航标，在中华民族伟大复兴的航道上熠熠生辉。上海兴业路的石库门，嘉兴南湖的红船，井冈山麓的八角楼，长征路上的泸定桥，延安的宝塔山，北京的天安门，大庆油田的第一口油井，戈壁深处的“两弹一星”科研基地，深圳的莲花山，荆江大堤的抗洪纪念碑，震后重建的汶川新城，旧貌换新颜的湘西十八洞村……这些记录下一个个历史时刻的地理标识，承载着红色记忆、闪耀着时代光芒，早已成为中华民族的精神图腾。</p>
<p>　　山峰耸立，挺立的是脊梁；政党勃兴，昂扬的是精神。</p>
<p>　　建党28年之际，党中央从西柏坡动身前往当时的北平，毛泽东同志说：“进京‘赶考’去，精神不好怎么行呀？”</p>
<p>　　建党100年之时，踏上“新的赶考之路”，习近平总书记强调：“我们要继续弘扬光荣传统、赓续红色血脉，永远把伟大建党精神继承下去、发扬光大！”</p>
<p>　　以史为鉴、开创未来。在这场只有进行时没有完成时的赶考之路上，精神的火炬，代代相传；精神的火焰，永远向上——</p>
<p>　　一个知道自己的目的，也知道怎样达到这个目的的政党，一个真正想达到这个目的并且具有达到这个目的所必不可缺的顽强精神的政党——这样的政党将是不可战胜的。</p>
<p>　　《 人民日报 》（ 2021年07月20日 01 版）</p>
]]></content>
      <categories>
        <category>人民日报</category>
        <category>任仲平</category>
      </categories>
      <tags>
        <tag>人民日报</tag>
        <tag>任仲平</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>两次循环搞定一维数组到多位数组的转换（菜单树生成）</title>
    <url>/posts/6d68ccb5.html</url>
    <content><![CDATA[<p>原数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&#x27;第一层1000&#x27;</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&#x27;第一层2000&#x27;</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&#x27;第二层1100&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">&#x27;第二层1200&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">title</span>: <span class="string">&#x27;第二层1300&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">title</span>: <span class="string">&#x27;第二层2100&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">title</span>: <span class="string">&#x27;第二层2200&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">8</span>, <span class="attr">title</span>: <span class="string">&#x27;第三层1110&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">9</span>, <span class="attr">title</span>: <span class="string">&#x27;第三层1120&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<p>现在要实现以下效果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第一层1000&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第二层1100&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第三层1110&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第三层1120&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第二层1200&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第二层1300&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第一层2000&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第二层2100&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;第二层2200&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parentId&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次循环</span></span><br><span class="line"><span class="comment">// 先按照 parentId 转成 Map</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatToMap</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr || !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || !arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; parentId &#125; = item;</span><br><span class="line">    <span class="keyword">if</span> (!map[parentId]) &#123;</span><br><span class="line">      map[parentId] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    map[parentId].<span class="title function_">push</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二次循环</span></span><br><span class="line"><span class="comment">// 从 Map 中递归提取</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">formatToTree</span>(<span class="params">map, parentId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> items = map[parentId] || [];</span><br><span class="line">  <span class="keyword">if</span> (!items.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = item;</span><br><span class="line">    item.<span class="property">children</span> = <span class="title function_">formatToTree</span>(map, id)</span><br><span class="line">  &#125;</span><br><span class="line">  result.<span class="title function_">push</span>(...items);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> mapData = <span class="title function_">formatToMap</span>(arr);</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">formatToTree</span>(mapData, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>JavaScript</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《人民日报》任仲平：掌握历史主动  凝聚奋进伟力（ 2022年09月29日 01 版）</title>
    <url>/posts/5672acc0.html</url>
    <content><![CDATA[<p>（一）点火、发射、升空！</p>
<p>　　北京时间2022年7月24日，搭载问天实验舱的长征五号B遥三运载火箭，在海南文昌航天发射场腾空而起。神舟十三号凯旋、神舟十四号飞天、问天实验舱升空、梦天实验舱择机发射、神舟十五号蓄势待发……我国载人航天事业向着浩瀚星空昂首挺进，承载着我们伟大民族的飞天梦想，镌刻着我们伟大祖国的前行脚步。</p>
<span id="more"></span>



<p>　　征途在星辰大海，潮涌于壮阔山河。党的十八大以来这10年，经过艰苦卓绝的努力，全国832个贫困县全部摘帽，12.8万个贫困村全部出列，现行标准下近1亿农村贫困人口实现脱贫，我们打赢了人类历史上最大规模脱贫攻坚战；经济总量从53.9万亿元提升到114.4万亿元，占世界经济的比重从11.4%提升到18%以上，人均国内生产总值从6300美元提高到超过1.2万美元，我国经济实力又迈上了一个大台阶；港珠澳大桥通车运营，北斗卫星导航系统全面开通，第三艘航空母舰下水，我们向高水平科技自立自强不断迈进……一个个改天换地的创举，一件件惊天动地的大事，谱写了时代变迁的恢宏乐章，拓展了历史前行的宽阔航道。</p>
<p>　　思想之旗领航向，人间正道开新篇。置身百年风云中擘画中华民族复兴大业，深入历史文脉里挖掘时代精神养分，站在世界版图前思考人类命运走向，习近平总书记以马克思主义政治家、思想家、战略家的非凡理论勇气、卓越政治智慧、强烈使命担当，深刻回答一系列时代课题，提出一系列具有开创性意义的新理念新思想新战略，为实现中华民族伟大复兴提供了思想指引和行动指南。</p>
<p>　　一切历史的精华最终是思想史。当历史的车轮驶过沧桑的岁月，一个有着五千多年文明史的古老民族如何走向复兴，一个历经5个多世纪的社会理想如何绽放光芒，一个处于百年未有之大变局的世界如何找到出路，习近平新时代中国特色社会主义思想在深邃的历史洞察中，发出时代的先声，奏响前行的凯歌。</p>
<p>　　（二）如月之恒，如日之升。新时代中国壮阔行进的每一步，都在创造奇迹、书写历史。</p>
<p>　　党的十八大以来这10年，在党和国家事业发展进程中极不寻常、极不平凡。我们遭遇的风险挑战风高浪急，有时甚至是惊涛骇浪，我们肩负任务的繁重性和艰巨性世所罕见、史所罕见。</p>
<p>　　沧海横流显砥柱，万山磅礴看主峰。以习近平同志为核心的党中央始终把握历史大势、掌握历史主动、保持战略定力，凝聚起全党全军全国各族人民的奋进伟力，引领中国号巨轮穿越重重险滩，在跨越历史雄关中朝着光明未来破浪前行。</p>
<p>　　惟其艰难，方显勇毅；惟其磨砺，始得玉成。“伟大的事业之所以伟大，不仅因为这种事业是正义的、宏大的，而且因为这种事业不是一帆风顺的。”回首来时路，我们通过奋斗，披荆斩棘，走过了万水千山。</p>
<p>　　——面对世界经济持续低迷和国内经济“三期叠加”等不利条件和复杂形势，果断作出我国经济发展进入新常态、我国进入新发展阶段等重大判断，提出创新、协调、绿色、开放、共享的新发展理念，作出加快构建新发展格局的重大战略决策，准确识变、科学应变、主动求变，推动高质量发展不断取得新进展。</p>
<p>　　——面对各方面体制机制存在的突出矛盾和问题，果断作出全面深化改革的战略部署，强调改革开放只有进行时、没有完成时，敢于向积存多年的顽瘴痼疾开刀，改革全面发力、多点突破、纵深推进，许多领域实现历史性变革、系统性重塑、整体性重构。</p>
<p>　　——面对贫中之贫、困中之困这块难啃的“硬骨头”，果断发出“决不能落下一个贫困地区、一个贫困群众”的脱贫攻坚战总攻令，把脱贫攻坚摆在治国理政的突出位置，将脱贫攻坚作为全面建成小康社会的底线任务，聚力攻克深度贫困堡垒，完成了消除绝对贫困的艰巨任务。</p>
<p>　　——面对新形势下我们党执政过程中遇到的许多新的重大风险考验，果断作出全面从严治党的战略部署，持续深入推进党的自我革命，坚定不移“打虎”“拍蝇”“猎狐”，坚持不敢腐、不能腐、不想腐一体推进，管党治党实现从“宽松软”到“严紧硬”的深刻转变。</p>
<p>　　——面对突如其来的新冠肺炎疫情，果断打响疫情防控的人民战争、总体战、阻击战，坚持人民至上、生命至上，坚持外防输入、内防反弹，坚持动态清零，因时因势不断调整防控措施，有效统筹疫情防控和经济社会发展，在危机中育先机、于变局中开新局。</p>
<p>　　——面对逆全球化思潮上升、国际局势急剧变化等严峻复杂的外部环境，果断提出总体国家安全观，强调统筹国内国际两个大局、发展安全两件大事，在因势而谋、应势而动、顺势而为中增强忧患意识，树立底线思维，在斗争中维护国家尊严和核心利益，牢牢掌握了我国发展和安全主动权。</p>
<p>　　…………</p>
<p>　　历史的进程有多么波澜壮阔，所产生的影响就有多么广泛深远。一系列战略性举措、一系列变革性实践、一系列突破性进展、一系列标志性成果……我们党团结带领亿万人民自信自强、守正创新，攻克了许多长期没有解决的难题，办成了许多事关长远的大事要事，经受住了来自政治、经济、意识形态、自然界等方面的风险挑战考验，创造了举世瞩目的巨大成就，中国特色社会主义展现出强大生机活力，为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。</p>
<p>　　回望过往的奋斗路，坚定的历史自信，让我们荡开层云千叠，踏平坎坷成大道。“当今世界，要说哪个政党、哪个国家、哪个民族能够自信的话，那中国共产党、中华人民共和国、中华民族是最有理由自信的。”百年来，我们党致力于为中国人民谋幸福、为中华民族谋复兴，致力于为人类谋进步、为世界谋大同，天下为公，人间正道，这是我们党具有历史自信的最大底气，是我们党在中国执政并长期执政的历史自信，也是我们党团结带领人民继续前进的历史自信。10年来，无论风云如何变幻，无论挑战如何严峻，以习近平同志为核心的党中央高瞻远瞩、统揽全局，保持历史耐心，坚定必胜信心，坚定不移做好自己的事情，坚持不懈把中华民族伟大复兴的历史伟业推向前进。时间证明了这样的判断——“时与势在我们一边，这是我们定力和底气所在，也是我们的决心和信心所在。”</p>
<p>　　回望过往的奋斗路，掌握了历史主动，让我们乘风破浪万里，直挂云帆济沧海。“历史发展有其规律，但人在其中不是完全消极被动的。只要把握住历史发展规律和大势，抓住历史变革时机，顺势而为，奋发有为，我们就能够更好前进。”10年来，面对严峻复杂的国际形势和接踵而至的巨大风险挑战，党中央运筹帷幄、指挥若定，作出一系列重大科学判断，提出一系列重大战略策略，推动一系列重大工作，始终掌握新时代新征程党和国家事业发展的历史主动。今天，中国人民更加自信、自立、自强，极大增强了志气、骨气、底气，在历史进程中积累的强大能量充分爆发出来，焕发出前所未有的历史主动精神、历史创造精神，正在信心百倍书写着新时代中国发展的伟大历史。岁月铸就了这样的辉煌——“实现中华民族伟大复兴进入了不可逆转的历史进程。”</p>
<p>　　2012年—2022年，这段浓墨重彩的历史时间，充盈着伟大人民“力拔山兮气盖世”的英雄豪情，铺展着伟大国度“无边光景一时新”的盛世景象，书写着伟大时代“此卷长留天地间”的不朽诗篇。新时代10年的伟大变革，在党史、新中国史、改革开放史、社会主义发展史、中华民族发展史上具有里程碑意义。</p>
<p>　　不久前，中国国家版本馆盛大落成。在中央总馆“真理之光——马克思主义中国化时代化经典版本展”上，《习近平谈治国理政》第一卷到第四卷依次排开。这部权威著作科学回答了中国之问、世界之问、人民之问、时代之问，为国际社会加深对中国之路、中国之治、中国之理的理解打开了重要的“思想之窗”。</p>
<p>　　新时代万象更新、日新月异，源于扭转乾坤的领航力量，源于点亮时代的思想光芒。作为习近平新时代中国特色社会主义思想的主要创立者，习近平总书记为新时代中国特色社会主义伟大实践定纲指向，引领党和国家事业取得历史性成就、发生历史性变革。</p>
<p>　　行进新时代新征程，正是因为有习近平总书记作为党中央的核心、全党的核心掌舵领航，党领导人民成就伟业就有了最可靠的“主心骨”；正是因为有习近平新时代中国特色社会主义思想科学指引，我们在新时代坚持和发展中国特色社会主义就有了行动上的“指南针”。</p>
<p>　　党的十九届六中全会提出：“党确立习近平同志党中央的核心、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位，反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。”这是对贯通历史与现实的必然逻辑和客观规律的深刻总结，是中国共产党、中国人民、中华民族走向更加辉煌未来最根本保证的深刻揭示。</p>
<p>　　在省部级主要领导干部“学习习近平总书记重要讲话精神，迎接党的二十大”专题研讨班上，习近平总书记强调：“在全面建设社会主义现代化国家、向第二个百年奋斗目标进军的新征程上，全党必须高举中国特色社会主义伟大旗帜，坚持以马克思主义中国化时代化最新成果为指导，坚定中国特色社会主义道路自信、理论自信、制度自信、文化自信，坚定不移推进中华民族伟大复兴历史进程。”在社会主义中国迈向社会主义现代化强国的宏图伟业中，在中华民族走向伟大复兴的壮阔征程中，“两个确立”为我们掌握历史主动、保持战略定力、坚持正确航向、推进复兴伟业提供了坚实思想基础和科学行动指引。</p>
<p>　　（三）只有善于从历史中寻找大道的人，才能获得走向未来的智慧。</p>
<p>　　一百多年前，摆在中国人民面前的，是神州陆沉、九原板荡的悲惨命运；激荡仁人志士心中的，是救亡图存、振兴中华的呐喊呼号。中国产生了共产党，这是开天辟地的大事变。为什么一个初创时不过50多名党员的马克思主义政党，能够发展成为今天拥有9600多万名党员、领导着14亿多人口大国、具有重大全球影响力的世界第一大执政党，带领人民创造了“地球上最大的政治奇迹”？为什么一度身处“覆屋之下、漏舟之中、薪火之上”的民族，而今正大踏步走在从站起来、富起来到强起来的康庄大道，向全世界展现了东方的希望？</p>
<p>　　习近平总书记的论断掷地有声：“中国共产党为什么能，中国特色社会主义为什么好，归根到底是因为马克思主义行。马克思主义之所以行，就在于党不断推进马克思主义中国化时代化并用以指导实践。”百年风霜雨雪，我们党之所以能够领导人民在一次次求索、一次次挫折、一次次开拓中完成中国其他各种政治力量不可能完成的艰巨任务，根本在于坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，不断推进马克思主义中国化时代化，用马克思主义中国化的科学理论引领伟大实践。</p>
<p>　　壮阔的时代进程中，马克思主义就是我们党和人民事业不断发展的参天大树之根本，就是我们党和人民不断奋进的万里长河之泉源——</p>
<p>　　在千回百转中寻找出路，在千难万险中向前挺进，在千磨万击中发展壮大，在千辛万苦中夺取胜利，我们党把马克思列宁主义基本原理同中国具体实际相结合，创立、丰富和发展了毛泽东思想，是马克思主义中国化的第一次历史性飞跃。在这一思想的指导下，中华民族任人宰割、饱受欺凌的时代一去不复返了，实现了中国从几千年封建专制政治向人民民主的伟大飞跃，实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃，为实现中华民族伟大复兴奠定了根本政治前提和制度基础。</p>
<p>　　在深入推进改革开放和社会主义现代化建设的征程上，肩负解放和发展社会生产力，使人民摆脱贫困、尽快富裕起来的艰巨任务，我们党从新的实践和时代特征出发坚持和发展马克思主义，创立了邓小平理论、形成了“三个代表”重要思想和科学发展观，形成了中国特色社会主义理论体系，实现了马克思主义中国化新的飞跃。在这一理论体系的指导下，党领导人民开创、坚持、捍卫、发展中国特色社会主义，推进了中华民族从站起来到富起来的伟大飞跃，中国大踏步赶上了时代。</p>
<p>　　立足时代之基、回答时代之问、引领时代之变，我们党深刻总结并充分运用党成立以来的历史经验，从新的实际出发，创立了习近平新时代中国特色社会主义思想，实现了马克思主义中国化新的飞跃。在这一思想的指导下，党领导人民开创中国特色社会主义新时代，创造了新时代中国特色社会主义的伟大成就，中华民族迎来了从站起来、富起来到强起来的伟大飞跃，正以不可阻挡的步伐迈向伟大复兴。</p>
<p>　　马克思主义深刻改变了中国，中国也极大丰富了马克思主义。习近平总书记指出：“我们党的历史，是一部推进马克思主义中国化、不断丰富和发展马克思主义的历史，也是一部运用马克思主义理论认识和改造中国的历史。”</p>
<p>　　百年沧海桑田，“换了人间”！马克思主义为中国革命、建设、改革提供了强大思想武器，使我们党始终掌握历史主动、锚定奋斗目标、沿着正确方向坚定前行，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局。放眼中华文明五千多年历史，没有哪一种政治力量能像中国共产党这样深刻地、历史性地推动中华民族发展进程，使中国这个古老的东方大国创造了人类历史上前所未有的发展奇迹。</p>
<p>　　时代波澜壮阔，“风景这边独好”！马克思主义的命运早已同中国共产党的命运、中国人民的命运、中华民族的命运紧紧连在一起。走过苦难辉煌的过去，走在日新月异的现在，走向光明宏大的未来，马克思主义的科学性和真理性在中国得到充分检验，马克思主义的人民性和实践性在中国得到充分贯彻，马克思主义的开放性和时代性在中国得到充分彰显。习近平新时代中国特色社会主义思想是我们掌握历史主动、凝聚奋进伟力的强大思想武器，在当代中国，坚持和发展习近平新时代中国特色社会主义思想，就是真正坚持和发展马克思主义。</p>
<p>　　（四）2012年岁末，河北阜平正逢零下十几摄氏度严寒，玻璃窗上挂着冰花，骆驼湾村村民唐荣斌家来了一位不寻常的客人。</p>
<p>　　他进门唠起家常，接过从锅里刚蒸出、冒着热气的土豆，掰开一块放在嘴里津津有味地吃了起来。这位客人就是专程前来访贫问苦的习近平总书记。在这太行山深处的革命老区，习近平总书记深情地说：“要看就要真看，看真贫，通过典型了解贫困地区真实情况，窥一斑而见全豹。”</p>
<p>　　顶风雪、冒酷暑，踏泥泞、翻山沟，从黄土高坡到青藏高原，从太行山区到乌蒙山区，从零下几十摄氏度到海拔数千米，从“贫瘠甲天下”的甘肃定西到“隔山走一天”的四川大凉山……党的十八大以来，习近平总书记走遍14个集中连片特困地区，听民声、察民情、解民忧，创造性提出精准扶贫理念，作出一系列新决策新部署，推动中国减贫事业取得巨大成就，困扰中华民族千百年的绝对贫困问题得到历史性解决。</p>
<p>　　时代是思想之母，实践是理论之源。一种理论的产生，源泉只能是丰富生动的现实生活，动力只能是解决社会矛盾和问题的现实要求。科学理论的价值就在于回答时代课题，推动实践发展。习近平新时代中国特色社会主义思想在实践经验的基础上提炼、升华而成，同时在指导实践、推动实践中展现出强大真理力量。</p>
<p>　　“党政军民学，东西南北中，党是领导一切的”——创造性提出“中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导”，指出“坚持和完善党的领导，是党和国家的根本所在、命脉所在，是全国各族人民的利益所在、幸福所在”，明确“加强党对一切工作的领导，这一要求不是空洞的、抽象的，要在各方面各环节落实和体现”，全党思想上统一、政治上团结、行动上一致，党的创造力、凝聚力、战斗力大大提升。</p>
<p>　　“坚持把国家和民族发展放在自己力量的基点上、把中国发展进步的命运牢牢掌握在自己手中”——创造性提出“使市场在资源配置中起决定性作用，更好发挥政府作用”，强调“必须坚持和完善社会主义基本经济制度”，要求“立足新发展阶段、贯彻新发展理念、构建新发展格局、推动高质量发展”，提出并推动实施京津冀协同发展、长江经济带发展、粤港澳大湾区建设、长三角一体化发展、黄河流域生态保护和高质量发展等新的区域发展战略，深入推进西部大开发、东北全面振兴、中部地区崛起、东部率先发展，推动形成优势互补高质量发展的区域经济布局……习近平经济思想深刻回答了我国经济发展的重大理论和实践问题，引领中国经济巨轮在大风大浪中明确方向、笃定前行。</p>
<p>　　“法治兴则民族兴，法治强则国家强”——创造性提出“党的领导是中国特色社会主义法治之魂，是我们的法治同西方资本主义国家的法治最大的区别”，指出“中国特色社会主义实践向前推进一步，法治建设就要跟进一步”，要求“正确处理政治和法治、改革和法治、依法治国和以德治国、依法治国和依规治党的关系”……习近平法治思想领航法治中国建设阔步向前，谱写了“中国之治”新篇章，开辟了社会主义法治理论与实践的新境界。</p>
<p>　　“不得罪成百上千的腐败分子，就要得罪十四亿人民”——创造性提出全面从严治党，严肃党内政治生活，严明党的政治纪律和政治规矩，出台并坚持实施中央八项规定，严厉整治“四风”问题，全面加强党内监督，实现中央和省级党委巡视全覆盖，刹住了一些过去被认为不可能刹住的歪风，纠治了一些多年未除的顽瘴痼疾，探索出依靠自我革命跳出历史周期率的有效途径，赢得了保持党同人民群众的血肉联系、人民衷心拥护的历史主动，赢得了全党高度团结统一、走在时代前列、带领人民实现中华民族伟大复兴的历史主动。</p>
<p>　　“建设生态文明，关系人民福祉，关乎民族未来”——创造性提出“绿水青山就是金山银山”，强调“良好生态环境是最普惠的民生福祉”，指出“山水林田湖草沙是生命共同体”，要求“用最严格制度最严密法治保护生态环境”，提出“共同构建地球生命共同体，共同建设清洁美丽的世界”……习近平生态文明思想为生态文明建设提供了理论指导，推动生态文明建设从认识到实践都发生了历史性、转折性、全局性的变化。</p>
<p>　　“强国必须强军，军强才能国安”——创造性提出党在新时代的强军目标是“建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队”，强调“党对军队的绝对领导是我军的军魂和命根子，永远不能变，永远不能丢”，指出“深化国防和军队改革是实现中国梦、强军梦的时代要求，是强军兴军的必由之路，也是决定军队未来的关键一招”……在习近平强军思想引领下，人民军队实现整体性革命性重塑、重整行装再出发，在中国特色强军之路上迈出坚实步伐。</p>
<p>　　“这样的好制度，没有任何理由改变，必须长期坚持”——创造性提出维护国家主权、安全、发展利益是“一国两制”方针的最高原则，全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，落实中央对特别行政区全面管治权，坚定落实“爱国者治港”、“爱国者治澳”，落实特别行政区维护国家安全的法律制度和执行机制，丰富和发展国家统一理论和对台方针政策，形成新时代党解决台湾问题的总体方略，牢牢把握两岸关系主导权和主动权。</p>
<p>　　“站在历史正确的一边，站在人类进步的一边”——创造性提出构建人类命运共同体，发出共建“一带一路”重大倡议，提出全球发展倡议和全球安全倡议，强调弘扬和平、发展、公平、正义、民主、自由的全人类共同价值……习近平外交思想深刻回答了“建设一个什么样的世界，如何建设这个世界”的时代问题，引领中国特色大国外交理论和实践创新，为人类社会实现共同发展、持续繁荣、长治久安绘制了蓝图。</p>
<p>　　…………</p>
<p>　　拥有科学理论的政党，才拥有真理的力量；科学理论指导的事业，才拥有光明前途。习近平新时代中国特色社会主义思想，深刻回答新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义的重大时代课题，极大深化了对社会主义建设规律的科学认识；深刻回答建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国的重大时代课题，擘画了以中国式现代化推进中华民族伟大复兴的宏伟蓝图；深刻回答建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党的重大时代课题，开辟了管党治党、兴党强党的崭新境界。</p>
<p>　　先进的思想总是与非凡的事业彼此辉映，科学的理论总是与伟大的实践相互激荡。习近平新时代中国特色社会主义思想，是从新时代中国特色社会主义伟大实践中产生的理论结晶，是指引为人民谋幸福、为民族谋复兴、为世界谋大同的思想之旗，是凝聚中国人民勠力同心、奋勇前进的精神之魂，是马克思主义中国化时代化的最新成果，无愧为引领中国、影响世界的当代中国马克思主义、21世纪马克思主义。</p>
<p>　　（五）“我国历史上的反腐倡廉”“我国历史上的国家治理”“我国历史上的法治和德治”“中国历史上的吏治”“我国考古最新发现及其意义”“深化中华文明探源工程”……党的十八大以来中共中央政治局集体学习，中华优秀传统文化多次成为重要内容。这份“课程表”背后，是对中国历史的深切体认，是对中华文化的深切思考，能看到一种深邃思想的源头活水、一种科学理论的文化基因。</p>
<p>　　有什么样的文化格局与气度，就会有什么样的历史发展趋向。在历史的风云际会中，在时代的澎湃大潮里，作为中国先进文化的积极引领者和践行者、中华优秀传统文化的忠实传承者和弘扬者、中国精神的重要贡献者与示范者，中国共产党始终坚持把马克思主义基本原理同中华优秀传统文化相结合，用马克思主义指导中华文化与中国精神的传承、丰富、创新和发展，使中华民族以昂扬姿态屹立于世界东方，使中华文明以璀璨光辉闪耀于人类文明星空。</p>
<p>　　党的十八大以来，习近平总书记在文章、讲话、演讲中常常引用古代典籍中的经典名句，用中国经典讲中国经验，以中国道理说中国道路——</p>
<p>　　从“全面深化改革是关系党和国家事业发展全局的重大战略部署，不是某个领域某个方面的单项改革”的改革谋划中，读出“不谋万世者，不足谋一时；不谋全局者，不足谋一域”的格局与智慧；</p>
<p>　　从“制度优势是一个国家的最大优势，制度竞争是国家间最根本的竞争”的深刻洞察中，读出“凡将立国，制度不可不察也”的经验与警示；</p>
<p>　　从“江山就是人民、人民就是江山，打江山、守江山，守的是人民的心”的深切感悟中，读出“民惟邦本，本固邦宁”的价值与理念；</p>
<p>　　从“增强忧患意识，把防范化解风险挑战摆在突出位置，把困难估计得更充分一些，把风险思考得更深入一些，下好先手棋，打好主动仗”的底线思维中，读出“明者防祸于未萌，智者图患于将来”的理智与清醒；</p>
<p>　　从“人的命脉在田，田的命脉在水，水的命脉在山，山的命脉在土，土的命脉在林和草，这个生命共同体是人类生存发展的物质基础”的深邃思考中，读出“天地与我并生，而万物与我为一”的和谐共生；</p>
<p>　　从“人类已经成为你中有我、我中有你的命运共同体，利益高度融合，彼此相互依存”的天下情怀中，读出“世界大同，天下一家”的美好憧憬；</p>
<p>　　…………</p>
<p>　　习近平总书记特别注重从中华优秀传统文化的角度来丰富发展当代中国马克思主义。习近平新时代中国特色社会主义思想把历史的中国和现实的中国贯通起来，把中华文化与中国精神统一起来，把马克思主义和中华优秀传统文化结合起来，把文化自信与道路自信、理论自信、制度自信结合起来，创造了中华民族智慧的最新表达和理论上的最新概括。</p>
<p>　　2021年3月，福建朱熹园。习近平总书记在这里凝望良久：“如果没有中华五千年文明，哪里有什么中国特色？如果不是中国特色，哪有我们今天这么成功的中国特色社会主义道路？我们要特别重视挖掘中华五千年文明中的精华，把弘扬优秀传统文化同马克思主义立场观点方法结合起来，坚定不移走中国特色社会主义道路。”</p>
<p>　　2022年6月，四川三苏祠。习近平总书记在这里驻足感慨：“中华民族有着五千多年的文明史，我们要敬仰中华优秀传统文化，坚定文化自信。要善于从中华优秀传统文化中汲取治国理政的理念和思维，广泛借鉴世界一切优秀文明成果，不能封闭僵化，更不能一切以外国的东西为圭臬，坚定不移走中国特色社会主义道路。”</p>
<p>　　一个民族的复兴需要强大的物质力量，也需要强大的精神力量。没有先进文化的积极引领，没有人民精神世界的极大丰富，没有民族精神力量的不断增强，一个国家、一个民族不可能屹立于世界民族之林。</p>
<p>　　早在2014年2月24日主持十八届中共中央政治局第十三次集体学习时，习近平总书记就弘扬中华优秀传统文化明确指出：“要处理好继承和创造性发展的关系，重点做好创造性转化和创新性发展。”从敦煌莫高窟到大同云冈石窟，从北京草厂四条胡同到福州三坊七巷，习近平总书记高度重视历史文化遗产保护，在多个场合都强调让收藏在博物馆里的文物、陈列在广阔大地上的遗产、书写在古籍里的文字都活起来。从弘扬民族精神和时代精神，到弘扬伟大建党精神，再到构建起中国共产党人的精神谱系，习近平总书记特别强调“以时代精神激活中华优秀传统文化的生命力”。</p>
<p>　　求木之长者，必固其根本；欲流之远者，必浚其泉源。习近平新时代中国特色社会主义思想从中华五千多年文明的积淀中汲取人文精神、道德价值、历史智慧等精华养分，同时赋予中华优秀传统文化新的时代内涵和现代表达形式，进而运用丰厚的中国历史智慧为治国理政服务、为全面建成社会主义现代化强国服务、为实现中华民族伟大复兴的中国梦服务，无愧为中华优秀传统文化在新的历史条件下创造性转化、创新性发展的优秀典范，无愧为中华文化和中国精神的时代精华。</p>
<p>　　（六）住窑洞、睡土炕、打水井、修淤地坝、建沼气池……“这种历练对您今天有什么影响？”谈起在陕西梁家河的知青岁月，习近平总书记感慨：“看到了人民群众的力量，看到了人民群众的根本，真正理解了老百姓，了解了社会，这个是最根本的。”</p>
<p>　　世界上最大的幸福莫过于为人民幸福而奋斗。从安危冷暖，到柴米油盐，在习近平总书记心中都是大事。“人民”二字，在新时代中国共产党人心中位置最高、分量最重。“人民对美好生活的向往，就是我们的奋斗目标”“为人民服务，担当起该担当的责任”“同群众一块过、一块苦、一块干”“我将无我、不负人民”“民心是最大的政治”“人民是我们党执政的最大底气”“与群众有福同享、有难同当，有盐同咸、无盐同淡”……这些真挚动情的金句，给全党以方向和指引，给人民以温暖和力量。正是为了人民幸福，才能一往无前以赴之，夙兴夜寐以求之，不遗余力以成之。</p>
<p>　　“意莫高于爱民，行莫厚于乐民”。人民性是马克思主义最鲜明的品格，人民立场是马克思主义政党的根本政治立场。任何一项伟大事业要成功，都必须从人民中找到根基，从人民中集聚力量，由人民共同来完成。深深扎根人民，始终敬仰人民；无限热爱人民，矢志造福人民；紧紧依靠人民，团结引领人民……人民至上，是中国共产党性质宗旨的集中体现，是人民是历史创造者的唯物史观的集中体现，是习近平新时代中国特色社会主义思想的鲜明特征和理论品格。</p>
<p>　　习近平新时代中国特色社会主义思想的人民立场，体现在治国理政的全部实践活动中，体现在始终把人民拥护不拥护、赞成不赞成、高兴不高兴、答应不答应作为衡量一切工作得失的根本标准上。在经济建设方面，强调推进高质量发展、推进供给侧结构性改革、促进收入分配更合理，朝着共同富裕方向稳步前进；在政治建设方面，强调党的领导、人民当家作主、依法治国有机统一，使全过程人民民主成为最广泛、最真实、最管用的社会主义民主；在文化建设方面，坚持对中华优秀传统文化的创造性转化、创新性发展，完善公共文化服务体系，丰富人民的精神世界，增强人民的精神力量；在社会建设方面，强调在发展中保障和改善民生，保护和促进人权，做到发展为了人民、发展依靠人民、发展成果由人民共享；在生态文明建设方面，强调环境就是民生，青山就是美丽，蓝天也是幸福……正如一位外国学者感慨：“最重要的是中国共产党与人民之间的关系，时刻将人民利益放在首位，明白人民真正的需求是什么，这样才能制定正确的、有利于人民的政策，才能取得真正的成果。”</p>
<p>　　人民就是江山，也是最大的靠山。抗击新冠肺炎疫情，“给我们力量和信心的是中国人民”；打赢脱贫攻坚战，“引导贫困群众依靠勤劳双手和顽强意志摆脱贫困、改变命运”；编制“十四五”规划，以互联网“倾听人民呼声、汇聚人民智慧”……与人民心心相印、与人民同甘共苦、与人民团结奋斗，有了民心所向、民意所归、民力所聚，我们就能够克服任何困难，就能够无往而不胜。</p>
<p>　　习近平总书记深刻指出：“老百姓是天，老百姓是地。忘记了人民，脱离了人民，我们就会成为无源之水、无本之木，就会一事无成。”心中装着人民——这样的政党，必将永远立于不败之地；这样的思想，必定拥有引领航向的力量。</p>
<p>　　（七）2021年11月19日，在第三次“一带一路”建设座谈会上，习近平总书记回忆起20多年前的一件往事。在福建工作期间，他接待了来访的巴布亚新几内亚东高地省省长。“我向他介绍了菌草技术，这位省长一听很感兴趣。我就派《山海情》里的那个林占熺去了。”</p>
<p>　　福建农林大学教授林占熺，是菌草技术的开创者，也是电视剧《山海情》中凌一农教授的原型。他不仅把菌草技术带到了宁夏的闽宁村，还让这株“致富草”“幸福草”传播至世界100多个国家和地区。巴布亚新几内亚东高地省的家庭主妇扎卡阿博里，2020年仅种菇一项，就收入1.5万基纳（约合2.7万元人民币），比传统种植咖啡和蔬菜高出10倍还多。</p>
<p>　　“菌草的故事”，是人民摆脱贫困的故事，是中国贡献世界的故事，也是人类在现代化道路上进行新探索的故事。</p>
<p>　　“世界上既不存在定于一尊的现代化模式，也不存在放之四海而皆准的现代化标准。”在新中国成立特别是改革开放以来的长期探索和实践基础上，经过党的十八大以来在理论和实践上的创新突破，我们成功推进和拓展了中国式现代化。中国式现代化，既有各国现代化的共同特征，更有基于国情的中国特色，是人口规模巨大的现代化，是全体人民共同富裕的现代化，是物质文明和精神文明相协调的现代化，是人与自然和谐共生的现代化，是走和平发展道路的现代化。</p>
<p>　　生态之变，是观察中国式现代化的一扇绝佳窗口。改革开放以后，我们创造了经济快速发展奇迹，资源环境约束趋紧、生态系统退化等问题也越来越突出。习近平总书记深刻指出：“我们建设现代化国家，走美欧老路是走不通的，再有几个地球也不够中国人消耗。”党的十八大以来，从将生态文明建设纳入“五位一体”总体布局，到把绿色发展列为新发展理念重要组成部分；从建立健全河（湖）长制等环境治理制度，到部署长江经济带发展“共抓大保护、不搞大开发”，一系列重大部署、有力举措推动生态文明建设驶入快车道，美丽中国建设开创新局面。今天的中国，山川披绿、河湖向美，探索出一条人与自然和谐发展的新路。</p>
<p>　　“中国要实现现代化，方方面面都要强起来。”在习近平新时代中国特色社会主义思想指引下，我们坚持和发展中国特色社会主义，推动物质文明、政治文明、精神文明、社会文明、生态文明协调发展，成功走出了中国式现代化道路，创造了人类文明新形态。中国的现代化探索，破解了人类社会发展的诸多难题，摒弃了西方以资本为中心的现代化、两极分化的现代化、物质主义膨胀的现代化、对外扩张掠夺的现代化老路，拓展了发展中国家走向现代化的途径，为人类对更好社会制度的探索提供了中国方案，深刻影响人类历史进程，展现了人类社会现代化的光明前景。</p>
<p>　　唯有凝聚共识的思想，才有拨云破雾的穿透力；唯有洞察未来的远见，才有指引前行的感召力。从置身“世界历史之外”“现代化的迟到国”，到成为“现代化的视觉中心”“世界上最大的经济和社会变革的实验室”，中国式现代化在世界范围内产生越来越强的示范效应。</p>
<p>　　——参观完中国共产党历史展览馆，阿根廷总统费尔南德斯由衷道出自己的感受：“我向中国共产党为中国人民所做的一切和取得的伟大成就表示崇高敬意”。</p>
<p>　　——时任老挝人民革命党中央总书记、国家主席本扬先后到访湖南湘西十八洞村、福建宁德下岐村，亲身体会精准扶贫的中国实践，表示“要把中国同志的好做法带回老挝去”。</p>
<p>　　…………</p>
<p>　　“我们已经走出一条光明大道，我们要继续前行。”脚踏中华大地，传承中华文明，走符合中国国情的正确道路，党和人民就具有无比广阔的舞台，具有无比深厚的历史底蕴，具有无比强大的前进定力。</p>
<p>　　（八）“习总书记绘蓝图，引领人民迈大步。新思想，在山西，民得实惠泰山移。新思想，新引领，山西面貌日日新。一起迎接二十大，共同奋进新征程……”在山西交城夏家营镇郑村中心广场，“金种子”宣讲团文艺宣讲小分队运用当地民间艺术形式开展《新思想在山西》宣讲，赢得了村民们阵阵掌声。</p>
<p>　　马克思曾说：“理论一经掌握群众，也会变成物质力量。”同样，思想若被人民群众所掌握，也能变成物质力量。田野乡村，“让中国人的饭碗牢牢端在自己手中”成为共识；工厂车间，“在全社会弘扬精益求精的工匠精神”激发力量；菁菁校园，“扣好人生第一粒扣子”启迪成长……在广袤神州大地上，亿万人民在党的创新理论中，找到工作的切入点、实践的结合点、发展的契合点，以强烈的历史主动精神奋进新征程、建功新时代。</p>
<p>　　纷繁世事多元应，击鼓催征稳驭舟。看今日之世界，百年变局和世纪疫情相互交织，世界之变、时代之变、历史之变的特征更加明显；观今日之中国，我们需要应对的风险和挑战、需要解决的矛盾和问题比以往更加错综复杂。前进道路上，形势越复杂，任务越艰巨，越需要把握好习近平新时代中国特色社会主义思想的世界观和方法论，坚持好、运用好贯穿其中的立场观点方法，不断提高攻坚克难、化解矛盾、驾驭复杂局面的能力，努力赢得优势、赢得主动、赢得未来。</p>
<p>　　高瞻远瞩，我们要坚持用习近平新时代中国特色社会主义思想观察时代。当代中国正在经历人类历史上最为宏大而独特的实践创新，改革发展稳定任务之重、矛盾风险挑战之多、治国理政考验之大都前所未有，世界百年未有之大变局深刻变化前所未有，提出了大量亟待回答的理论和实践课题，马克思主义始终是我们认识世界、把握规律、追求真理、改造世界的强大思想武器。新的征程上，要善于运用党的创新理论从纷繁复杂的矛盾中把握规律，坚持用马克思主义之“矢”去射新时代中国之“的”，坚持历史与现实、理论与实践、国内与国际相结合，既充分认识我国社会主要矛盾的变化，又牢牢把握社会主义初级阶段的基本国情和世界最大发展中国家的实际，更好认识国情，更好认识党和国家事业发展大势，更好认识历史发展规律，不断积累经验、增长才干，在新时代伟大实践中不断开辟马克思主义中国化时代化新境界。</p>
<p>　　运筹帷幄，我们要坚持用习近平新时代中国特色社会主义思想把握时代。我们党始终善于系统、具体、历史地分析中国社会运动及其发展规律，在认识世界和改造世界过程中不断把握规律、积极运用规律。新的征程上，要牢牢把握新时代新征程党的中心任务，立足新发展阶段，完整、准确、全面贯彻新发展理念，加快构建新发展格局，推动高质量发展，把党的科学理论转化为万众一心推动实现第二个百年奋斗目标、实现中华民族伟大复兴中国梦的强大力量。</p>
<p>　　掌握主动，我们要坚持用习近平新时代中国特色社会主义思想引领时代。一个民族要走在时代前列，就一刻不能没有理论思维，一刻不能没有正确思想指引。新的征程上，要胸怀中华民族伟大复兴战略全局和世界百年未有之大变局，从历史长河、时代大潮、全球风云中分析演变机理、探究历史规律，增强工作的系统性、预见性、创造性，在乱云飞渡中把牢正确方向，在风险挑战面前砥砺胆识，激发为实现中华民族伟大复兴而奋斗的信心和动力，风雨无阻，坚毅前行，开创属于我们这一代人的历史伟业。</p>
<p>　　又踏层峰辟新天，更扬云帆立潮头。坚持用习近平新时代中国特色社会主义思想武装头脑、指导实践、推动工作，以思想的力量激扬奋进的力量，以理论的主动把握历史的主动，我们就一定能在新的长征路上跨越万水千山，夺取新的更大胜利。</p>
<p>　　（九）在中国共产党历史展览馆的广场上，大型雕塑《旗帜》迎风矗立、气势恢宏，以厚重感、崇高感、使命感，激荡着“加油、努力，再长征”的精神力量。</p>
<p>　　回首过去，马克思主义的旗帜高高飘扬，我们交出了一份人民满意、世界瞩目、足以载入史册的答卷；展望未来，在习近平新时代中国特色社会主义思想指引下，中国共产党团结带领中国人民正在新的赶考之路上继续考出好成绩。</p>
<p>　　思想光芒，照亮奋斗之路；思想火炬，引领复兴征程——</p>
<p>　　“心中装着百姓，手中握有真理，脚踏人间正道，我们信心十足、力量十足。”</p>
<p>　　“发展21世纪马克思主义、当代中国马克思主义，是当代中国共产党人责无旁贷的历史责任。”</p>
<p>　　“只要我们勇于结合新的实践不断推进理论创新、善于用新的理论指导新的实践，就一定能够让马克思主义在中国大地上展现出更强大、更有说服力的真理力量。”</p>
<p>　　往昔已展千重锦，明朝更进百尺竿。习近平总书记强调：“即将召开的党的二十大，是在进入全面建设社会主义现代化国家新征程的关键时刻召开的一次十分重要的大会，将科学谋划未来5年乃至更长时期党和国家事业发展的目标任务和大政方针，事关党和国家事业继往开来，事关中国特色社会主义前途命运，事关中华民族伟大复兴。”我们要坚定历史自信、增强历史主动，砥砺前行，奋发有为，以实际行动迎接党的二十大胜利召开，奋力谱写全面建设社会主义现代化国家崭新篇章。</p>
<p>　　今天，新时代中国共产党人意气风发、奋勇争先，亿万人民锐意进取、活力迸发，广袤神州大地生机勃发、欣欣向荣。让我们更加紧密地团结在以习近平同志为核心的党中央周围，坚持以习近平新时代中国特色社会主义思想为指导，深刻领悟“两个确立”的决定性意义，增强“四个意识”、坚定“四个自信”、做到“两个维护”，增强对马克思主义、共产主义的信仰，增强对中国特色社会主义的信念，增强对实现中华民族伟大复兴的信心，踔厉奋发、勇毅前进，为坚持和发展中国特色社会主义、全面建设社会主义现代化国家、全面推进中华民族伟大复兴而不懈奋斗，在新时代新征程上赢得更加伟大的胜利和荣光！</p>
<p>　　《 人民日报 》（ 2022年09月29日 01 版）</p>
]]></content>
      <categories>
        <category>人民日报</category>
        <category>任仲平</category>
      </categories>
      <tags>
        <tag>人民日报</tag>
        <tag>任仲平</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>了解 API 网关</title>
    <url>/posts/3adbb301.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>API 网关是位于客户端与后端服务集之间的 API 管理工具。</p>
<p>API 网关相当于反向代理，用于接受所有应用编程接口（API）调用、整合处理这些调用所需的各种服务，并返回相应的结果。</p>
<span id="more"></span>

<h1 id="为什么要使用-API-网关？"><a href="#为什么要使用-API-网关？" class="headerlink" title="为什么要使用 API 网关？"></a>为什么要使用 API 网关？</h1><p>大多数企业 API 都是通过 API 网关部署的。API 网关通常会处理跨 API 服务系统使用的常见任务，例如用户身份验证、速率限制和统计信息。</p>
<p>API 服务最基本的作用是接受远程请求并返回响应。但是，现实却并非如此简单。不妨想一下您在托管大型 API 时经历的种种顾虑。</p>
<ul>
<li><p>您希望保护 API 免受过度使用和滥用，因此选择了身份验证服务和速率限制。</p>
</li>
<li><p>您想了解人们如何使用您的 API，因此添加了分析和监控工具。</p>
</li>
<li><p>如果您已有货币化 API，则还要连接到计费系统。</p>
</li>
<li><p>您可能采用了微服务架构，因此，单个请求可能需要调用数十个不同的应用。</p>
</li>
<li><p>随着时间推移，您会添加一些新的 API 服务并淘汰另外一些服务，但您的客户仍希望原样获得所有服务。</p>
</li>
</ul>
<p>面对这些复杂局面，您的挑战是为客户提供简单而可靠的体验。API 网关是一种将客户端接口与后端实现分离的方式。当客户端发出请求时，API 网关会将其分解为多个请求，然后将它们路由到正确的位置，生成响应，并跟踪所有内容。</p>
<h1 id="API-网关在-API-管理中的作用"><a href="#API-网关在-API-管理中的作用" class="headerlink" title="API 网关在 API 管理中的作用"></a>API 网关在 API 管理中的作用</h1><p>API 网关是 API 管理系统的一部分。API 网关会拦截所有传入的请求，然后通过 API 管理系统（该系统负责处理各种必要的功能）将其发送出去。</p>
<p>API 网关的工作因实施不同而异。一些常见的功能包括：身份验证、路由、速率限制、计费、监控、分析、策略、警报和安全防护。</p>
<h1 id="API-网关如何支持-DevOps-和无服务器环境"><a href="#API-网关如何支持-DevOps-和无服务器环境" class="headerlink" title="API 网关如何支持 DevOps 和无服务器环境"></a>API 网关如何支持 DevOps 和无服务器环境</h1><p>在采用 DevOps 方法的企业中，开发人员会使用微服务以快速、迭代的方式构建和部署应用。API 是最常见的微服务通信方式之一。</p>
<p>此外，包括无服务器模型在内的现代云开发都要依靠 API 来置备基础架构。您可以部署无服务器功能并使用 API 网关进行管理。</p>
<p>总之，随着集成和互联变得愈加重要，API 的重要性也在提升。随着 API 复杂性的提高和使用量的增长，API 网关的价值也日益得到体现。</p>
<p><a href="https://www.redhat.com/zh/topics/api/what-does-an-api-gateway-do">原文链接</a></p>
]]></content>
      <categories>
        <category>API网关</category>
      </categories>
      <tags>
        <tag>API网关</tag>
      </tags>
  </entry>
  <entry>
    <title>事业单位考试-公共基础知识-山东-2017</title>
    <url>/posts/3ee9425.html</url>
    <content><![CDATA[<h1 id="2017年3月山东省事业单位统考公共基础知识＋综合写作（综合类）试卷"><a href="#2017年3月山东省事业单位统考公共基础知识＋综合写作（综合类）试卷" class="headerlink" title="2017年3月山东省事业单位统考公共基础知识＋综合写作（综合类）试卷"></a>2017年3月山东省事业单位统考公共基础知识＋综合写作（综合类）试卷</h1><p>（考试时长：150分钟满分：100分）</p>
<p>一、单项选择题（下列各題备选答案中只有一项符合题意，请将其选出，并用2B铅笔填涂在答题卡相应的位置上。本题共60小题，毎小题0.8分，共48分）</p>
<span id="more"></span>



<p>1.2016年11月16日，第三届世界互联网大会在浙江省乌镇开幕。国家主席习近平发表讲话指出，互联网是我们这个时代最具发展活力的领域。为携手构建网络空间命运共同体，中国愿同国际社会一道，坚持以人类共同福祉为根本，坚持网络主权理念，推动全球互联网治理朝着更加公正合理的方向迈进，推动网络空间实现（）的目标。<br>A ．平等互信，创新发展，资源其享、安全稳定<br>B ．平等尊重、创新发展、开放共享、安全有序<br>C ．平等尊重、协同发展、开放共享、安全稳定<br>D ．平等互信、协同发展、资源共享、安全有序</p>
<p>2．中国的改革开放之所以能够順利推进并取得历史性成就，根本原因在于始终坚持了正确的改革方向和改革立场，既不走封闭僵化的老路，也不走改旗易帜的邪路。坚持改革的正确方向，最核心的是（)。<br>A ．坚持社会主义市场经济<br>B ．坚持改革与开放相结合<br>C ．坚持和完善中国共产党领导的多党合作和政治协商制度<br>D ．堅持和完善党的领导，坚持和发展中国特色社会主义</p>
<p>3.2016年9月4日至5日在抗州举办的二十国集团领导人第十一次峰会，是近年来我国主办的级别最高、规模最大、影响最深的国际峰会。这次峰会的主题是（)。<br>A ．共同行动：实现包容和稳健增长<br>B .緑色复苏：世界可持续发展的现实选择<br>C ．包容性发展：共同议程与全新挑战<br>D ．构建创新、活力、联动、包容的世界经济</p>
<p>4.自2016年7月1日起，我国全面推进（）改革，这是维营改增试点全面推开后，我国推出的又一重大税制改革。 A ．所得税<br>B ．流转税<br>C ．财产税<br>D ．资源税</p>
<p>5 .（山东省人民政府关于促进大数据发展的意见》提出，要开发“()“智能搜索引擎，向公众提供个性化搜索服务。 A ．山东搜索<br>B ．数据山东<br>C ．民生搜索<br>D ．智慧齐鲁</p>
<p>6.《山东省国民经济和社会发展第十三个五年规划纲要）指出，要加快现代农业发展步伐，深人推进农业标准化，持续推进“三品一标”农产品产地认定。其中，“一标”是指（)。<br>A ．无公害农产品标志<br>B ．绿色食品标志<br>C ．有机农产品标志<br>D ．农产品地理标志</p>
<p>7.(）是国际货币基金组织创造的具有“纸黄金”之称的记账形式，用以充当国家间的支付手段。<br>A ．世界货币<br>B ．强势货币<br>C ．特别提款权<br>D ．自由兑换货币</p>
<p>8．下列关于古代人物与其称号的说法，不正确的是（)。<br>A .“司马青衫”指的是白居易<br>B .“靖节先生”指的是阮籍<br>c .“青莲居士”指的是李白<br>D .“二安”指的是李清照、辛弃疾</p>
<p>9．党的十八届六中全会指出，(）是党的生命，是党内政治生活积极健康的重要基础。<br>A ．群众路线<br>B ．党内民主<br>C ．严肃党内政治生活<br>D ．民主集中制</p>
<p>10．根据国家互联网信息办公室发布的《互联网直播服务管理规定），互联网直播服务提供者应当记录互联网直播服务使用者发布的内容和日志信息，保存（）天，以便配合有关部门的监督检査。<br>A .15<br>C .60<br>B .30<br>D .90</p>
<p>11．为进一步健全农村土地产权制度，中共中央办公厅、国务院办公厅印发（关于完善农村土地所有权承包权经营权分置办法的意见》。“三权分置”是维（‘）后农村改革的又一重大制度创新，对今后一段时期农村土地制度改革将产生深远影响。<br>A ．农村土地分配制度<br>B ．农村集体土地所有制<br>C ．家庭联产承包责任制<br>D ．农村土地经营管理制度</p>
<p>12．自2016年起，毎年4月24日被设立为“中国航天日”。首个“中国航天日”的主题是（)<br>A ．太空梦，民族梦<br>B ．航天梦，中国梦<br>C ．科技强国，民族复兴<br>D ．探索太空，科技兴国</p>
<p>13．人工智能有近期、远期和终极三重威胁，我们在发展人工智能时必须慎重，不应盲目。在人工智能发展上首先要做好风险管控，这样才能为人类造福。这体现的哲学观点是（)。<br>A ．透过现象看本质<br>B ．两点论和重点论的统一<br>C ．具体问题具体分析<br>D ．矛盾的普遍性和特殊性相结合</p>
<p>14.2016年是中俄双方签署《睦邻友好合作条约》15周年，该条约以法律形式固定下来的两国新型国家关系是（)。<br>A ．互信、互惠、互利<br>B ．不结盟、不对抗、不针对第三方<br>C ．平等信任、相互支持、共同繁荣、世代友好<br>D ．和睦相处、平等相待，在涉及彼此核心利益问题上相互坚定支持</p>
<p>15.2016年9月22日，位于（）的中国首个、全球第四个国家级基因库正式运营，这也是我国唯一获批筹建的国家基因库。<br>A ．北京<br>B ．上海<br>C ．广州<br>D ．深圳</p>
<p>16．国有经济是社会主义公有制经济的重要成分，国有经济在国民经济中的主导作用主要体现在（)。<br>A ．数量上<br>B ．质量上<br>C ．效益上<br>D ．控制力上</p>
<p>17.《关于党的十九大代表选举工作的通知》要求，十九大代表的选举产生，要坚持党的领导视相读解与发扬民主有机统一，代表实行差额选举，差额选举的比例应多于（)。<br>A .5%<br>B .10%<br>C .15%<br>D.20%</p>
<p>18．关于党的历史，下列表述正确的是（)。<br>A ．中国共产党第一次全国代表大会于1921年7月31日在上海举行<br>B ．中国共产党第二次全国代表大会通过了中国共产党历史上的第一部党章<br>C ．中国共产党第三次全国代表大会提出了“须知政权是由枪杆子中取得的”的著名论断<br>D ．中国共产党第五次全国代表大会在莫斯科召开</p>
<p>19．文化旅游目的地品牌是指具有地方特色、可以转化成现实旅游产品的重点文化资源。下列不属于山东省十大文化旅游目的地品牌的是（)。<br>A ．泉城济南<br>B ．东方圣地<br>C ．江北水城<br>D ．亲情沂蒙</p>
<p>20．社会分配机制主要有初次分配、再分配、第三次分配三个层次。下列选项中，属于第三次分配的是（)。<br>A ．税收<br>C ．社会救助<br>B ．社会保险<br>D ．市场机制</p>
<p>21．下列漫画揭示的哲理是（)。</p>
<p>那儿很美呀！我看不见！生活在不同高度世界的人．有很不同的视野 A ．人的认识受主客体因素制约 C ．思想的高度影响认识的深度22．社会意识具有相对独立性，即在反映社会存在的同时，还有自身的发展形式和规律。下 B ．人的主观认识影响客观环境 D ．思想的高度决定认识的深度列社会现象中，体现社会意识相对独立性的是（)。 A ．社会主义发展到今天，一些封建习俗在我国依然存在 B ．仓廪实而知礼节，衣食足而知荣辱 C ．随着我国经济社会的发展，人们的消费观念也逐渐改变 D ．随着我国综合国力的提升，人们的幸福感越来强23．国家地震烈度速报和预警工程将用5年左右的时间建设完成，届时发生破坏性地震，我国将能提供秒级地震预警信息服务。地震发生时，具有破坏性的 S 波从震中向四周扩散的速度是毎秒（)。 A .3.4米 B .340米 C .3.5千米 D .35千米24．一个没有发达的自然科学的国家不可能走在世界前列，一个没有繁荣的哲学社会科学的国家也不可能走在世界前列。坚持和发展中国特色社会主义，必须高度重视哲学社会科学，结合中国特色社会主义伟大实践，加快构建中国特色哲学社会科学。当代中国哲学社会科学区别于其他哲学社会科学的根本标志是（)。 A ．坚持以马克思主义为指导 B ．接受中国共产党的领导 C ．代表最广大人民的根本利益 D ．坚守共产主义的远大目标国计</p>
]]></content>
      <categories>
        <category>事业单位考试</category>
        <category>公共基础知识</category>
      </categories>
      <tags>
        <tag>事业单位考试</tag>
        <tag>公共基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>军队文职</title>
    <url>/posts/f13ee3c0.html</url>
    <content><![CDATA[<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>👉 <a href="https://pan.quark.cn/s/4c87af5f4717#/list/share/9e10dccad1b14ea593d778ebb1fb603e-%E5%86%9B%E9%98%9F%E6%96%87%E8%81%8C%E7%9C%9F%E9%A2%98/b3435449b41847dba56cb66907c95725-%E5%86%9B%E9%98%9F%E6%96%87%E8%81%8C%E7%9C%9F%E9%A2%98">公共科目历年真题</a></p>
<p>👉 <a href="https://pan.quark.cn/s/ad0fb544c5c2#/list/share/6dcf35241282449a815c4686f01ac4de-2023%E8%80%83%E5%85%AC%E8%B5%84%E6%96%99%E7%BD%91%E7%9B%98%E7%BE%A4/43e18e5c10134fbb86fe33785452d915-2023%E8%80%83%E5%85%AC%E8%B5%84%E6%96%99/fe3a0b9eb87440509d1c4dd1188b2f8b-2023%E5%86%9B%E9%98%9F%E6%96%87%E8%81%8C">公共课视频课程</a></p>
<span id="more"></span>

<h2 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h2><ol>
<li>熟悉题型</li>
<li>系统学习（视频 + 讲义 + 笔记 + 基础练习）</li>
<li>刷题（粉笔软件、买题库）（提升正确率、技巧、速度 + 查缺补漏）</li>
</ol>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>军队文职和公考一样，学习过程中要防止思维僵化，要打破思维定式，脑子要转起来，灵活起来。</p>
]]></content>
      <categories>
        <category>军队文职</category>
      </categories>
      <tags>
        <tag>军队文职</tag>
      </tags>
  </entry>
  <entry>
    <title>军队文职统一考试理工学类（数学 1）专业科目考试大纲</title>
    <url>/posts/19e91c4e.html</url>
    <content><![CDATA[<h1 id="全军面向社会公开招考文职人员统一考试理工学类（数学-1）专业科目考试大纲"><a href="#全军面向社会公开招考文职人员统一考试理工学类（数学-1）专业科目考试大纲" class="headerlink" title="全军面向社会公开招考文职人员统一考试理工学类（数学 1）专业科目考试大纲"></a>全军面向社会公开招考文职人员统一考试理工学类（数学 1）专业科目考试大纲</h1><p>为了便于应试者充分了解全军面向社会公开招考文职人员统一考试理工学类（数学 1）专<br>业科目的测查范围、内容和要求，制定本大纲。</p>
<span id="more"></span>

<h2 id="一、考试目的"><a href="#一、考试目的" class="headerlink" title="一、考试目的"></a>一、考试目的</h2><p>主要测查应试者与拟任的文职人员岗位要求密切相关的数学学科的基本素养和能力要<br>素，系统掌握数学学科的基本理论、基本知识和基本技能，运用所学数学知识综合分析、判<br>断和解决相关理论问题和实际问题的能力。</p>
<h2 id="二、测查范围"><a href="#二、测查范围" class="headerlink" title="二、测查范围"></a>二、测查范围</h2><p>理工学类（数学 1）专业科目主要为院校、科研单位、工程技术部门从事基础研究、应用<br>研究和教学文职人员岗位者设置，测查内容主要包括高等数学、线性代数、概率论与数理统<br>计等。</p>
<h2 id="三、考试方式和时限"><a href="#三、考试方式和时限" class="headerlink" title="三、考试方式和时限"></a>三、考试方式和时限</h2><p>考试方式为闭卷笔试。考试时限为 120 分钟。</p>
<h2 id="四、试卷分值和试题类型"><a href="#四、试卷分值和试题类型" class="headerlink" title="四、试卷分值和试题类型"></a>四、试卷分值和试题类型</h2><p>试卷满分为 100 分。试题类型为客观性试题。</p>
<h2 id="五、考试内容及要求"><a href="#五、考试内容及要求" class="headerlink" title="五、考试内容及要求"></a>五、考试内容及要求</h2><h3 id="第一篇-高等数学"><a href="#第一篇-高等数学" class="headerlink" title="第一篇 高等数学"></a>第一篇 高等数学</h3><p>主要测查应试者对《高等数学》中的极限、一元函数的连续性、一元函数微分学、一元<br>函数积分学、向量代数与空间解析几何、多元函数微分学、多元函数积分学、无穷级数、常<br>微分方程的基本概念与基本理论的熟知程度，运用基本概念、基本理论和基本方法正确地判<br>断、推理和准确地计算，以及综合运用所学知识分析与解决实际问题的能力。<br>本篇内容包括函数、极限和连续，一元函数微分学，一元函数积分学，向量代数与空间<br>解析几何，多元函数微分学，多元函数积分学，无穷级数，常微分方程。</p>
<h4 id="第一章-函数、极限和连续"><a href="#第一章-函数、极限和连续" class="headerlink" title="第一章 函数、极限和连续"></a>第一章 函数、极限和连续</h4><p>主要测查应试者对极限理论和函数连续性理论的掌握程度。<br>要求应试者理解集合、函数、数列极限、函数极限、无穷小量、无穷大量、函数的连续<br>性、函数的间断点等概念；掌握函数的特性（有界性、单调性、周期性和奇偶性）、特殊的<br>函数（反函数、复合函数、分段函数）、基本初等函数的性质、数列极限的性质和四则运算<br>法则、函数极限的性质和四则运算法则、极限存在的两个重要准则、两个重要极限、无穷小<br>的阶和无穷小的比较、连续函数的性质、初等函数的连续性、闭区间上连续函数的性质等基<br>本理论和基本方法。<br>本章内容主要包括函数、极限、连续。</p>
<h5 id="第一节-函数"><a href="#第一节-函数" class="headerlink" title="第一节 函数"></a>第一节 函数</h5><p><strong>一、函数的概念</strong><br>集合；邻域；集合的运算；映射；逆映射；复合映射；函数；函数的表示法；几个特殊<br>函数；分段函数。<br><strong>二、函数的特性</strong><br>单调性；奇偶性；有界性；周期性。<br><strong>三、函数的运算</strong><br>函数的四则运算；反函数；反函数的图像；复合函数。<br><strong>四、基本初等函数与初等函数</strong><br>幂函数；指数函数；对数函数；三角函数；反三角函数；初等函数。</p>
<h5 id="第二节-极限"><a href="#第二节-极限" class="headerlink" title="第二节 极限"></a>第二节 极限</h5><p><strong>一、数列极限的概念</strong><br>数列；数列极限；数列极限的几何意义。<br><strong>二、数列极限的性质与运算</strong><br>唯一性；有界性；保号性；四则运算法则；收敛数列与其子数列的关系。<br><strong>三、函数极限的概念</strong><br>函数的极限；单侧极限及其与极限的关系；函数极限的几何意义。<br><strong>四、函数极限的性质与运算</strong><br>四则运算法则；函数极限的性质；复合函数求极限法则。<br><strong>五、无穷小量与无穷大量</strong><br>无穷小量与无穷大量；无穷小量与无穷大量的关系；无穷小量的性质及四则运算；无穷<br>小量的阶；高阶、同阶、等价无穷小量。<br><strong>六、极限存在准则与两个重要极限</strong><br>夹逼定理；单调有界收敛准则；柯西（Cauchy）极限存在准则；两个重要极限。</p>
<h5 id="第三节-连续"><a href="#第三节-连续" class="headerlink" title="第三节 连续"></a>第三节 连续</h5><p><strong>一、函数连续的概念</strong><br>函数在一点处连续；左连续与右连续；函数在一点处连续的充分必要条件；连续函数；<br>函数的间断点及其分类；连续函数的四则运算；复合函数的连续性；反函数的连续性；初等<br>函数的连续性。<br><strong>二、闭区间上连续函数的性质</strong><br>有界性定理；最值定理；零点定理；介值定理。</p>
<h4 id="第二章-一元函数微分学"><a href="#第二章-一元函数微分学" class="headerlink" title="第二章 一元函数微分学"></a>第二章 一元函数微分学</h4><p>主要测查应试者对一元函数的微分学理论的掌握程度。<br>要求应试者理解一元函数的导数、微分、高阶导数、隐函数、一阶微分的形式不变性、<br>平面曲线的切线和法线、函数极值、最值、曲线的凹凸性、拐点、曲率等概念；掌握函数的<br>可导性与连续性之间的关系、导数与微分的几何意义、基本初等函数的求导公式、导数和微<br>分的四则运算、反函数与复合函数的求导法则、隐函数以及参数方程所确定的函数的求导法<br>则、求高阶导数的莱布尼兹公式、微分学中值定理（罗尔定理、拉格朗日中值定理、柯西中<br>值定理）、微分中值定理的应用（函数单调性和凹凸性的判定、函数极值、函数最值、渐近<br>线、函数图形）、洛必达法则、函数的泰勒公式、曲率半径等基本理论和基本方法；了解函<br>数的相关变化率、曲率圆的概念和利用泰勒公式求函数近似值、误差估计。<br>本章内容主要包括导数与微分、微分中值定理及导数的应用。</p>
<h5 id="第一节-导数与微分"><a href="#第一节-导数与微分" class="headerlink" title="第一节 导数与微分"></a>第一节 导数与微分</h5><p><strong>一、导数概念</strong><br>导数的定义；左导数与右导数；函数在一点处可导的充分必要条件；导数的几何意义与<br>物理意义；可导与连续的关系；导函数；高阶导数。<br><strong>二、导数基本公式与求导法则</strong><br>基本初等函数的导数公式；导数的四则运算法则；反函数的求导法则；复合函数的求导<br>法则；由方程确定的隐函数的导数；由参数方程确定的函数的导数，左右导数；对数求导法<br>等。<br><strong>三、高阶导数</strong><br>求高阶导数的莱布尼兹公式；直接、间接求高阶导数的方法。<br><strong>四、微分的概念</strong><br>微分；微分的几何意义；微分与导数的关系；微分运算法则；一阶微分形式的不变性；<br>微分在近似计算中的应用。<br><strong>五、曲率</strong><br>弧微分；曲率的概念与计算；曲率半径与曲率圆。</p>
<h5 id="第二节-微分中值定理及导数的应用"><a href="#第二节-微分中值定理及导数的应用" class="headerlink" title="第二节 微分中值定理及导数的应用"></a>第二节 微分中值定理及导数的应用</h5><p><strong>一、微分中值定理</strong><br>费马引理；罗尔定理；拉格朗日中值定理；柯西中值定理。<br><strong>二、洛必达法则</strong><br>未定式的极限；洛必达法则。<br><strong>三、泰勒公式</strong><br>泰勒中值定理；泰勒公式；麦克劳林公式；佩亚诺型余项；拉格朗日型余项。<br><strong>四、导数的应用</strong><br>函数单调性的判定法；曲线的凹凸性；极大值和极小值；函数最值的求法；拐点；渐近<br>线；函数图形的描绘。<br><strong>五、曲率</strong><br>弧微分；曲率；曲率半径；曲率圆。</p>
<h4 id="第三章-一元函数积分学"><a href="#第三章-一元函数积分学" class="headerlink" title="第三章 一元函数积分学"></a>第三章 一元函数积分学</h4><p>主要测查应试者对一元函数积分学的掌握程度。<br>要求应试者理解原函数、不定积分、定积分、变上限积分、微元法及广义积分等概念；掌握原函数的性质、不定积分的基本性质、定积分的性质、积分中值定理，变上限定积分的<br>性质、微积分基本公式（Newton-Leibniz 公式）、不定积分和定积分的基本计算方法、有理函<br>数的积分、三角函数有理式的积分、简单无理函数的积分、定积分的应用、广义积分的简单<br>计算等基本理论和基本方法；了解定积分的近似计算、广义积分收敛性。<br>本章内容主要包括不定积分、定积分。</p>
<h5 id="第一节-不定积分"><a href="#第一节-不定积分" class="headerlink" title="第一节 不定积分"></a>第一节 不定积分</h5><p><strong>一、不定积分</strong><br>原函数；不定积分；原函数存在定理；基本积分表；不定积分的性质；基本积分公式。<br><strong>二、基本积分方法</strong><br>第一类换元积分法；第二类换元积分法；分部积分法。<br><strong>三、有理函数的积分</strong><br>有理函数及可化为有理函数的函数的积分；三角函数有理式的积分；简单无理函数的积<br>分。</p>
<h5 id="第二节-定积分"><a href="#第二节-定积分" class="headerlink" title="第二节 定积分"></a>第二节 定积分</h5><p><strong>一、定积分的概念</strong><br>定积分；定积分的几何、物理意义；定积分的性质；可积的条件。<br><strong>二、定积分的计算</strong><br>两类换元积分法；分部积分法；变上限积分；变上限积分的性质；牛顿—莱布尼茨公式。<br><strong>三、反常积分</strong><br>无穷区间的反常积分；无界函数的反常积分；无穷区间反常积分审敛法；无界函数的反<br>常积分审敛法。<br><strong>四、定积分的应用</strong><br>微元法；平面图形的面积；平面曲线的弧长；旋转体体积；平行截面面积已知的立体的<br>体积；物体沿直线运动时变力所作的功；压力；引力；质心的计算。</p>
<h4 id="第四章-向量代数与空间解析几何"><a href="#第四章-向量代数与空间解析几何" class="headerlink" title="第四章 向量代数与空间解析几何"></a>第四章 向量代数与空间解析几何</h4><p>主要测查应试者对向量代数与空间解析几何的掌握程度。<br>要求应试者理解向量、方向余弦、数量积、向量积、投影、空间直线、平面、空间曲线、<br>曲面等概念；掌握向量及其运算、曲面及其方程、空间曲线及其方程、平面及其方程、空间<br>直线及其方程、特殊的二次曲面等基本理论和基本方法；了解向量的混合积及其运算。<br>本章内容主要包括向量代数、曲面与平面、曲线与直线。</p>
<h5 id="第一节-向量代数"><a href="#第一节-向量代数" class="headerlink" title="第一节 向量代数"></a>第一节 向量代数</h5><p><strong>一、向量的概念</strong><br>向量；向量的模；单位向量；向量在坐标轴上的投影；向量的坐标表示法；向量的方向<br>余弦；两点间的距离公式；n 维向量的概念及运算。<br><strong>二、向量的运算</strong><br>向量的加法；向量的减法；向量的数乘；向量的数量积；向量的向量积；向量的混合积。<br><strong>三、向量的夹角</strong><br>向量的夹角；向量平行、重合、垂直的充分必要条件。</p>
<h5 id="第二节-曲面与平面"><a href="#第二节-曲面与平面" class="headerlink" title="第二节 曲面与平面"></a>第二节 曲面与平面</h5><p><strong>一、曲面方程</strong><br>曲面的一般方程；曲面的参数式方程；旋转曲面及其方程；柱面及其方程；二次曲面；<br>二次曲面的几何图形；截痕法。<br><strong>二、空间平面方程</strong><br>点法式方程；一般式方程；截距式方程。<br><strong>三、两平面的位置关系与点到平面的距离</strong><br>两平面的夹角；两平面平行、垂直的充要条件、点到平面的距离公式。</p>
<h5 id="第三节-曲线与直线"><a href="#第三节-曲线与直线" class="headerlink" title="第三节 曲线与直线"></a>第三节 曲线与直线</h5><p><strong>一、曲线方程</strong><br>曲线的一般方程；曲线的参数式方程；空间曲线在坐标面的投影。<br><strong>二、空间直线方程</strong><br>一般式方程；对称式方程；参数式方程。<br><strong>三、两直线的位置关系和平面与直线的位置关系</strong><br>两直线的夹角；两直线平行、重合、垂直的充要条件；点到直线的距离公式；直线与平<br>面的夹角；直线与平面的平行、垂直和直线在平面上的条件；异面直线的距离；平面束方程。</p>
<h4 id="第五章-多元函数微分学"><a href="#第五章-多元函数微分学" class="headerlink" title="第五章 多元函数微分学"></a>第五章 多元函数微分学</h4><p>主要测查应试者对多元函数微分学理论的掌握程度。<br>要求应试者理解平面点集、区域、多元函数、多元函数的极限、多元函数的连续性、偏导数与全微分、混合偏导数、方向导数与梯度、多元函数的极值和条件极值等概念；掌握二<br>元函数的极限及性质、二元函数的连续性、有界闭区域上连续函数的性质、多元复合函数一<br>阶和二阶偏导数的求法、全微分存在的必要条件和充分条件、全微分形式的不变性、隐函数<br>存在定理、方程及方程组确定的隐函数的偏导数的求法、方向导数与偏导数的关系、方向导<br>数与梯度的关系、空间曲线的切线和法平面及空间曲面的切平面和法线、多元函数极值存在<br>的必要条件和充分条件、多元函数极值和条件极值、拉格朗日乘数法等基本理论；了解向量<br>值函数的导数与微分、二元函数的二阶泰勒公式和最小二乘法。<br>本章内容主要包括多元函数微分学、多元函数微分学的应用。</p>
<h5 id="第一节-多元函数微分学"><a href="#第一节-多元函数微分学" class="headerlink" title="第一节 多元函数微分学"></a>第一节 多元函数微分学</h5><p><strong>一、多元函数</strong><br>平面点集；多元函数；二元函数的几何、物理意义；向量值函数；多元函数的极限；多<br>元连续函数；向量值函数的极限与连续；多元函数极限运算法则；多元函数极限的性质；有<br>界闭区域上连续函数的性质。<br><strong>二、偏导数与全微分</strong><br>偏导数；混合偏导数；全微分；高阶偏导数；连续、偏导数存在、全微分与偏导数连续<br>之间的关系，全微分形式不变性。<br><strong>三、复合函数的求导法则及隐函数求导公式</strong><br>复合函数求导法则；隐函数存在定理；方程及方程组确定的隐函数的偏导数的求法。</p>
<h5 id="第二节-多元函数微分学的应用"><a href="#第二节-多元函数微分学的应用" class="headerlink" title="第二节 多元函数微分学的应用"></a>第二节 多元函数微分学的应用</h5><p><strong>一、多元函数微分学的几何应用</strong><br>空间曲线的切线及法平面；空间曲面的切平面和法线。<br><strong>二、方向导数与梯度</strong><br>方向导数；方向导数与偏导数的关系；梯度；梯度与方向导数的关系。<br><strong>三、多元函数的极值与条件极值</strong><br>多元函数极值和条件极值；多元函数极值存在的必要条件和充分条件；多元函数求极值、<br>最值；求条件极值的拉格朗日乘数法；建立简单实际问题的模型并求最值。<br><strong>四、二元函数泰勒公式</strong><br>二元函数的泰勒公式。<br>— 8 —<br>第六章 多元函数积分学<br>主要测查应试者对多元函数积分学理论的掌握程度。<br>要求应试者理解二重积分、三重积分、曲线积分、曲面积分、全微分方程、散度与旋度<br>等概念；掌握重积分的性质、二重积分在直角坐标和极坐标系下的计算方法、三重积分（在<br>直角坐标、柱面坐标、球面坐标下）的计算方法、曲线和曲面积分的性质、两类曲线积分的<br>计算方法和格林（Green）公式、平面曲线积分与路径无关的条件、两类曲面积分的计算方法、<br>高斯（Gauss）公式和斯托克斯（Stokes）公式以及重积分、线面积分的实际应用问题（曲面<br>的面积、立体的体积、质心、转动惯量、引力等）等基本理论；了解沿任意封闭曲面积分为<br>零的条件和空间曲线积分与路径无关的条件。<br>本章内容主要包括重积分、曲线积分与曲面积分。<br>第一节 重积分<br>一、二重积分<br>二重积分的定义；二重积分的几何意义；二重积分的性质；二重积分在直角坐标和极坐<br>标系下的计算方法。<br>二、三重积分<br>三重积分的定义；三重积分的性质；三重积分在直角坐标、柱面坐标和球面坐标系下的<br>计算方法。<br>三、重积分的应用<br>曲面的面积；立体的体积；质心；转动惯量；引力。<br>第二节 曲线积分与曲面积分<br>一、曲线积分<br>对弧长的曲线积分的定义；对坐标的曲线积分的定义；两类曲线积分的关系；两类曲线<br>积分的性质；两类曲线积分的计算方法。<br>二、格林公式及其应用<br>格林公式；平面曲线积分与路径无关的条件；二元函数的全微分求积、全微分方程。<br>三、曲面积分<br>对面积的曲面积分的定义；对坐标的曲面积分的定义；两类曲面积分的关系；两类曲面<br>积分的性质；两类曲面积分的计算方法。<br>四、高斯公式和斯托克斯公式<br>高斯公式；斯托克斯公式；沿任意封闭曲面积分为零的条件；空间曲线积分与路径无关<br>— 9 —9<br>的条件；通量与散度。<br>第七章 无穷级数<br>主要测查应试者对级数理论的掌握程度。<br>要求应试者理解常数项级数、函数项级数、幂级数、级数的收敛与发散、绝对收敛与条<br>件收敛、函数项级数的收敛域与和函数、傅里叶级数、函数项级数的一致收敛性等概念；掌<br>握正项级数及其审敛法、交错级数及其审敛法，一致收敛级数的性质、函数项级数的收敛域、<br>幂级数的收敛半径、收敛区间和收敛域、幂级数在其收敛区间内的基本性质、幂级数的和函<br>数、函数展开成幂级数、函数展开成傅里叶级数等基本理论和基本方法；了解函数展开成幂<br>级数的应用。<br>本章内容主要包括数项级数、幂级数、傅里叶级数。<br>第一节 数项级数<br>一、数项级数<br>数项级数；部分和；数项级数的收敛与发散；几何级数与 P 级数；收敛级数的基本性质；<br>柯西收敛原理。<br>二、正项级数审敛法<br>比较审敛法；比较审敛法的极限形式；根值审敛法；比值审敛法。<br>三、任意项级数<br>交错级数；莱布尼兹定理；绝对收敛和条件收敛；绝对收敛级数的性质。<br>第二节 幂级数<br>一、函数项级数<br>函数项级数；函数项级数的收敛与发散；函数项级数的收敛域；函数项级数的一致收敛<br>性；一致收敛级数的基本性质。<br>二、幂级数<br>幂级数的收敛、发散与绝对收敛；幂级数的性质；阿贝尔定理；幂级数的收敛半径、收<br>敛区间、收敛域；幂级数的和函数。<br>三、函数展开为幂级数<br>基本初等函数的麦克劳林展开式；用间接法将初等函数展开为幂级数；近似计算；微分<br>方程的幂级数解法；欧拉公式。<br>— 10 —<br>第三节 傅里叶级数<br>一、傅里叶级数的概念<br>三角级数；三角函数系的正交性；周期为 2π 的函数的傅里叶级数；正弦级数与余弦级数。<br>二、一般周期函数的傅里叶级数<br>函数的周期延拓；周期为 2l 的函数的傅里叶级数。<br>第八章 常微分方程<br>主要测查应试者对常微分方程理论的掌握程度。<br>要求应试者理解微分方程及其阶、解、通解、初始条件和特解等概念；掌握可变量分离<br>的微分方程及一阶线性微分方程的解法，齐次方程、伯努利方程和全微分方程的解法，线性<br>微分方程解的性质及解的结构，二阶常系数齐次线性微分方程、二阶常系数非齐次线性微分<br>方程、欧拉（Euler）方程的解法等基本理论与基本方法。<br>本章内容主要包括微分方程的基本概念、一阶微分方程、高阶微分方程。<br>第一节 微分方程的基本概念<br>一、微分方程<br>微分方程；常微分方程；偏微分方程；微分方程的阶。<br>二、微分方程的解<br>通解；初始条件；初值问题；特解；积分曲线。<br>第二节 一阶微分方程<br>一、可分离变量的方程及其求解<br>可分离变量方程；可分离变量方程的对称形式；可分离变量方程的求解。<br>二、齐次方程<br>齐次方程；齐次方程的求解；可化为齐次方程的方程。<br>三、一阶线性方程<br>一阶线性微分方程；一阶齐次线性微分方程；一阶非齐次线性方程；常数变易法；非齐<br>次线性方程的通解结构；积分因子；伯努利方程；全微分方程。<br>第三节 高阶微分方程<br>一、可降阶的高阶微分方程<br>  yxfy ),( 型微分方程；   yyfy ),( 型微分方程； )( 型微分方程。 )( xfy n <br>— 11 —11<br>二、高阶线性微分方程<br>二阶线性微分方程解的结构；叠加原理；二阶常系数齐次线性微分方程；二阶常系数非<br>齐次线性微分方程；欧拉方程；常微分方程的简单应用。<br>第二篇 线性代数<br>主要测查应试者对《线性代数》中行列式、矩阵、向量组的线性相关性、线性方程组、<br>二次型等基本概念、基本理论和基本方法的熟知程度，运用基本概念、基本理论和基本方法<br>正确地判断、推理和准确地计算，以及综合运用所学知识分析与解决实际问题的能力。<br>本篇内容包括行列式、矩阵、向量、线性方程组、矩阵的特征值和特征向量、二次型。<br>第一章 行列式<br>主要测查应试者对行列式的相关概念、性质、克拉默法则的理论的掌握程度。<br>要求应试者理解行列式的概念；掌握行列式的性质、行列式按行（列）展开定理、行列<br>式的计算、常用的高阶行列式的降阶法、升阶法、三角化方法、递推公式法和数学归纳法等<br>计算方法、克莱姆法则等基本理论和方法；了解全排列、逆序数、对换等概念。<br>本章内容主要包括 n 阶行列式的概念、行列式的性质、克莱姆法则。<br>第一节 n 阶行列式的概念<br>一、二阶行列式<br>二阶行列式；二元线性方程组。<br>二、三阶行列式<br>三阶行列式；对角线法则；三阶行列式的计算。<br>三、n 阶行列式<br>n 阶行列式的定义；对角行列式；上（下）三角形行列式；范德蒙德行列式；余子式；代<br>数余子式；行列式展开式。<br>第二节 行列式的性质<br>一、行列式的性质<br>行列式的性质；行列式的转置。<br>二、行列式的计算<br>三角行列式的值；化一般行列式为三角行列式；行列式按行（列）展开。<br>三、高阶行列式的计算<br>— 12 —<br>降阶法；三角化方法；升阶法；建立递推关系式法；数学归纳法。<br>第三节 克莱姆法则<br>一、克莱姆法则<br>克莱姆法则；利用克莱姆法则求解线性方程组。<br>二、克莱姆法则与线性方程组<br>齐次线性方程组的解与系数行列式的关系；非齐次线性方程组的解与系数行列式的关系。<br>第二章 矩阵<br>主要测查应试者对矩阵的基本理论的掌握程度。<br>要求应试者理解矩阵、单位矩阵、数量矩阵、对角矩阵、上（下）三角矩阵、对称矩阵<br>与反对称矩阵、逆矩阵、伴随矩阵、矩阵初等变换、分块矩阵、矩阵的秩等概念，掌握矩阵<br>的性质、矩阵的运算、逆矩阵的性质、矩阵可逆的充分必要条件、方阵的幂与方阵乘积的行<br>列式的性质，用伴随矩阵求逆矩阵的方法、初等矩阵的性质和矩阵等价性、用初等变换求矩<br>阵的秩和逆矩阵的方法、分块矩阵的运算法则等基本理论和基本方法。<br>本章内容主要包括矩阵的概念、矩阵的运算、矩阵的分块、矩阵的初等变换、矩阵的秩。<br>第一节 矩阵的概念<br>一、矩阵的定义<br>元素；mn 矩阵；矩阵的相等。<br>二、特殊矩阵<br>列向量（矩阵）；行向量（矩阵）；同型矩阵；零矩阵；方阵；幂矩阵；对角矩阵；数<br>量矩阵；单位矩阵；三角矩阵；伴随矩阵。<br>第二节 矩阵的运算<br>一、矩阵的线性运算<br>矩阵的加减法；矩阵的数乘；矩阵的线性运算。<br>二、矩阵的乘法<br>矩阵的乘法；矩阵的乘法运算；可交换矩阵。<br>三、方阵的行列式<br>方阵的行列式；方阵的行列式的运算。<br>四、矩阵的幂与多项式<br>— 13 —13<br>矩阵的幂；矩阵的多项式。<br>五、矩阵的转置<br>转置矩阵；矩阵转置的运算；对称矩阵；反对称矩阵。<br>六、矩阵的逆<br>可逆矩阵；逆矩阵的性质；利用伴随矩阵求逆矩阵；利用逆矩阵解矩阵方程。<br>第三节 矩阵的分块<br>一、分块矩阵的概念<br>st 分块矩阵；分块三角矩阵；分块对角矩阵。<br>二、分块矩阵的运算<br>分块矩阵的加法；分块矩阵的数乘；分块矩阵的乘法；分块矩阵的转置；分块矩阵的逆。<br>三、线性方程组的矩阵表示<br>系数矩阵；增广矩阵；矩阵方程。<br>第四节 矩阵的初等变换<br>一、初等行变换与初等列变换<br>对调行（列）变换；倍乘行（列）变换；倍加行（列）变换；阶梯矩阵；最简阶梯矩阵。<br>二、等价矩阵<br>矩阵的等价；矩阵的标准形。<br>三、初等矩阵<br>对调矩阵；倍乘矩阵；倍加矩阵；初等变换与对应的初等矩阵的关系。<br>四、求逆矩阵的初等变换法<br>矩阵可逆的充要条件；矩阵等价的充要条件；求逆矩阵的初等变换法；解矩阵方程的初<br>等变换法。<br>第五节 矩阵的秩<br>一、矩阵秩的概念及简单性质<br>k 阶子式；矩阵的秩；矩阵秩的简单性质。<br>二、线性方程组解的判别准则<br>线性方程组无解、有唯一解、有无穷多解的充要条件；齐次线性方程组有非零解的充要<br>条件；初等变换求解线性方程组；矩阵方程有解的充要条件。<br>三、满秩矩阵<br>— 14 —<br>行满秩矩阵；列满秩矩阵；满秩矩阵；降秩矩阵；满秩矩阵的充分条件。<br>第三章 向量<br>主要测查应试者对向量组的线性相关性和秩、线性方程组解的结构、向量空间、欧几里<br>得（Euclid）空间的掌握程度。<br>要求应试者理解 n 维向量、向量的线性组合、线性表示、向量组的线性相关、线性无关、<br>极大线性无关组、向量组的秩、向量组等价、n 维向量空间、子空间、基、维数、坐标、基变<br>换和坐标变换公式、过渡矩阵、内积、规范正交基、正交矩阵等概念，掌握向量组线性相关、<br>线性无关的性质及判别法，向量组的极大线性无关组及秩的计算，矩阵的秩与其行（列）向<br>量组的秩之间的关系、线性无关向量组正交规范化的施密特（Schmidt）方法、正交变换的性<br>质等基本理论和基本方法。<br>本章内容主要包括向量组及其线性相关性、向量组的秩、向量空间、n 维欧几里得空间。<br>第一节 向量组及其线性相关性<br>一、n 维向量<br>n 维向量；分量；零向量；n 维单位向量。<br>二、向量由向量组的线性表示<br>矩阵的列向量组、行向量组；线性组合；向量的线性表示；向量线性表示的充要条件。<br>三、向量组的线性相关性<br>线性相关、线性无关；线性无关的充要条件、充分条件、必要条件；线性相关与线性表<br>示的内在联系；初等行（列）变换与矩阵列（行）向量组的线性相关性。<br>第二节 向量组的秩<br>一、等价向量组<br>两个向量组的等价；一个向量组被另一个向量组线性表示的充要条件、充分条件、必要<br>条件；向量组等价的充要条件。<br>二、向量组的极大线性无关组与秩<br>向量组的极大线性无关组；极大线性无关组的等价定义；向量组的秩；矩阵的列秩、行<br>秩与秩的关系。<br>第三节 向量空间<br>一、向量空间的概念<br>— 15 —15<br>向量空间；运算的封闭性；零空间；生成的向量空间；子空间。<br>二、向量空间的基与维数<br>基；维数；n 维向量空间；自然基；坐标。<br>三、基变换和坐标变换<br>过渡矩阵；基变换公式；坐标变换公式。<br>第四节 n 维欧几里得空间<br>一、向量的内积<br>实向量的内积；n 维欧几里得空间；内积的性质；长度（范数）；长度的性质；向量的夹<br>角；正交。<br>二、正交向量组<br>正交向量组；标准正交向量组；正交向量组的性质；正交基；规范正交基；施密特正交<br>化方法。<br>三、正交矩阵与正交变换<br>正交矩阵；正交矩阵的充要条件；正交变换；正交变换的性质。<br>第四章 线性方程组<br>主要测查应试者对线性方程组基本概念、线性方程组的求解和解的结构理论的掌握程度。<br>要求应试者理解线性方程组、通解、解空间、基础解系等概念；掌握齐次线性方程组有<br>非零解的充分必要条件、非齐次线性方程组有解的充分必要条件、齐次线性方程组的解空间<br>的理论、齐次线性方程组的基础解系和通解的求法、非齐次线性方程组解的结构及通解、初<br>等行变换求解线性方程组的方法等基本理论和基本方法。<br>本章内容主要包括线性方程组的基本概念、线性方程组的消元法、线性方程组解的结构。<br>第一节 线性方程组的基本概念<br>一、线性方程<br>n 元线性方程；线性方程的几何意义。<br>二、线性方程组的表示与解<br>mn 线性方程组；线性方程组的几何意义；线性方程组的解；同解方程组；相容（有解）<br>方程组；矛盾（无解）方程组；解向量；通解；特解。<br>三、线性方程组的分类<br>齐次线性方程组；非齐次线性方程组。<br>— 16 —<br>第二节 线性方程组的消元法<br>一、线性方程组的初等变换<br>对调变换；倍乘变换；倍加变换；初等变换的性质；消元法。<br>二、化一般方程组为阶梯方程组<br>自由未知量；基本未知量；阶梯方程组；非齐次线性方程组解的判别；齐次线性方程组<br>有非零解的判别准则。<br>第三节 线性方程组解的结构<br>一、齐次线性方程组解的结构<br>齐次线性方程组的解对线性运算的封闭性；解空间；基础解系；求基础解系的方法；齐<br>次线性方程组的通解。<br>二、非齐次线性方程组解的结构<br>导出方程组；齐次线性方程组的解与非齐次线性方程组解的关系；非齐次线性方程组解<br>的结构；初等行变换法求非齐次线性方程组的解。<br>第五章 矩阵的相似化简<br>主要测查应试者对矩阵的特征值理论、相似矩阵、实对称矩阵对角化理论的掌握程度。<br>要求应试者理解矩阵的特征值和特征向量、相似矩阵等概念，掌握矩阵特征值的性质，<br>矩阵的特征值和特征向量的计算、矩阵可相似对角化的充分必要条件、将矩阵化为相似对角<br>矩阵的方法、实对称矩阵的特征值和特征向量的性质等基本理论和基本方法。<br>本章内容主要包括特征值与特征向量、矩阵的相似对角化、实对称矩阵的对角化。<br>第一节 特征值与特征向量<br>一、特征值与特征向量的概念<br>特征值、特征向量；特征多项式；特征方程。<br>二、特征值与特征向量的性质和计算<br>特征值和特征向量的性质；特征值和特征向量的计算；矩阵的迹；矩阵的特征值与矩阵<br>的关系；相异特征值对应的特征向量。<br>三、相似矩阵的概念和性质<br>相似矩阵；相似变换；相似矩阵的性质；相似矩阵的特征值和迹。<br>— 17 —17<br>第二节 矩阵的相似对角化<br>一、相似对角化的条件和方法<br>矩阵的对角化；n 阶矩阵可对角化的充要条件；n 阶矩阵可对角化的充分条件；n 阶矩阵<br>相似对角化的步骤。<br>二、可对角化矩阵的多项式<br>对角矩阵的幂；可对角化矩阵的多项式。<br>第三节 实对称矩阵的对角化<br>一、实对称矩阵的特征值与特征向量<br>实对称矩阵的特征值及特征向量的性质；实对称矩阵的相似正交对角化。<br>第六章 二次型<br>主要测查应试者对二次型的矩阵表示和标准形、实二次型的规范形、正定二次型的掌握<br>程度。<br>要求应试者理解合同矩阵、二次型、正定二次型、正定矩阵、二次型秩等概念；掌握二<br>次型及其矩阵表示、二次型的标准形、实二次型的规范形、用正交变换化实二次型为标准形、<br>化二次型为标准形的配方法和合同初等变换法、惯性定理和实二次型的正惯性指数、负惯性<br>指数以及判别二次型和矩阵的正定性的方法等理论。<br>本章内容主要包括二次型及其矩阵表示、二次型的标准形、正定二次型。<br>第一节 二次型及其矩阵表示<br>一、二次型的概念<br>二次型；二次型的矩阵表示；二次型的矩阵；二次型的秩；标准形；规范形。<br>二、可逆线性变换<br>实线性变换；可逆的（满秩的或非退化的）线性变换；合同矩阵；合同初等变换。<br>第二节 二次型的标准形<br>一、正交变换法<br>正交变换及性质；用正交变换化二次型为标准形；用配方法化二次型为标准形。<br>二、实二次型的规范形<br>实二次型的规范形；惯性定理；正惯性指数；负惯性指数。<br>— 18 —<br>第三节 正定二次型<br>一、正定二次型<br>正定二次型；实二次型正定的充要条件。<br>二、正定矩阵<br>正定矩阵；实对称矩阵正定的充要条件。<br>第三篇 概率论与数理统计<br>主要测查应试者对概率论与数理统计中的随机变量及其分布、随机变量的数字特征、参<br>数估计、假设检验等理论的熟知程度，运用基本概念、基本理论和基本方法正确地判断、推<br>理和准确地计算，以及综合运用所学知识分析与解决实际问题的能力。<br>本篇内容包括概率论的基本概念、随机变量及其分布、多维随机变量及其分布、随机变<br>量的数字特征、大数定律及中心极限定理、样本及抽样分布、参数估计、假设检验。<br>第一章 概率论的基本概念<br>主要测查应试者对随机试验、样本空间、随机事件、事件的关系与运算、频率与概率、<br>概率的性质、古典概型、几何概型、条件概率、全概率公式和贝叶斯公式、事件的独立性的<br>掌握程度。<br>要求应试者理解随机试验、样本空间、随机事件、频率、概率、条件概率、事件的独立<br>性等概念，掌握事件的关系与运算、频率和概率的性质、全概率公式、贝叶斯公式等基本理<br>论与基本方法；会利用事件的独立性计算概率；了解几何概型。<br>本章内容主要包括样本空间、频率与概率、等可能概型、条件概率、独立性。<br>第一节 样本空间<br>一、样本空间<br>随机试验；样本空间。<br>二、随机事件<br>随机事件；事件发生；基本事件；必然事件；不可能事件。<br>三、事件的关系与运算<br>事件的相等；事件的和；事件的积；事件的差；不相容（互斥）事件；对立事件；事件<br>运算的交换律、结合律、分配律、德摩根律。<br>— 19 —19<br>第二节 频率与概率<br>一、频率<br>频数；频率；频率的基本性质。<br>二、概率<br>概率的定义；非负性；规范性；可列可加性；有限可加性；对立事件的概率；加法公式。<br>第三节 等可能概型<br>一、等可能概型<br>等可能概型；等可能概型的计算；几何概型。<br>二、抽样方式<br>放回抽样；不放回抽样。<br>三、实际推断原理<br>实际推断原理；实际推断原理的应用。<br>第四节 条件概率<br>一、条件概率<br>条件概率；乘法定理。<br>二、全概率公式和贝叶斯公式<br>样本空间的划分；全概率公式；贝叶斯公式；先验概率；后验概率。<br>第五节 独立性<br>一、两个事件相互独立<br>两个事件相互独立性；相互独立事件的性质。<br>二、多个事件相互独立<br>多个事件相互独立性；多个事件相互独立性的应用。<br>第二章 随机变量及其分布<br>主要测查应试者对随机变量、分布函数、离散型随机变量及其分布律、连续型随机变量<br>及其概率密度、随机变量的函数的分布的掌握程度。<br>要求应试者理解随机变量、分布函数、离散型随机变量、连续型随机变量、概率密度等<br>概念，掌握分布函数的性质、与随机变量相联系的事件的概率的计算、离散型随机变量及其<br>分布律、0-1分布、二项分布、几何分布、泊松（Poisson）分布及其应用、泊松定理和应用、<br>— 20 —<br>连续型随机变量及其概率密度、均匀分布、指数分布、Γ分布、正态分布及其应用、随机变<br>量的函数的分布等基本理论与基本方法。<br>本章内容主要包括随机变量及其分布函数、离散型随机变量、连续型随机变量、随机变<br>量的函数的分布。<br>第一节 随机变量及其分布函数<br>一、随机变量<br>随机变量的概念；随机变量的表示；随机变量的取值与随机试验结果的对应关系。<br>二、分布函数<br>分布函数的概念；分布函数的基本性质。<br>第二节 离散型随机变量<br>一、离散型随机变量及其分布律<br>离散型随机变量的概念；分布律；分布律的性质。<br>二、常用的离散型随机变量<br>0-1分布；二项分布；几何分布；泊松（Poisson）分布；泊松定理的应用条件。<br>第三节 连续型随机变量<br>一、连续型随机变量及其分布律<br>连续型随机变量的概念；概率密度；概率密度的性质。<br>二、常用的连续型随机变量<br>均匀分布；指数分布；Γ分布；正态分布。<br>第四节 随机变量的函数的分布<br>一、离散型随机变量函数的分布<br>随机变量函数的分布；离散型随机变量函数的分布的计算。<br>二、连续型随机变量函数的分布<br>连续型随机变量函数的分布的计算；连续型随机变量的严格单调函数的概率密度。<br>第三章 多维随机变量及其分布<br>主要测查应试者对多维随机变量及其分布、二维离散型随机变量及其分布律、边缘分布<br>律、条件分布律、二维连续型随机变量及其概率密度、边缘概率密度、条件概率密度、相互<br>— 21 —21<br>独立的随机变量、常用二维随机变量的分布、两个随机变量的函数的分布的掌握程度。<br>要求应试者理解多维随机变量、多维随机变量的分布等概念，掌握多维随机变量的分布<br>的性质、二维离散型随机变量及其分布律、边缘分布律和条件分布律、二维连续型随机变量<br>的概率密度、边缘密度和条件密度、二维均匀分布、二维正态分布的概率密度、二维随机变<br>量相关的事件的概率、随机变量的独立性、两个随机变量的函数的分布、多个相互独立随机<br>变量简单函数的分布等基本理论与基本方法。<br>本章内容主要包括多维随机变量、二维离散型随机变量、二维连续型随机变量、相互独<br>立的随机变量、两个随机变量的函数的分布。<br>第一节 多维随机变量<br>一、二维随机变量<br>二维随机变量；二维随机变量的联合分布函数及其性质；二维离散型随机变量的联合分<br>布律及其性质；二维连续型随机变量的联合概率密度及其性质。<br>二、n 维随机变量<br>n 维随机变量；n 维随机变量的联合分布函数。<br>第二节 二维离散型随机变量<br>一、二维离散型随机变量的边缘分布<br>二维随机变量的边缘分布函数；二维离散型随机变量的边缘分布律。<br>二、二维离散型随机变量的条件分布<br>二维离散型随机变量的条件分布律；联合分布律、边缘分布律和条件分布律的关系。<br>第三节 二维连续型随机变量<br>一、二维连续型随机变量的边缘分布<br>二维连续型随机变量的边缘概率密度；二维正态分布。<br>二、二维连续型随机变量的条件分布<br>二维随机变量的条件分布函数；二维连续型随机变量的条件概率密度；联合概率密度、<br>边缘概率密度和条件概率密度的关系。<br>第四节 相互独立的随机变量<br>一、两个相互独立的随机变量<br>两个随机变量相互独立的概念；两个离散型随机变量相互独立的充要条件；两个连续型<br>— 22 —<br>随机变量相互独立的充要条件。<br>二、n 个相互独立的随机变量<br>n 个随机变量相互独立的概念；两组随机变量相互独立的概念及性质。<br>第五节 两个随机变量的函数的分布<br>一、和分布<br>两个随机变量和的概率密度；卷积公式；有限个相互独立的正态随机变量的线性组合的<br>分布；Γ分布及其可加性。<br>二、商分布和积分布<br>两个随机变量商的概率密度；两个随机变量积的概率密度。<br>三、相互独立的随机变量的最大值、最小值分布<br>两个相互独立的随机变量的最大值、最小值的分布；n 个相互独立的随机变量的最大值、<br>最小值的分布。<br>第四章 随机变量的数字特征<br>主要测查应试者对数学期望、方差、协方差、相关系数、矩、协方差矩阵的掌握程度。<br>要求应试者理解随机变量的数学期望、随机变量协方差、相关系数、随机变量不相关的<br>概念；掌握随机变量的数学期望的性质、常用分布的数学期望、随机变量的方差、标准差的<br>性质、常用分布的方差、随机变量协方差、相关系数的性质、切比雪夫不等式。掌握随机变<br>量的矩、协方差矩阵。<br>本章内容主要包括数学期望与方差，协方差、相关系数、矩、协方差矩阵。<br>第一节 数学期望与方差<br>一、数学期望<br>数学期望的概念；随机变量函数的数学期望；数学期望的性质。<br>二、方差<br>方差的概念；方差的性质；切比雪夫不等式。<br>第二节 协方差、相关系数、矩、协方差矩阵<br>一、协方差<br>协方差的概念；协方差的性质。<br>二、相关系数<br>— 23 —23<br>相关系数的概念；相关系数的性质；不相关的概念。<br>三、矩、协方差矩阵<br>一个随机变量的原点矩、中心矩；两个随机变量的混合矩、混合中心矩；协方差矩阵；<br>多维正态随机变量的性质。<br>第五章 大数定律及中心极限定理<br>主要测查应试者对依概率收敛、切比雪夫（Chebyshev）大数定律、辛钦（Khintchine）大<br>数定律、伯努利（Bernoulli）大数定律、独立同分布随机变量和的中心极限定理、李雅普诺夫<br>（Liapunov）中心极限定理、棣莫夫-拉普拉斯（DeMoivre-Laplace）中心极限定理的掌握程度。<br>要求应试者掌握切比雪夫大数定律、辛钦大数定律、伯努利大数定律、依概率收敛、独<br>立同分布的中心极限定理、李雅普诺夫中心极限定理、棣莫夫-拉普拉斯中心极限定理等基本<br>理论与基本方法。<br>本章内容主要包括大数定理、中心极限定理。<br>第一节 大数定律<br>一、依概率收敛<br>依概率收敛的概念；依概率收敛的性质。<br>二、大数定律<br>切比雪夫大数定律；辛钦大数定律；伯努利大数定律。<br>第二节 中心极限定理<br>一、独立同分布随机变量和的中心极限定理<br>随机变量的标准化；独立同分布随机变量和的中心极限定理。<br>二、李雅普诺夫中心极限定理、棣莫夫-拉普拉斯中心极限定理<br>李雅普诺夫中心极限定理；棣莫夫-拉普拉斯中心极限定理。<br>第六章 样本及抽样分布<br>主要测查应试者对总体与个体、简单随机样本、样本统计量、经验分布函数、样本均值、<br>样本方差、样本矩、正态总体的常用抽样分布的掌握程度。<br>要求应试者理解总体与个体、简单随机样本、统计量、经验分布函数等概念；掌握样本<br>均值、样本方差及样本矩的计算、格里汶科（Glivenko）定理、统计学的三大分布、正态总体<br>的常用抽样分布等基本理论与基本方法。<br>— 24 —<br>本章内容主要包括随机样本、直方图和箱线图，抽样分布。<br>第一节 随机样本、直方图和箱线图<br>一、随机样本<br>总体及其容量；个体；有限总体；无限总体；简单随机样本；样本值；直方图。<br>二、直方图<br>直方图；样本中位数。<br>第二节 抽样分布<br>一、统计量<br>统计量的概念；样本均值；样本方差；样本标准差；样本矩；经验分布函数。<br>二、抽样分布<br>正态分布； x^2^ 分布；t 分布；F 分布；分位点；正态总体的样本均值与样本方差的分布。<br>第七章 参数估计<br>主要测查应试者对点估计、估计量与估计值、矩估计法、最大似然估计、估计量的评选<br>标准、区间估计、单个正态总体的均值和方差的区间估计、两个正态总体的均值差和方差比<br>的区间估计的掌握程度。<br>要求应试者理解参数的点估计、估计量与估计值、估计量的无偏性、有效性和相合性、<br>区间估计等概念；掌握矩估计、最大似然估计、估计量的无偏性、估计量的有效性、单个正<br>态总体的均值和方差的置信区间、两个正态总体的均值差和方差比的置信区间等基本理论与<br>基本方法。<br>本章内容主要包括点估计、区间估计。<br>第一节 点估计<br>一、矩估计法<br>矩估计法；矩估计量；矩估计值。<br>二、最大似然估计法<br>似然函数；最大似然估计值；最大似然估计量；对数似然方程；对数似然方程组；最大<br>似然估计的不变性。<br>三、估计量的评选标准<br>无偏性；有效性；相合性。<br>— 25 —25<br>第二节 区间估计<br>一、区间估计的基本概念<br>置信区间；置信下限；置信上限；置信水平。<br>二、正态总体的均值和方差的置信区间<br>正态总体常用抽样的分布；正态总体的均值和方差的置信区间。<br>三、单侧置信区间、（0-1）分布参数的区间估计<br>单侧置信区间；单侧置信下限；单侧置信上限；（0-1）分布参数的区间估计。<br>第八章 假设检验<br>主要测查应试者对显著性检验、假设检验的两类错误、单个及两个正态总体的均值和方<br>差的假设检验、分布拟合检验的掌握程度。<br>要求应试者理解假设检验的基本思想；掌握单个正态总体均值和方差的假设检验、两个<br>正态总体的均值差和方差比的假设检验、假设检验与区间估计的关系等基本理论和基本方法；<br>了解分布拟合检验、检验可能产生的两类错误。<br>本章内容主要包括假设检验、正态总体均值的假设检验、正态总体方差的假设检验、分<br>布拟合检验。<br>第一节 假设检验<br>一、检验问题<br>原假设；备择假设；检验统计量；显著性水平；拒绝域；临界点。<br>二、显著性检验<br>双边检验；双边备择假设；单边检验。</p>
<h5 id="第二节-正态总体均值的假设检验"><a href="#第二节-正态总体均值的假设检验" class="headerlink" title="第二节 正态总体均值的假设检验"></a>第二节 正态总体均值的假设检验</h5><p><strong>一、单个总体均值的假设检验</strong><br>单个总体均值的 Z 检验法；单个总体均值的 t 检验法。<br><strong>二、两个总体均值差的假设检验</strong><br>两个总体均值差的 Z 检验法；两个总体均值差的 t 检验法。<br><strong>三、基于成对数据的检验</strong><br>逐对比较法；基于成对数据的 t 检验法。</p>
<h5 id="第三节-正态总体方差的假设检验"><a href="#第三节-正态总体方差的假设检验" class="headerlink" title="第三节 正态总体方差的假设检验"></a>第三节 正态总体方差的假设检验</h5><p><strong>一、单个总体方差的假设检验</strong><br>单个总体方差的双边检验；单个总体方差的单边检验。<br><strong>二、两个总体方差的假设检验</strong><br>两个总体方差的双边检验；两个总体方差的单边检验。<br><strong>三、基于成对数据的检验</strong><br>逐对比较法；基于成对数据的 F 检验法。</p>
<h5 id="第四节-分布拟合检验"><a href="#第四节-分布拟合检验" class="headerlink" title="第四节 分布拟合检验"></a>第四节 分布拟合检验</h5><p><strong>一、单个分布的 x^2^ 拟合检验法</strong><br>单个分布的 x^2^ 拟合检验的问题；单个分布的 x^2^ 拟合检验法。<br><strong>二、分布族的 x^2^ 拟合检验</strong><br>分布族的 x^2^ 拟合检验问题；分布族的 x^2^ 拟合检验方法。</p>
]]></content>
      <categories>
        <category>公考</category>
      </categories>
      <tags>
        <tag>公考</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客：Next主题使用手册</title>
    <url>/posts/50664caf.html</url>
    <content><![CDATA[<p>使用了好多 Hexo 博客主题主题，最后还是感觉 Next 主题要好一些。</p>
<span id="more"></span>

<p>目前最新版(Next8.0-r4)在线文档为：</p>
<ul>
<li><a href="https://theme-next.js.org/docs/">https://theme-next.js.org/docs/</a></li>
</ul>
<p>Next主题被分为了三个版本系列，并存储在不同仓库中：</p>
<ul>
<li>2014-2017 <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></li>
<li>2018-2019 <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></li>
<li>2020 <a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></li>
</ul>
<h2 id="去掉地址上的-more"><a href="#去掉地址上的-more" class="headerlink" title="去掉地址上的#more"></a>去掉地址上的<code>#more</code></h2><p>找到<code>/theme/hexo-theme-next/layout/_macro/post.njk</code>文件中的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(post.path) &#125;&#125;#more&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;contents&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>去掉<code>#more</code>。</p>
<h2 id="文章详情链接改造"><a href="#文章详情链接改造" class="headerlink" title="文章详情链接改造"></a>文章详情链接改造</h2><p>插件：<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇词 | 这一次，让我们一起来搞懂MySQL</title>
    <url>/posts/cf232bbf.html</url>
    <content><![CDATA[<p>你好，我是林晓斌，网名“丁奇”，欢迎加入我的专栏，和我一起开始MySQL学习之旅。我曾先后在百度和阿里任职，从事MySQL数据库方面的工作，一步步地从一个数据库小白成为MySQL内核开发人员。回想起来，从我第一次带着疑问翻MySQL的源码查到答案至今，已经有十个年头了。在这个过程中，走了不少弯路，但同时也收获了很多的知识和思考，希望能在这个专栏里分享给你。</p>
<span id="more"></span>

<p>记得刚开始接触MySQL，是我在百度贴吧做权限系统的时候。我们遇到了一个奇怪的问题，一个正常10毫秒就能完成的SQL查询请求偶尔要执行100多毫秒才结束。当时主管问我是什么原因，我其实也搞不清楚，就上网查答案，但怎么找都找不到，又脸皮薄不想说自己不知道，只好硬着头皮翻源码。后来遇到了越来越多的问题，也是类似的情景，所以我逐步养成了通过分析源码理解原理的习惯。</p>
<p>当时，我自己的感觉是，即使我只是一个开发工程师，只是MySQL的用户，在了解了一个个系统模块的原理后，再来使用它，感觉是完全不一样的。当在代码里写下一行数据库命令的时候，我就能想到它在数据库端将怎么执行，它的性能是怎么样的，怎样写能让我的应用程序访问数据库的性能最高。进一步，哪些数据处理让数据库系统来做性能会更好，哪些数据处理在缓存里做性能会更好，我心里也会更清楚。在建表和建索引的时候，我也会更有意识地为将来的查询优化做综合考虑，比如确定是否使用递增主键、主键的列怎样选择，等等。</p>
<p>但随后我又有了一个新的困惑，我觉得自己了解的MySQL知识点是零散的，没有形成网络。于是解决完一个问题后，很容易忘记。再碰到类似的问题，我又得再翻一次代码。</p>
<p>所幸在阿里工作的时候，我参与了阿里云关系型数据库服务内核的开发，并且负责开发开源分支AliSQL，让我对MySQL内核和源码有了更深层次的研究和理解。在服务内部客户和公有云客户的过程中，我有机会面对和解决足够多的问题，再通过手册进行系统的学习，算是比较坎坷地将MySQL的知识网络补了起来。</p>
<p>所以，在回顾这个过程的时候，我的第一个感受是，如果一开始就有一些从理论到实战的系统性指导，那该多好啊，也许我可以学习得更快些。</p>
<p>在极客时间团队跟我联系策划这个专栏的时候，我还是持怀疑态度的。为什么呢？现在不比当年了，犹记得十余年前，你使用MySQL的过程中碰到问题的话，基本上都只能到代码里去找答案，因为那时网上的资料太少了。</p>
<p>而近十年来，MySQL在中国广泛普及，技术分享文章可以说是浩如烟海。所以，现在要系统地介绍一遍MySQL的话，恐怕里面提及的大多数知识点，都可以在社区文章中找到。那么我们做这个专栏的意义在哪里，而它又凭什么可以收费呢？</p>
<p>直到收到极客时间团队的答复，我才开始对这个专栏“想做和可以做”的事情感觉清晰起来。数据库是一个综合系统，其背后是发展了几十年的数据库理论。同时，数据库系统也是一个应用系统，可能一个业务开发人员用了两三年MySQL，还未必清楚那些自己一直在用的“最佳实践”为什么是最佳的。</p>
<p>于是，我希望这个专栏能够帮助这样的一些开发者：他们正在使用MySQL，知道如何写出逻辑正确的SQL语句来实现业务目标，却不确定这个语句是不是最优的；他们听说了一些使用数据库的最佳实践，但是更想了解为什么这么做；他们使用的数据库偶尔会出问题，亟需了解如何更快速、更准确地定位问题，甚至自己解决问题……</p>
<p>在过去的七年里，我带过十几个应届毕业生，看着他们成长，要求他们原理先行，再实践验证。几年下来，他们的成长速度都很快，其中好几个毕业没两年就成为团队的骨干力量了。我也在社招的时候面试过很多有着不错的运维实践经验和能力的候选人，但都因为对数据库原理仅有一知半解的了解，而最终遗憾地没有通过面试。</p>
<p>因此，我希望这个专栏能够激发开发者对数据库原理的探索欲，从而更好地理解工作中遇到的问题，更能知道背后的为什么。所以我会选那些平时使用数据库时高频出现的知识，如事务、索引、锁等内容构成专栏的主线。这些主线上是一个个的知识点。每个点就是一个概念、一个机制或者一个原理说明。在每个说明之后，我会和你讨论一个实践相关的问题。</p>
<p>希望能以这样的方式，让你对MySQL的几条主线有一个整体的认识，并且了解基本概念。在之后的实践篇中，我会引用到这些主线的知识背景，并着力说明它们是怎样指导实践的。这样，你可以从点到线，再到面，形成自己的MySQL知识网络。</p>
<p>在这里，有一份目录，你也可以先了解下整个专栏的知识结构。</p>
<p><img src="https://flzc.gitee.io/mynote/blog/a78db0b99bbf1149c39b7960f7183c7e.webp.jpg"></p>
<p>如前面说的，这几条主线上的每个知识点几乎都不是最新的，有些甚至十年前就这样，并没有改过。但我希望针对这些点的说明，可以让你在使用MySQL时心里更有底，知道怎么做选择，并且明白为什么。了解了原理，才能在实践中不断创新，提升个人的价值和工作输出。</p>
<p>从这里开始，跟我一起搞懂MySQL!</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>常用特殊字符图案</title>
    <url>/posts/d1ea0eaa.html</url>
    <content><![CDATA[<p>整理了一波文本图案。</p>
<span id="more"></span>



<h2 id="♟🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥"><a href="#♟🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥" class="headerlink" title="♟🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥"></a>♟🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥</h2><h2 id="😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑"><a href="#😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑" class="headerlink" title="😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑"></a>😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑</h2><h2 id="😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞"><a href="#😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞" class="headerlink" title="😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞"></a>😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞</h2><h2 id="😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻"><a href="#😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻" class="headerlink" title="😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻"></a>😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻</h2><h2 id="👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼"><a href="#👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼" class="headerlink" title="👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼"></a>👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼</h2><h2 id="💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑"><a href="#💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑" class="headerlink" title="💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑"></a>💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑</h2><h2 id="👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋"><a href="#👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋" class="headerlink" title="👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋"></a>👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋</h2><h2 id="👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂"><a href="#👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂" class="headerlink" title="👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂"></a>👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂</h2><h2 id="🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈"><a href="#🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈" class="headerlink" title="🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈"></a>🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈</h2><h2 id="🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭"><a href="#🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭" class="headerlink" title="🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭"></a>🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭</h2><h2 id="🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳"><a href="#🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳" class="headerlink" title="🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳"></a>🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳</h2><h2 id="🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲"><a href="#🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲" class="headerlink" title="🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲"></a>🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲</h2><h2 id="🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚"><a href="#🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚" class="headerlink" title="🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚"></a>🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚</h2><h2 id="🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏"><a href="#🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏" class="headerlink" title="🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏"></a>🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏</h2><h2 id="🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜"><a href="#🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜" class="headerlink" title="🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜"></a>🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜</h2><h2 id="🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴"><a href="#🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴" class="headerlink" title="🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴"></a>🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴</h2><h2 id="🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵"><a href="#🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵" class="headerlink" title="🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵"></a>🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵</h2><h2 id="🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯"><a href="#🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯" class="headerlink" title="🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯"></a>🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯</h2><h2 id="🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌"><a href="#🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌" class="headerlink" title="🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌"></a>🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌</h2><h2 id="🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁"><a href="#🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁" class="headerlink" title="🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁"></a>🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁</h2><h2 id="🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀"><a href="#🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀" class="headerlink" title="🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀"></a>🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀</h2><h2 id="🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦"><a href="#🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦" class="headerlink" title="🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦"></a>🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦</h2><h2 id="🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩"><a href="#🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩" class="headerlink" title="🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩"></a>🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩</h2><h2 id="📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂"><a href="#📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂" class="headerlink" title="📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂"></a>📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂</h2><h2 id="🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴"><a href="#🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴" class="headerlink" title="🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴"></a>🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴</h2><h2 id="🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑"><a href="#🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑" class="headerlink" title="🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑"></a>🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑</h2><h2 id="✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣"><a href="#✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣" class="headerlink" title="✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣"></a>✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣</h2><h2 id="🔤🅰🆎🅱🆑🆒🆓ℹ🆔M🆕🆖🅾🆗🅿"><a href="#🔤🅰🆎🅱🆑🆒🆓ℹ🆔M🆕🆖🅾🆗🅿" class="headerlink" title="🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿"></a>🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿</h2><h2 id="🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵"><a href="#🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵" class="headerlink" title="🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵"></a>🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵</h2><h2 id="▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵"><a href="#▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵" class="headerlink" title="▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵"></a>▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵</h2><h2 id="♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞"><a href="#♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞" class="headerlink" title="♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞"></a>♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞</h2><h2 id="💟❣🌿🚧💒☎📟💽"><a href="#💟❣🌿🚧💒☎📟💽" class="headerlink" title="💟❣🌿🚧💒☎📟💽"></a>💟❣🌿🚧💒☎📟💽</h2><h2 id="⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂"><a href="#⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂" class="headerlink" title="⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂"></a>⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂</h2><h2 id="▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞"><a href="#▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞" class="headerlink" title="▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞"></a>▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞</h2><h2 id="❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│"><a href="#❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│" class="headerlink" title="❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│"></a>❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│</h2><h2 id="♥❣♂♀☿A✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃"><a href="#♥❣♂♀☿A✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃" class="headerlink" title="♥❣♂♀☿Ⓐ✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃"></a>♥❣♂♀☿Ⓐ✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃</h2><h2 id="♡ღツ☼☁❅♒✎©®™Σ✪✯☭➳卐√↖↗●◐Θ◤◥︻〖〗┄"><a href="#♡ღツ☼☁❅♒✎©®™Σ✪✯☭➳卐√↖↗●◐Θ◤◥︻〖〗┄" class="headerlink" title="♡ღツ☼☁❅♒✎©®™Σ✪✯☭➳卐√↖↗●◐Θ◤◥︻〖〗┄"></a>♡ღツ☼☁❅♒✎©®™Σ✪✯☭➳卐√↖↗●◐Θ◤◥︻〖〗┄</h2><h2 id="┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇"><a href="#┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇" class="headerlink" title="┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇"></a>┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇</h2><h2 id="☽☾✚〓▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾の•▸◂▴▾┈┊"><a href="#☽☾✚〓▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾の•▸◂▴▾┈┊" class="headerlink" title="☽☾✚〓▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾の•▸◂▴▾┈┊"></a>☽☾✚〓▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾の•▸◂▴▾┈┊</h2><h2 id="①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ"><a href="#①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ" class="headerlink" title="①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ"></a>①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ</h2><h2 id="㍿▓♨♛❖♓☪✙┉┋☹☺☻تヅツッシUϡﭢ™℠℗©®♥❤❥❣❦❧♡۵"><a href="#㍿▓♨♛❖♓☪✙┉┋☹☺☻تヅツッシUϡﭢ™℠℗©®♥❤❥❣❦❧♡۵" class="headerlink" title="㍿▓♨♛❖♓☪✙┉┋☹☺☻تヅツッシÜϡﭢ™℠℗©®♥❤❥❣❦❧♡۵"></a>㍿▓♨♛❖♓☪✙┉┋☹☺☻تヅツッシÜϡﭢ™℠℗©®♥❤❥❣❦❧♡۵</h2><h2 id="웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣♥♦☜☞☝✍"><a href="#웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣♥♦☜☞☝✍" class="headerlink" title="웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣♥♦☜☞☝✍"></a>웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣♥♦☜☞☝✍</h2><h2 id="☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ㄨ"><a href="#☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ㄨ" class="headerlink" title="☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ㄨ"></a>☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ㄨ</h2><h2 id="✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊"><a href="#✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊" class="headerlink" title="✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊"></a>✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊</h2><h2 id="†☨✞✝☥☦☓☩☯☧☬☸✡♁✙♆。，、＇：∶；-‘’“”〝〞ˆˇ﹕︰﹔﹖"><a href="#†☨✞✝☥☦☓☩☯☧☬☸✡♁✙♆。，、＇：∶；-‘’“”〝〞ˆˇ﹕︰﹔﹖" class="headerlink" title="†☨✞✝☥☦☓☩☯☧☬☸✡♁✙♆。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖"></a>†☨✞✝☥☦☓☩☯☧☬☸✡♁✙♆。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖</h2><h2 id="﹑•¨…-¸-！´？！～—ˉ｜‖＂〃｀-﹫¡¿﹏﹋﹌︴々"><a href="#﹑•¨…-¸-！´？！～—ˉ｜‖＂〃｀-﹫¡¿﹏﹋﹌︴々" class="headerlink" title="﹑•¨….¸;！´？！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々"></a>﹑•¨….¸;！´？！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々</h2><h2 id="﹟-﹩-﹠-﹪-﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎"><a href="#﹟-﹩-﹠-﹪-﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎" class="headerlink" title="﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+&#x3D;&lt;＿_-\ˇ~﹉﹊（）"></a>﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+&#x3D;&lt;＿_-\ˇ~﹉﹊（）</h2><h2 id="〈〉‹›﹛﹜『』〖〗［］《》〔〕-「」【】"><a href="#〈〉‹›﹛﹜『』〖〗［］《》〔〕-「」【】" class="headerlink" title="〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】"></a>〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】</h2><h2 id="︵︷︿︹︽-﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼"><a href="#︵︷︿︹︽-﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼" class="headerlink" title="︵︷︿︹︽_﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼"></a>︵︷︿︹︽_﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼</h2><h2 id="☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍"><a href="#☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍" class="headerlink" title="☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍"></a>☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍</h2><h2 id="⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈"><a href="#⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈" class="headerlink" title="⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈"></a>⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈</h2><h2 id="≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦"><a href="#≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦" class="headerlink" title="≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦"></a>≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦</h2><h2 id="≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳-℅‰‱"><a href="#≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳-℅‰‱" class="headerlink" title="≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱"></a>≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱</h2><h2 id="㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯"><a href="#㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯" class="headerlink" title="㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯"></a>㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯</h2><h2 id="㊰㊙㉿囍♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ"><a href="#㊰㊙㉿囍♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ" class="headerlink" title="㊰㊙㉿囍♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ"></a>㊰㊙㉿囍♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ</h2><h2 id="♪♫♩♬♭♮♯°oA☮✌☪✡☭✯卐✐✎✏✑✒✍✉✁✂✃✄✆✉"><a href="#♪♫♩♬♭♮♯°oA☮✌☪✡☭✯卐✐✎✏✑✒✍✉✁✂✃✄✆✉" class="headerlink" title="♪♫♩♬♭♮♯°øⒶ☮✌☪✡☭✯卐✐✎✏✑✒✍✉✁✂✃✄✆✉"></a>♪♫♩♬♭♮♯°øⒶ☮✌☪✡☭✯卐✐✎✏✑✒✍✉✁✂✃✄✆✉</h2><h2 id="☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔"><a href="#☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔" class="headerlink" title="☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔"></a>☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔</h2><h2 id="↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻"><a href="#↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻" class="headerlink" title="↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻"></a>↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻</h2><h2 id="↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪"><a href="#↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪" class="headerlink" title="↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪"></a>↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪</h2><h2 id="➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉"><a href="#➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉" class="headerlink" title="➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉"></a>➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉</h2><h2 id="ABCDEFGHIJKLMNOPQRSTUVWXYZ"><a href="#ABCDEFGHIJKLMNOPQRSTUVWXYZ" class="headerlink" title="ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ"></a>ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ</h2><h2 id="abcdefghijklmnopqrstuvwxyz"><a href="#abcdefghijklmnopqrstuvwxyz" class="headerlink" title="ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ"></a>ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ</h2><h2 id="⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵"><a href="#⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵" class="headerlink" title="⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵"></a>⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵</h2><h2 id="ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺ"><a href="#ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺ" class="headerlink" title="ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺ"></a>ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺ</h2><h2 id="ⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫"><a href="#ⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫" class="headerlink" title="ⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫"></a>ⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫</h2><h2 id="┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘"><a href="#┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘" class="headerlink" title="┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘"></a>┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘</h2><h2 id="╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀"><a href="#╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀" class="headerlink" title="╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀"></a>╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀</h2><h2 id="▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥"><a href="#▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥" class="headerlink" title="▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥"></a>▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥</h2><h2 id="▦▧▨▩▪▫▬▭▮▯"><a href="#▦▧▨▩▪▫▬▭▮▯" class="headerlink" title="▦▧▨▩▪▫▬▭▮▯"></a>▦▧▨▩▪▫▬▭▮▯</h2><h2 id="㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋"><a href="#㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋" class="headerlink" title="㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋"></a>㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋</h2><h2 id="㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾"><a href="#㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾" class="headerlink" title="㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾"></a>㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾</h2><h2 id="㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘☰☲☱☴☵☶☳☷☯"><a href="#㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘☰☲☱☴☵☶☳☷☯" class="headerlink" title="㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘☰☲☱☴☵☶☳☷☯"></a>㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘☰☲☱☴☵☶☳☷☯</h2><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h2 id="♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°"><a href="#♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°" class="headerlink" title="♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°"></a>♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°</h2><h2 id="◆◇⊙■□△▽¿½☯✡㍿卍卐♂♀✚〓㎡♪♫♩♬㊚㊛囍㊒㊖Φ"><a href="#◆◇⊙■□△▽¿½☯✡㍿卍卐♂♀✚〓㎡♪♫♩♬㊚㊛囍㊒㊖Φ" class="headerlink" title="◆◇⊙■□△▽¿½☯✡㍿卍卐♂♀✚〓㎡♪♫♩♬㊚㊛囍㊒㊖Φ"></a>◆◇⊙■□△▽¿½☯✡㍿卍卐♂♀✚〓㎡♪♫♩♬㊚㊛囍㊒㊖Φ</h2><h2 id="♀♂‖-※卍卐Ψ♫♬♭♩♪♯♮⌒¶∮‖€￡¥"><a href="#♀♂‖-※卍卐Ψ♫♬♭♩♪♯♮⌒¶∮‖€￡¥" class="headerlink" title="#♀♂‖$@*&amp;#※卍卐Ψ♫♬♭♩♪♯♮⌒¶∮‖€￡¥$"></a>#♀♂‖$@*&amp;#※卍卐Ψ♫♬♭♩♪♯♮⌒¶∮‖€￡¥$</h2><h2 id="编号序号"><a href="#编号序号" class="headerlink" title="编号序号"></a>编号序号</h2><h2 id="①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪"><a href="#①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪" class="headerlink" title="①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪"></a>①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪</h2><h2 id="❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴"><a href="#❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴" class="headerlink" title="❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴"></a>❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴</h2><h2 id="㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩"><a href="#㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩" class="headerlink" title="㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩"></a>㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩</h2><h2 id="⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇"><a href="#⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇" class="headerlink" title="⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇"></a>⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇</h2><h2 id="⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛"><a href="#⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛" class="headerlink" title="⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛"></a>⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛</h2><h2 id="ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ"><a href="#ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ" class="headerlink" title="ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ"></a>ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ</h2><h2 id="ABCDEFGHIJKLMNOPQRSTUVWXYZ-1"><a href="#ABCDEFGHIJKLMNOPQRSTUVWXYZ-1" class="headerlink" title="ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ"></a>ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ</h2><h2 id="abcdefghijklmnopqrstuvwxyz-1"><a href="#abcdefghijklmnopqrstuvwxyz-1" class="headerlink" title="ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ"></a>ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ</h2><h2 id="⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵-1"><a href="#⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵-1" class="headerlink" title="⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵"></a>⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵</h2><h2 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h2><h2 id="─-━│┃╌╍╎╏┄-┅┆┇┈-┉┊┋┌┍┎┏┐┑┒┓└-┕┖┗-┘┙┚┛├┝┞┟┠"><a href="#─-━│┃╌╍╎╏┄-┅┆┇┈-┉┊┋┌┍┎┏┐┑┒┓└-┕┖┗-┘┙┚┛├┝┞┟┠" class="headerlink" title="─ ━│┃╌╍╎╏┄ ┅┆┇┈ ┉┊┋┌┍┎┏┐┑┒┓└ ┕┖┗ ┘┙┚┛├┝┞┟┠"></a>─ ━│┃╌╍╎╏┄ ┅┆┇┈ ┉┊┋┌┍┎┏┐┑┒┓└ ┕┖┗ ┘┙┚┛├┝┞┟┠</h2><h2 id="┡┢┣-┤┥┦┧┨┩┪┫┬-┭-┮-┯-┰-┱-┲-┳-┴-┵-┶-┷-┸-┹-┺-┻┼-┽-┾-┿"><a href="#┡┢┣-┤┥┦┧┨┩┪┫┬-┭-┮-┯-┰-┱-┲-┳-┴-┵-┶-┷-┸-┹-┺-┻┼-┽-┾-┿" class="headerlink" title="┡┢┣ ┤┥┦┧┨┩┪┫┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻┼ ┽ ┾ ┿"></a>┡┢┣ ┤┥┦┧┨┩┪┫┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻┼ ┽ ┾ ┿</h2><h2 id="╀-╁-╂-╃-╄-╅-╆-╇-╈-╉-╊-╋-╪-╫-╬═║╒╓╔-╕╖╗╘╙╚-╛╜╝╞"><a href="#╀-╁-╂-╃-╄-╅-╆-╇-╈-╉-╊-╋-╪-╫-╬═║╒╓╔-╕╖╗╘╙╚-╛╜╝╞" class="headerlink" title="╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╪ ╫ ╬═║╒╓╔ ╕╖╗╘╙╚ ╛╜╝╞"></a>╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╪ ╫ ╬═║╒╓╔ ╕╖╗╘╙╚ ╛╜╝╞</h2><h2 id="╟╠-╡╢╣╤-╥-╦-╧-╨-╩-╳╔-╗╝╚-╬-═-╓-╩-┠-┨┯-┷┏-┓┗-┛┳"><a href="#╟╠-╡╢╣╤-╥-╦-╧-╨-╩-╳╔-╗╝╚-╬-═-╓-╩-┠-┨┯-┷┏-┓┗-┛┳" class="headerlink" title="╟╠ ╡╢╣╤ ╥ ╦ ╧ ╨ ╩ ╳╔ ╗╝╚ ╬ ═ ╓ ╩ ┠ ┨┯ ┷┏ ┓┗ ┛┳"></a>╟╠ ╡╢╣╤ ╥ ╦ ╧ ╨ ╩ ╳╔ ╗╝╚ ╬ ═ ╓ ╩ ┠ ┨┯ ┷┏ ┓┗ ┛┳</h2><h2 id="⊥-﹃-﹄┌-╮-╭-╯╰"><a href="#⊥-﹃-﹄┌-╮-╭-╯╰" class="headerlink" title="⊥ ﹃ ﹄┌ ╮ ╭ ╯╰"></a>⊥ ﹃ ﹄┌ ╮ ╭ ╯╰</h2><h2 id="皇冠符号"><a href="#皇冠符号" class="headerlink" title="皇冠符号"></a>皇冠符号</h2><h2 id="♚-♛-♝-♞-♜-♟-♔-♕-♗-♘-♖"><a href="#♚-♛-♝-♞-♜-♟-♔-♕-♗-♘-♖" class="headerlink" title="♚　♛　♝　♞　♜　♟　♔　♕　♗　♘　♖"></a>♚　♛　♝　♞　♜　♟　♔　♕　♗　♘　♖</h2><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><h2 id="﹢﹣×÷±-≌∽≦≧≒﹤﹥≈≡≠-≤≥≮≯∷∶∫∮∝∞∧∨"><a href="#﹢﹣×÷±-≌∽≦≧≒﹤﹥≈≡≠-≤≥≮≯∷∶∫∮∝∞∧∨" class="headerlink" title="﹢﹣×÷±&#x2F;&#x3D;≌∽≦≧≒﹤﹥≈≡≠&#x3D;≤≥&lt;&gt;≮≯∷∶∫∮∝∞∧∨"></a>﹢﹣×÷±&#x2F;&#x3D;≌∽≦≧≒﹤﹥≈≡≠&#x3D;≤≥&lt;&gt;≮≯∷∶∫∮∝∞∧∨</h2><h2 id="∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑-‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏"><a href="#∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑-‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏" class="headerlink" title="∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑%‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏"></a>∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑%‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏</h2><h2 id="≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳-℅‰‱oOπ"><a href="#≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳-℅‰‱oOπ" class="headerlink" title="≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱øØπ"></a>≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱øØπ</h2><h2 id="爱心符号"><a href="#爱心符号" class="headerlink" title="爱心符号"></a>爱心符号</h2><h2 id="♥❣ღ♠♡♤❤❥"><a href="#♥❣ღ♠♡♤❤❥" class="headerlink" title="♥❣ღ♠♡♤❤❥"></a>♥❣ღ♠♡♤❤❥</h2><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h2 id="。，、＇：∶；-‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨…-¸-！´？"><a href="#。，、＇：∶；-‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨…-¸-！´？" class="headerlink" title="。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？"></a>。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？</h2><h2 id="！～—ˉ｜‖＂〃｀-﹫¡¿﹏﹋﹌︴々﹟-﹩-﹠-﹪-﹡"><a href="#！～—ˉ｜‖＂〃｀-﹫¡¿﹏﹋﹌︴々﹟-﹩-﹠-﹪-﹡" class="headerlink" title="！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#﹩$﹠&amp;﹪%*﹡"></a>！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#﹩$﹠&amp;﹪%*﹡</h2><h2 id="﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎-＿-ˇ-﹉﹊（）〈〉‹›﹛﹜『"><a href="#﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎-＿-ˇ-﹉﹊（）〈〉‹›﹛﹜『" class="headerlink" title="﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+&#x3D;&lt;&gt;＿_-\ˇ~﹉﹊（）〈〉‹›﹛﹜『"></a>﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+&#x3D;&lt;&gt;＿_-\ˇ~﹉﹊（）〈〉‹›﹛﹜『</h2><h2 id="』〖〗［］《》〔〕-「」【】︵︷︿︹︽-﹁﹃︻"><a href="#』〖〗［］《》〔〕-「」【】︵︷︿︹︽-﹁﹃︻" class="headerlink" title="』〖〗［］《》〔〕{}「」【】︵︷︿︹︽_﹁﹃︻"></a>』〖〗［］《》〔〕{}「」【】︵︷︿︹︽_﹁﹃︻</h2><h2 id="︶︸﹀︺︾ˉ﹂﹄︼❝❞"><a href="#︶︸﹀︺︾ˉ﹂﹄︼❝❞" class="headerlink" title="︶︸﹀︺︾ˉ﹂﹄︼❝❞"></a>︶︸﹀︺︾ˉ﹂﹄︼❝❞</h2><h2 id="单位符号"><a href="#单位符号" class="headerlink" title="单位符号"></a>单位符号</h2><h2 id="°′″＄￥〒￠￡％＠℃℉﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤-º¹²³"><a href="#°′″＄￥〒￠￡％＠℃℉﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤-º¹²³" class="headerlink" title="°′″＄￥〒￠￡％＠℃℉﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤%$º¹²³"></a>°′″＄￥〒￠￡％＠℃℉﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤%$º¹²³</h2><h2 id="货币符号"><a href="#货币符号" class="headerlink" title="货币符号"></a>货币符号</h2><h2 id="€£Ұ₴-₰¢₤¥₳₲₪₵元₣₱฿¤₡₮₭₩ރ円₢₥₫₦zl﷼₠₧₯₨Kcर₹f₸￠"><a href="#€£Ұ₴-₰¢₤¥₳₲₪₵元₣₱฿¤₡₮₭₩ރ円₢₥₫₦zl﷼₠₧₯₨Kcर₹f₸￠" class="headerlink" title="€£Ұ₴$₰¢₤¥₳₲₪₵元₣₱฿¤₡₮₭₩ރ円₢₥₫₦zł﷼₠₧₯₨Kčर₹ƒ₸￠"></a>€£Ұ₴$₰¢₤¥₳₲₪₵元₣₱฿¤₡₮₭₩ރ円₢₥₫₦zł﷼₠₧₯₨Kčर₹ƒ₸￠</h2><h2 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h2><h2 id="↑↓←→↖↗↘↙↔↕➻➼➽➸➳➺➻➴➵➶➷➹▶►▷◁◀◄«»"><a href="#↑↓←→↖↗↘↙↔↕➻➼➽➸➳➺➻➴➵➶➷➹▶►▷◁◀◄«»" class="headerlink" title="↑↓←→↖↗↘↙↔↕➻➼➽➸➳➺➻➴➵➶➷➹▶►▷◁◀◄«»"></a>↑↓←→↖↗↘↙↔↕➻➼➽➸➳➺➻➴➵➶➷➹▶►▷◁◀◄«»</h2><h2 id="➩➪➫➬➭➮➯➱⏎➲➾➔➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨↚↛↜↝↞↟"><a href="#➩➪➫➬➭➮➯➱⏎➲➾➔➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨↚↛↜↝↞↟" class="headerlink" title="➩➪➫➬➭➮➯➱⏎➲➾➔➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨↚↛↜↝↞↟"></a>➩➪➫➬➭➮➯➱⏎➲➾➔➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨↚↛↜↝↞↟</h2><h2 id="↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙"><a href="#↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙" class="headerlink" title="↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙"></a>↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙</h2><h2 id="⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹☇☈↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛♐"><a href="#⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹☇☈↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛♐" class="headerlink" title="⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹☇☈↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛♐"></a>⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹☇☈↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛♐</h2><h2 id="符号图案"><a href="#符号图案" class="headerlink" title="符号图案"></a>符号图案</h2><h2 id="✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏☑✓✔√☐☒✗✘ㄨ✕✖✖☢☠☣✈★☆✡"><a href="#✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏☑✓✔√☐☒✗✘ㄨ✕✖✖☢☠☣✈★☆✡" class="headerlink" title="✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏☑✓✔√☐☒✗✘ㄨ✕✖✖☢☠☣✈★☆✡"></a>✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏☑✓✔√☐☒✗✘ㄨ✕✖✖☢☠☣✈★☆✡</h2><h2 id="囍㍿☯☰☲☱☴☵☶☳☷☜☞☝✍☚☛☟✌♤♧♡♢♠♣♥♦☀☁☂"><a href="#囍㍿☯☰☲☱☴☵☶☳☷☜☞☝✍☚☛☟✌♤♧♡♢♠♣♥♦☀☁☂" class="headerlink" title="囍㍿☯☰☲☱☴☵☶☳☷☜☞☝✍☚☛☟✌♤♧♡♢♠♣♥♦☀☁☂"></a>囍㍿☯☰☲☱☴☵☶☳☷☜☞☝✍☚☛☟✌♤♧♡♢♠♣♥♦☀☁☂</h2><h2 id="❄☃♨웃유❖☽☾☪✿♂♀✪✯☭➳卍卐√×■◆●○◐◑✙☺☻❀"><a href="#❄☃♨웃유❖☽☾☪✿♂♀✪✯☭➳卍卐√×■◆●○◐◑✙☺☻❀" class="headerlink" title="❄☃♨웃유❖☽☾☪✿♂♀✪✯☭➳卍卐√×■◆●○◐◑✙☺☻❀"></a>❄☃♨웃유❖☽☾☪✿♂♀✪✯☭➳卍卐√×■◆●○◐◑✙☺☻❀</h2><h2 id="⚘♔♕♖♗♘♙♚♛♜♝♞♟♧♡♂♀♠♣♥❤☜☞☎☏⊙◎☺☻☼▧▨♨◐◑"><a href="#⚘♔♕♖♗♘♙♚♛♜♝♞♟♧♡♂♀♠♣♥❤☜☞☎☏⊙◎☺☻☼▧▨♨◐◑" class="headerlink" title="⚘♔♕♖♗♘♙♚♛♜♝♞♟♧♡♂♀♠♣♥❤☜☞☎☏⊙◎☺☻☼▧▨♨◐◑"></a>⚘♔♕♖♗♘♙♚♛♜♝♞♟♧♡♂♀♠♣♥❤☜☞☎☏⊙◎☺☻☼▧▨♨◐◑</h2><h2 id="↔↕▪▒◊◦▣▤▥▦▩◘◈◇♬♪♩♭♪の★☆→あぃ￡Ю〓§♤♥▶¤"><a href="#↔↕▪▒◊◦▣▤▥▦▩◘◈◇♬♪♩♭♪の★☆→あぃ￡Ю〓§♤♥▶¤" class="headerlink" title="↔↕▪▒◊◦▣▤▥▦▩◘◈◇♬♪♩♭♪の★☆→あぃ￡Ю〓§♤♥▶¤"></a>↔↕▪▒◊◦▣▤▥▦▩◘◈◇♬♪♩♭♪の★☆→あぃ￡Ю〓§♤♥▶¤</h2><h2 id="✲❈✿✲❈➹☀☂☁【】┱┲❣✚✪✣✤✥✦❉❥❦❧❃❂❁❀✄☪☣☢☠☭ღ"><a href="#✲❈✿✲❈➹☀☂☁【】┱┲❣✚✪✣✤✥✦❉❥❦❧❃❂❁❀✄☪☣☢☠☭ღ" class="headerlink" title="✲❈✿✲❈➹☀☂☁【】┱┲❣✚✪✣✤✥✦❉❥❦❧❃❂❁❀✄☪☣☢☠☭ღ"></a>✲❈✿✲❈➹☀☂☁【】┱┲❣✚✪✣✤✥✦❉❥❦❧❃❂❁❀✄☪☣☢☠☭ღ</h2><h2 id="▶▷◀◁☀☁☂☃☄★☆☇☈⊙☊☋☌☍love╬『』∴☀♫♬♩♭♪☆"><a href="#▶▷◀◁☀☁☂☃☄★☆☇☈⊙☊☋☌☍love╬『』∴☀♫♬♩♭♪☆" class="headerlink" title="▶▷◀◁☀☁☂☃☄★☆☇☈⊙☊☋☌☍ⓛⓞⓥⓔ╬『』∴☀♫♬♩♭♪☆"></a>▶▷◀◁☀☁☂☃☄★☆☇☈⊙☊☋☌☍ⓛⓞⓥⓔ╬『』∴☀♫♬♩♭♪☆</h2><h2 id="∷﹌の★◎▶☺☻►◄▧▨♨◐◑↔↕↘▀▄█▌◦☼♪の☆→♧ぃ￡"><a href="#∷﹌の★◎▶☺☻►◄▧▨♨◐◑↔↕↘▀▄█▌◦☼♪の☆→♧ぃ￡" class="headerlink" title="∷﹌の★◎▶☺☻►◄▧▨♨◐◑↔↕↘▀▄█▌◦☼♪の☆→♧ぃ￡"></a>∷﹌の★◎▶☺☻►◄▧▨♨◐◑↔↕↘▀▄█▌◦☼♪の☆→♧ぃ￡</h2><h2 id="❤▒▬♦◊◦♠♣▣۰•❤•۰►◄▧▨♨◐◑↔↕▪▫☼♦⊙●○①⊕◎Θ⊙¤㊣"><a href="#❤▒▬♦◊◦♠♣▣۰•❤•۰►◄▧▨♨◐◑↔↕▪▫☼♦⊙●○①⊕◎Θ⊙¤㊣" class="headerlink" title="❤▒▬♦◊◦♠♣▣۰•❤•۰►◄▧▨♨◐◑↔↕▪▫☼♦⊙●○①⊕◎Θ⊙¤㊣"></a>❤▒▬♦◊◦♠♣▣۰•❤•۰►◄▧▨♨◐◑↔↕▪▫☼♦⊙●○①⊕◎Θ⊙¤㊣</h2><h2 id="★☆♀◆◇◣◢◥▲▼△▽⊿◤◥✐✌✍✡✓✔✕✖♂♀♥♡☜☞☎☏⊙◎☺☻"><a href="#★☆♀◆◇◣◢◥▲▼△▽⊿◤◥✐✌✍✡✓✔✕✖♂♀♥♡☜☞☎☏⊙◎☺☻" class="headerlink" title="★☆♀◆◇◣◢◥▲▼△▽⊿◤◥✐✌✍✡✓✔✕✖♂♀♥♡☜☞☎☏⊙◎☺☻"></a>★☆♀◆◇◣◢◥▲▼△▽⊿◤◥✐✌✍✡✓✔✕✖♂♀♥♡☜☞☎☏⊙◎☺☻</h2><h2 id="►◄▧▨♨◐◑↔↕♥♡▪▫☼♦▀▄█▌▐░▒▬♦◊◘◙◦☼♠♣▣▤▥▦▩◘◙◈"><a href="#►◄▧▨♨◐◑↔↕♥♡▪▫☼♦▀▄█▌▐░▒▬♦◊◘◙◦☼♠♣▣▤▥▦▩◘◙◈" class="headerlink" title="►◄▧▨♨◐◑↔↕♥♡▪▫☼♦▀▄█▌▐░▒▬♦◊◘◙◦☼♠♣▣▤▥▦▩◘◙◈"></a>►◄▧▨♨◐◑↔↕♥♡▪▫☼♦▀▄█▌▐░▒▬♦◊◘◙◦☼♠♣▣▤▥▦▩◘◙◈</h2><h2 id="♫♬♪♩♭♪✄☪☣☢☠♯♩♪♫♬♭♮☎☏☪♈ºº₪¤큐«»™♂✿♥-◕‿-｡-｡◕‿◕｡"><a href="#♫♬♪♩♭♪✄☪☣☢☠♯♩♪♫♬♭♮☎☏☪♈ºº₪¤큐«»™♂✿♥-◕‿-｡-｡◕‿◕｡" class="headerlink" title="♫♬♪♩♭♪✄☪☣☢☠♯♩♪♫♬♭♮☎☏☪♈ºº₪¤큐«»™♂✿♥　◕‿-｡　｡◕‿◕｡"></a>♫♬♪♩♭♪✄☪☣☢☠♯♩♪♫♬♭♮☎☏☪♈ºº₪¤큐«»™♂✿♥　◕‿-｡　｡◕‿◕｡</h2><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><h2 id="ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζνξοπρσηθικλμτυφχψω"><a href="#ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζνξοπρσηθικλμτυφχψω" class="headerlink" title="ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζνξοπρσηθικλμτυφχψω"></a>ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζνξοπρσηθικλμτυφχψω</h2><h2 id="俄语字母"><a href="#俄语字母" class="headerlink" title="俄语字母"></a>俄语字母</h2><h2 id="АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"><a href="#АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" class="headerlink" title="АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"></a>АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ</h2><h2 id="абвгдеёжзийклмнопрстуфхцчшщъыьэюя"><a href="#абвгдеёжзийклмнопрстуфхцчшщъыьэюя" class="headerlink" title="абвгдеёжзийклмнопрстуфхцчшщъыьэюя"></a>абвгдеёжзийклмнопрстуфхцчшщъыьэюя</h2><h2 id="汉语拼音"><a href="#汉语拼音" class="headerlink" title="汉语拼音"></a>汉语拼音</h2><h2 id="aaaaooooeeeeiiiiuuuuuuuuueɑnnɡㄅㄆㄇㄈㄉㄊㄋㄌ"><a href="#aaaaooooeeeeiiiiuuuuuuuuueɑnnɡㄅㄆㄇㄈㄉㄊㄋㄌ" class="headerlink" title="āáǎàōóǒòēéěèīíǐìūúǔùǖǘǚǜüêɑńňɡㄅㄆㄇㄈㄉㄊㄋㄌ"></a>āáǎàōóǒòēéěèīíǐìūúǔùǖǘǚǜüêɑńňɡㄅㄆㄇㄈㄉㄊㄋㄌ</h2><h2 id="ㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ"><a href="#ㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ" class="headerlink" title="ㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ"></a>ㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ</h2><h2 id="中文字符"><a href="#中文字符" class="headerlink" title="中文字符"></a>中文字符</h2><h2 id="零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微卍卐卄"><a href="#零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微卍卐卄" class="headerlink" title="零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微卍卐卄"></a>零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微卍卐卄</h2><h2 id="巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩"><a href="#巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩" class="headerlink" title="巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩"></a>巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩</h2><h2 id="㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜"><a href="#㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜" class="headerlink" title="㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜"></a>㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜</h2><h2 id="㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉"><a href="#㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉" class="headerlink" title="㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉"></a>㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉</h2><h2 id="日文平假名片假名"><a href="#日文平假名片假名" class="headerlink" title="日文平假名片假名"></a>日文平假名片假名</h2><h2 id="ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざ"><a href="#ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざ" class="headerlink" title="ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざ"></a>ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざ</h2><h2 id="しじすずせぜそぞただちぢっつづてでとどなにぬねの"><a href="#しじすずせぜそぞただちぢっつづてでとどなにぬねの" class="headerlink" title="しじすずせぜそぞただちぢっつづてでとどなにぬねの"></a>しじすずせぜそぞただちぢっつづてでとどなにぬねの</h2><h2 id="はばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆ"><a href="#はばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆ" class="headerlink" title="はばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆ"></a>はばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆ</h2><h2 id="ょよらりるれろゎわゐゑをんゔゕゖァアィイゥウェエ"><a href="#ょよらりるれろゎわゐゑをんゔゕゖァアィイゥウェエ" class="headerlink" title="ょよらりるれろゎわゐゑをんゔゕゖァアィイゥウェエ"></a>ょよらりるれろゎわゐゑをんゔゕゖァアィイゥウェエ</h2><h2 id="ォオカガキギクグケゲコゴサザシジスズセゼソゾタダ"><a href="#ォオカガキギクグケゲコゴサザシジスズセゼソゾタダ" class="headerlink" title="ォオカガキギクグケゲコゴサザシジスズセゼソゾタダ"></a>ォオカガキギクグケゲコゴサザシジスズセゼソゾタダ</h2><h2 id="チヂッツヅテデトドナニヌネノハバパヒビピフブプヘ"><a href="#チヂッツヅテデトドナニヌネノハバパヒビピフブプヘ" class="headerlink" title="チヂッツヅテデトドナニヌネノハバパヒビピフブプヘ"></a>チヂッツヅテデトドナニヌネノハバパヒビピフブプヘ</h2><h2 id="ベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱ"><a href="#ベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱ" class="headerlink" title="ベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱ"></a>ベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱ</h2><h2 id="ヲンヴヵヶヷヸヹヺ・ーヽヾヿ゠ㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ"><a href="#ヲンヴヵヶヷヸヹヺ・ーヽヾヿ゠ㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ" class="headerlink" title="ヲンヴヵヶヷヸヹヺ・ーヽヾヿ゠ㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ"></a>ヲンヴヵヶヷヸヹヺ・ーヽヾヿ゠ㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ</h2>]]></content>
      <categories>
        <category>图案</category>
      </categories>
      <tags>
        <tag>图案</tag>
      </tags>
  </entry>
  <entry>
    <title>杜宁-克鲁格效应</title>
    <url>/posts/4fb90dee.html</url>
    <content><![CDATA[<p><code>杜宁-克鲁格效应</code> ，倾向于高估自己的能力水平；无法认知他人真正的能力；无法认知且正视自身的不足，及其不足之极端程度；如果他们能够经过恰当训练大幅度提高能力水平，他们最终会认知到且能承认他们之前的无能程度。</p>
<span id="more"></span>

<p>杜宁（Dunning）与克鲁格（Kruger）两个人都是康奈尔大学的教授。</p>
<p>杜宁与克鲁格找了一群康奈尔的在校学生，然后对他们的“幽默”、“语法”、“逻辑”等几项能力进行了测试。之后，再让参试者进行自我评估。结果是，成绩最差的那些学生对自我水平的认知偏差最大。其成绩处于12%百分比等级（即意味着说，他们的成绩处于末尾12%的水平——有88%的人的成绩比他们更高）的应试者认为自己的百分比等级至少应该是67%。与此同时，那些能力更强者却可能反过来低估自己的能力。</p>
<p>这种“<code>越差越牛屄，越强越谦虚</code>”的现象，之后就干脆被称为“<code>杜宁-克鲁格效应</code>” 。</p>
<p>自己的生命要自己珍惜。所以，不要与蠢货纠结在一起，不要与他们为伴。尤其不要与他们争斗，他们会瞬间把你拉到他们的水平上，然后用他们多年的经验轻而易举地打败你，而后还要持续地羞辱你。</p>
<p>珍爱生命，远离蠢货。</p>
<p>参考文章：<a href="https://baike.baidu.com/item/%E6%9D%9C%E5%AE%81-%E5%85%8B%E9%B2%81%E6%A0%BC%E6%95%88%E5%BA%94/1197282">https://baike.baidu.com/item/杜宁-克鲁格效应/1197282</a></p>
]]></content>
      <categories>
        <category>心理学</category>
        <category>社会心理学</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>人格</tag>
        <tag>社会心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>国内时政部分</title>
    <url>/posts/78be4644.html</url>
    <content><![CDATA[<h2 id="专题一：十九届六中全会【必须背诵】"><a href="#专题一：十九届六中全会【必须背诵】" class="headerlink" title="专题一：十九届六中全会【必须背诵】"></a>专题一：十九届六中全会【必须背诵】</h2><h3 id="一、百年历程创造四方面伟大成就【事件】"><a href="#一、百年历程创造四方面伟大成就【事件】" class="headerlink" title="一、百年历程创造四方面伟大成就【事件】"></a>一、百年历程创造四方面伟大成就【事件】</h3><ol>
<li>党领导人民浴血奋战、百折不挠，创造了新民主主义革命的伟大成就，成立中华人民共和国，实现民族独立、人民解放，彻底结束了旧中国半殖民地半封建社会的历史，彻底结束了极少数剥削者统治广大劳动人民的历史，彻底结束了旧中国一盘散沙的局面，彻底废除了列强强加给中国的不平等条约和帝国主义在中国的一切特权，实现了中国从几千年封建专制政治向人民民主的伟大飞跃，也极大改变了世界政治格局，鼓舞了全世界被压迫民族和被压迫人民争取解放的斗争。中国共产党和中国人民以英勇顽强的奋斗向世界庄严宣告，中国人民从此站起来了，中华民族任人宰割、饱受欺凌的时代一去不复返了，中国发展从此开启了新纪元。</li>
<li>党领导人民自力更生、发愤图强，创造了社会主义革命和建设的伟大成就，实现了中华民族有史以来最为广泛而深刻的社会变革，实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃。</li>
<li>解放思想、锐意进取，创造了改革开放和社会主义现代化建设的伟大成就。</li>
<li>自信自强、守正创新，创造了新时代中国特色社会主义的伟大成就。</li>
</ol>
<span id="more"></span>

<h3 id="二、中国共产党百年奋斗的历史意义：【5-个方面】"><a href="#二、中国共产党百年奋斗的历史意义：【5-个方面】" class="headerlink" title="二、中国共产党百年奋斗的历史意义：【5 个方面】"></a>二、中国共产党百年奋斗的历史意义：【5 个方面】</h3><ol>
<li>党的百年奋斗从根本上改变了中国人民的前途命运，中国人民彻底摆脱了被欺负、被压迫、被奴役的命运，成为国家、社会和自己命运的主人，中国人民对美好生活的向往不断变为现实；</li>
<li>党的百年奋斗开辟了实现中华民族伟大复兴的正确道路，中国仅用几十年时间就走完发达国家几百年走过的工业化历程，创造了经济快速发展和社会长期稳定两大奇迹；</li>
<li>党的百年奋斗展示了马克思主义的强大生命力，马克思主义的科学性和真理性在中国得到充分检验，马克思主义的人民性和实践性在中国得到充分贯彻，马克思主义的开放性和时<br>代性在中国得到充分彰显；</li>
<li>党的百年奋斗深刻影响了世界历史进程，党领导人民成功走出中国式现代化道路，创造了人类文明新形态，拓展了发展中国家走向现代化的途径；</li>
<li>党的百年奋斗锻造了走在时代前列的中国共产党，形成了以伟大建党精神为源头的精神谱系，保持了党的先进性和纯洁性，党的执政能力和领导水平不断提高，中国共产党无愧为伟大光荣正确的党。</li>
</ol>
<h3 id="三、三个“历史性决议”"><a href="#三、三个“历史性决议”" class="headerlink" title="三、三个“历史性决议”"></a>三、三个“历史性决议”</h3><h4 id="（一）内容"><a href="#（一）内容" class="headerlink" title="（一）内容"></a>（一）内容</h4><ol>
<li>1945 年，党的六届七中全会通过了《关于若干历史问题的决议》，对建党以后特别是党的六届四中全会至遵义会议前这一段党的历史及其经验教训进行了总结，对若干重大历史问题作出了结论，使全党特别是党的高级干部对中国革命基本问题的认识达到了一致，增强了全党团结，为党的七大胜利召开创造了充分条件，有力促进了中国革命事业发展。</li>
<li>1981年，党的十一届六中全会通过了《关于建国以来党的若干历史问题的决议》，回顾了新中国成立以前党的历史，总结了社会主义革命和建设的历史经验，对一些重大事件和重要人物作出了评价，特别是正确评价了毛泽东同志和毛泽东思想，分清了是非，纠正了“左”右两方面的错误观点，统一了全党思想，对推动党团结一致向前看、更好推进改革开放和社会主义现代化建设产生了重大影响。</li>
<li>《中共中央关于党的百年奋斗重大成就和历史经验的决议》是在中国共产党成立一百周年之际，对党的百年奋斗历程特别是改革开放 40 多年的奋斗历程进行系统总结和全面检视。党中央认为，在党成立一百周年的重要历史时刻，在党和人民胜利实现第一个百年奋斗目标、全面建成小康社会，正在向着全面建成社会主义现代化强国的第二个百年奋斗目标迈进的重大历史关头，全面总结党的百年奋斗重大成就和历史经验，对推动全党进一步统一思想、统一意志、统一行动，团结带领全国各族人民夺取新时代中国特色社会主义新的伟大胜利，具有重大现实意义和深远历史意义。全面总结党的百年奋斗重大成就和历史经验，从党的百年奋斗中看清楚过去我们为什么能够成功、弄明白未来我们怎样才能继续成功，以史为鉴，开创未来，对于新时代更好地坚持和发展中国特色社会主义、实现第二个百年奋斗目标极为必要。可以说，第三个“历史决议”起到了承前启后、继往开来的作用。</li>
</ol>
<h4 id="（二）三大“历史决议”的历史价值"><a href="#（二）三大“历史决议”的历史价值" class="headerlink" title="（二）三大“历史决议”的历史价值"></a>（二）三大“历史决议”的历史价值</h4><ol>
<li>三大“历史决议”为树立正确的党史观提供了科学的世界观和方法论。</li>
<li>三大“历史决议”为维护党的团结统一提供了重要保障。</li>
<li>三大“历史决议”为总结党的历史，不断开拓进取提供了根本遵循。</li>
</ol>
<h3 id="四、深刻认识“两个确立”的重大意义"><a href="#四、深刻认识“两个确立”的重大意义" class="headerlink" title="四、深刻认识“两个确立”的重大意义"></a>四、深刻认识“两个确立”的重大意义</h3><ol>
<li>《决议》指出：“党确立习近平同志党中央的核心、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位，反映了全党全军全国各族人民共同心愿，对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。”“两个确立”为进行伟大斗争、建设伟大工程、推进伟大事业、实现伟大梦想培根铸魂、凝心聚力，是夺取新征程新胜利的根本保证。</li>
<li>“两个确立”反映了全党全军全国各族人民共同心愿，必将为实现中华民族伟大复兴提供更为坚强的政治保证。</li>
<li>“两个确立”体现了我们党在指导思想上的与时俱进，必将为实现中华民族伟大复兴提供更为强大的思想指引。</li>
<li>“两个确立”展现了我们党推进新时代党和人民事业伟大实践的历史担当，必将为实现中华民族伟大复兴汇聚更为磅礴的奋进力量。</li>
<li>“两个确立”宣示了我们党牢记初心使命、永葆生机活力的坚定决心，必将为实现中华民族伟大复兴提供更为强大的组织优势。</li>
</ol>
<h3 id="五、三次飞跃"><a href="#五、三次飞跃" class="headerlink" title="五、三次飞跃"></a>五、三次飞跃</h3><p>全会明确指出，</p>
<ol>
<li>毛泽东思想是“马克思主义中国化的第一次历史性飞跃”，</li>
<li>中国特色社会主义理论体系“实现了马克思主义中国化新的飞跃”，</li>
<li>习近平新时代中国特色社会主义思想“实现了马克思主义中国化新的飞跃”，这彰显了马克思主义的强大生命力，是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华。也使人们充分认识到，“中国共产党为什么能，中国特色社会主义为什么好，归根到底是因为马克思主义行！”</li>
</ol>
<h3 id="六、百年来中国共产党的历史经验"><a href="#六、百年来中国共产党的历史经验" class="headerlink" title="六、百年来中国共产党的历史经验"></a>六、百年来中国共产党的历史经验</h3><p>【十个坚持】一百年来，党领导人民进行伟大奋斗，积累了宝贵的历史经验，这就是：<br>① 坚持党的领导，<br>② 坚持人民至上，<br>③ 坚持理论创新，<br>④ 坚持独立自主，<br>⑤ 坚持中国道路，<br>⑥ 坚持胸怀天下，<br>⑦ 坚持开拓创新，<br>⑧ 坚持敢于斗争，<br>⑨ 坚持统一战线，<br>⑩ 坚持自我革命。<br>以上十个方面，是经过长期实践积累的宝贵经验，是党和人民共同创造的精神财富，必须倍加珍惜、长期坚持，并在新时代实践中不断丰富和发展。</p>
<h3 id="七、回答两个重要问题"><a href="#七、回答两个重要问题" class="headerlink" title="七、回答两个重要问题"></a>七、回答两个重要问题</h3><ol>
<li>过去我们为什么能够成功？<br>①中国共产党百年来取得巨大成功，一个重要原因，就是在每一个历史时期，都能准确判断基本国情和阶段性特征，抓住主要任务。<br>②科学的思想理论武装以及所铸就的崇高理想信念和不懈追求，是中国共产党能成功的根本基石。<br>③至上的人民理念以及所锻造的坚定人民立场和不懈奋斗，是中国共产党能成功的根本力量。始终把为人民服务放在首位。<br>④勇于自我革命的精神以及所淬炼的蓬勃生机活力和不懈斗争，是中国共产党能成功的根本保证。</li>
<li>未来我们该怎样继续成功？【新的赶考路 怎样交出一份新的答卷】<br>踏上实现第二个百年奋斗目标新的赶考之路，交出更加优异的答卷，就要使理想信念强大无<br>比，全党的马克思主义信仰坚如磐石，共产主义远大理想豪迈澎湃，中国特色社会主义共同<br>理想凝聚力量，理想信念的洪流冲决一切阻碍我们前进的围堰和堤坝。交出更加优异的答卷，<br>就要进行伟大的自我革命，不断医治病症，坚决铲除毒瘤，保持肌体健康。交出更加优异的<br>答卷，就要常怀远虑、居安思危，始终谦虚谨慎、不骄不躁、艰苦奋斗，不为任何风险所惧，<br>不为任何干扰所惑，不懈推进中华民族伟大复兴。</li>
</ol>
<h3 id="八、中国共产党是什么？"><a href="#八、中国共产党是什么？" class="headerlink" title="八、中国共产党是什么？"></a>八、中国共产党是什么？</h3><p>历史告诉我们：中国共产党是用马克思主义武装起来的政党，马克思主义是中国共产党的灵<br>魂；中国共产党是为人民服务的政党，始终相信和依靠人民，最广泛地发动和组织人民，始<br>终代表最广大人民根本利益，没有任何自己特殊的利益；中国共产党是按照民主集中制原则<br>组织起来的马克思主义政党，维护党中央权威和集中统一领导，是一个成熟的马克思主义执<br>政党的重大建党原则。</p>
<h2 id="专题二：庆祝中国共产党成立-100-周年"><a href="#专题二：庆祝中国共产党成立-100-周年" class="headerlink" title="专题二：庆祝中国共产党成立 100 周年"></a>专题二：庆祝中国共产党成立 100 周年</h2><ol>
<li>1840 年鸦片战争以后，中国逐步成为半殖民地半封建社会</li>
<li>十月革命一声炮响，给中国送来了马克思列宁主义。在中国人民和中华民族的伟大觉醒中，在马克思列宁主义同中国工人运动的紧密结合中，中国共产党应运而生。【中国共产党诞生的背景】</li>
<li>中国产生了共产党，这是开天辟地的大事变，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局。【共产党的伟大意义】</li>
<li>中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心使命。归结起来就是一个主题：实现中华民族伟大复兴。</li>
<li>① 创造了新民主主义革命的伟大成就。彻底结束了旧中国半殖民地半封建社会的历史，彻底结束了旧中国一盘散沙的局面，彻底废除了列强强加给中国的不平等条约和帝国主义在中国的一切特权，为实现中华民族伟大复兴创造了根本社会条件。<br>② 创造了社会主义革命和建设的伟大成就。我们进行社会主义革命，消灭在中国延续几千年的封建剥削压迫制度，确立社会主义基本制度，推进社会主义建设，战胜帝国主义、霸权主义的颠覆破坏和武装挑衅，实现了中华民族有史以来最为广泛而深刻的社会变革。为实现中华民族伟大复兴奠定了根本政治前提和制度基础。<br>③ 创造了改革开放和社会主义现代化建设的伟大成就。为实现中华民族伟大复兴提供了充满新的活力的体制保证和快速发展的物质条件。<br>④ 创造了新时代中国特色社会主义的伟大成就。为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。中华民族迎来了从站起来、富起来到强起来的伟大飞跃，实现中华民族伟大复兴进入了不可逆转的历史进程！【四大成就】</li>
<li>首次提出伟大建党精神。伟大建党精神是中国共产党的精神之源。内容是坚持真理、坚守理想 ；践行初心、担当使命；不怕牺牲、英勇斗争；对党忠诚、不负人民。</li>
<li>①必须坚持中国共产党坚强领导。中国共产党领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，是党和国家的根本所在、命脉所在，是全国各族人民的利益所系、命运所系。<br>②必须团结带领中国人民不断为美好生活而奋斗。中国共产党始终代表最广大人民根本利益，与人民休戚与共、生死相依，没有任何自己特殊的利益，从来不代表任何利益集团、任何权势团体、任何特权阶层的利益。坚持全心全意为人民服务的根本宗旨。<br>③必须继续推进马克思主义中国化。马克思主义是我们立党立国的根本指导思想，是我们党的灵魂和旗帜。中国共产党为什么能，中国特色社会主义为什么好，归根到底是因为马克思主义行！<br>④必须坚持和发展中国特色社会主义。中国特色社会主义是党和人民历经千辛万苦、付出巨大代价取得的根本成就，是实现中华民族伟大复兴的正确道路。<br>⑤必须加快国防和军队现代化。<br>⑥必须不断推动构建人类命运共同体。中国始终是世界和平的建设者、全球发展的贡献者、国际秩序的维护者！<br>⑦必须进行具有许多新的历史特点的伟大斗争。敢于斗争、敢于胜利，是中国共产党不可战胜的强大精神力量。<br>⑧必须加强中华儿女大团结。爱国统一战线是中国共产党团结海内外全体中华儿女实现中华民族伟大复兴的重要法宝。<br>⑨必须不断推进党的建设新的伟大工程。勇于自我革命是中国共产党区别于其他政党的显著标志。【9 个必须】</li>
<li>中国共产党又踏上了新的赶考之路，全体中国共产党党员要努力为党和人民争取更大荣光。过去的一百年，中国共产党向人民、向历史交出了一份优异的答卷。现在，中国共产党团结带领中国人民又踏上了实现第二个百年奋斗目标新的赶考之路。</li>
<li>走自己的路，是党的全部理论和实践立足点，更是党百年奋斗得出的历史结论。</li>
</ol>
<h2 id="专题三：辛亥革命-110-周年"><a href="#专题三：辛亥革命-110-周年" class="headerlink" title="专题三：辛亥革命 110 周年"></a>专题三：辛亥革命 110 周年</h2><h3 id="（一）辛亥革命部分"><a href="#（一）辛亥革命部分" class="headerlink" title="（一）辛亥革命部分"></a>（一）辛亥革命部分</h3><ol>
<li>辛亥革命的发生，有着深刻的社会历史背景，是近代以来中国社会矛盾激化和中国人民顽强斗争的必然结果。</li>
<li>1840 年鸦片战争以后，西方列强在中华大地上恣意妄为，封建统治者孱弱无能，中国逐步成为半殖民地半封建社会【单选】，国家蒙辱、人民蒙难、文明蒙尘，中国人民和中华民族遭受了前所未有的劫难。英雄的中国人民始终没有屈服，在救亡图存的道路上一次次抗争、一次次求索，展现了不畏强暴、自强不息的顽强意志。</li>
<li>孙中山先生是伟大的民族英雄、伟大的爱国主义者、中国民主革命的伟大先驱【多选】。孙中山先生大声疾呼“亟拯斯民于水火，切扶大厦之将倾”，高扬反对封建专制统治的斗争旗帜，提出民族、民权、民生的三民主义政治纲领，率先发出“振兴中华”的呐喊。</li>
<li>1911 年 10 月 10 日，武昌城头枪声一响，拉开了中国完全意义上的近代民族民主革命的序幕【单选】。辛亥革命极大促进了中华民族的思想解放，传播了民主共和的理念，打开了中国进步潮流的闸门，撼动了反动统治秩序的根基，在中华大地上建立起亚洲第一个共和制国家，以巨大的震撼力和深刻的影响力推动了中国社会变革，为实现中华民族伟大复兴探索了道路。【伟大历史意义】。</li>
</ol>
<h3 id="（二）共产党部分"><a href="#（二）共产党部分" class="headerlink" title="（二）共产党部分"></a>（二）共产党部分</h3><ol>
<li>历史发展总是螺旋式上升、波浪式前进的。由于历史进程和社会条件的制约，由于没有找到解决中国前途命运问题的正确道路和领导力量，辛亥革命没有改变旧中国半殖民地半封建的社会性质和中国人民的悲惨境遇，没有完成实现民族独立、人民解放的历史任务【3&#x2F;4多选】。辛亥革命之后，在这场革命中接受洗礼的中国人民和中国先进分子继续探寻救国救民道路。十月革命一声炮响，给中国送来了马克思列宁主义【单选】，促进了中国人民的伟大觉醒，在马克思列宁主义同中国工人运动的紧密结合中，中国共产党应运而生。中国共产党一经诞生，就把为中国人民谋幸福、为中华民族谋复兴确立为自己的初心和使命【单选】，点亮了实现中华民族伟大复兴的灯塔。</li>
<li>中国共产党人是孙中山先生革命事业最坚定的支持者、最忠诚的合作者、最忠实的继承者【3&#x2F;4 多选】。中国共产党在成立之初就提出反帝反封建的民主革命纲领，并同孙中山先生领导的中国国民党携手合作，帮助国民党完成改组，建立最广泛的革命统一战线，掀起轰轰烈烈的大革命，给北洋军阀反动统治以沉重打击。</li>
<li>孙中山先生逝世后，中国共产党人继承他的遗愿，同一切忠于他的事业的人们继续奋斗，不断实现和发展了孙中山先生和辛亥革命先驱的伟大抱负。中国共产党团结带领中国人民浴血奋战、百折不挠，打败国内外一切反动势力，取得了<br>（1）新民主主义革命伟大胜利，建立了人民当家作主的中华人民共和国，完成了民族独立、人民解放的历史任务，开启了中华民族发展进步的历史新纪元。新中国成立后，中国共产党团结带领中国人民，自力更生、发愤图强，<br>（2）创造了社会主义革命和建设的伟大成就；<br>（3）解放思想、锐意进取，创造了改革开放和社会主义现代化建设的伟大成就；<br>（4）自信自强、守正创新，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，创造了新时代坚持和发展中国特色社会主义的伟大成就。</li>
<li>五个启示：辛亥革命 110 年来的历史启示我们，实现中华民族伟大复兴，必须有领导中国人民前进的坚强力量，<br>（1）这个坚强力量就是中国共产党。中国共产党领导是历史的选择、人民的选择，是党和国家的根本所在、命脉所在，是全国各族人民的利益所系、命运所系。没有中国共产党，就没有新中国，就没有中华民族伟大复兴。新的征程上，我们必须坚持和加强党的全面领导，充分发挥党总揽全局、协调各方的领导核心作用，提高党科学执政、民主执政、依法执政水平【3&#x2F;4 多选】。要弘扬伟大建党精神，推进党的建设新的伟大工程，增强自我净化、自我完善、自我革新、自我提高能力【4&#x2F;4 多选】，确保中国共产党始终成为中国人民和中华民族最可靠的主心骨。<br>（2）道路是最根本的问题。中国特色社会主义是实现中华民族伟大复兴的唯一正确道路。这条道路符合中国实际、反映中国人民意愿、适应时代发展要求，不仅走得对、走得通，而且也一定能够走得稳、走得好。<br>（3）必须依靠中国人民自己的英勇奋斗来实现。<br>（4）中国人民和中华民族必须同舟共济，依靠团结战胜前进道路上一切风险挑战。孙中山先生说过：“要恢复民族的地位，便先要恢复民族的精神。”近代以来，中国人民和中华民族弘扬伟大爱国主义精神，心聚在了一起、血流到了一起，共同书写了抵御外来侵略、推翻反动统治、建设人民国家、推进改革开放的革命史诗。统一战线始终是中国共产党凝聚人心、汇聚力量的重要法宝。<br>（5）不仅需要安定团结的国内环境，而且需要和平稳定的国际环境。孙中山先生曾经说过：“中国如果强盛起来，我们不但是要恢复民族的地位，还要对于世界负一个大责任。”中华民族的血液中没有侵略他人、称王称霸的基因，中国人民不仅希望自己发展得好，也希望各国人民都能拥有幸福安宁的生活。</li>
</ol>
<h3 id="（三）台湾问题"><a href="#（三）台湾问题" class="headerlink" title="（三）台湾问题"></a>（三）台湾问题</h3><p>孙中山先生说过：“‘统一’是中国全体国民的希望。能够统一，全国人民便享福；不能统一，便要受害。”台湾问题因民族弱乱而产生，必将随着民族复兴而解决。“台独”分裂是祖国统一的最大障碍，是民族复兴的严重隐患。这是中华民族历史演进大势所决定的，更是全体中华儿女的共同意志，正像孙中山先生所说：“世界潮流，浩浩荡荡，顺之则昌，逆之则亡”。以和平方式实现祖国统一，最符合包括台湾同胞在内的中华民族整体利益。我们坚持“和平统一、一国两制”的基本方针，坚持一个中国原则和“九二共识”【单选】，推动两岸关系和平发展。两岸同胞都要站在历史正确的一边，共同创造祖国完全统一、民族伟大复兴的光荣伟业。台湾问题纯属中国内政，不容任何外来干涉。任何人都不要低估中国人民捍卫国家主权和领土完整的坚强决心、坚定意志、强大能力！祖国完全统一的历史任务一定要实现，也一定能够实现！</p>
<h2 id="专题四：共同富裕"><a href="#专题四：共同富裕" class="headerlink" title="专题四：共同富裕"></a>专题四：共同富裕</h2><ol>
<li>党的十八大以来，党中央把逐步实现全体人民共同富裕摆在更加重要的位置上，采取有力措施保障和改善民生，打赢脱贫攻坚战，全面建成小康社会，为促进共同富裕创造了良好条件。我们正在向第二个百年奋斗目标迈进，适应我国社会主要矛盾的变化，更好满足人民日益增长的美好生活需要，必须把促进全体人民共同富裕作为为人民谋幸福的着力点，不断夯实党长期执政基础。</li>
<li>共同富裕的内涵<br>共同富裕是全体人民的富裕，是人民群众物质生活和精神生活都富裕，不是少数人的富裕，也不是整齐划一的平均主义，要分阶段促进共同富裕。<br>① 共同富裕是中国式现代化的“母版”“新版”，不是西方高福利政策的“再版”“翻版”；<br>② 是高质量发展基础上的富裕，不是“穿新鞋走老路”；<br>③ 共同富裕是分阶段促进共同富裕，不是同时同步同等富裕。<br>④ 共同富裕是人人参与、人人奋斗，不是“躺平”“搭车”<br>⑤ 共同富裕是全体人民的共同富裕，不是少数<br>人的富裕。<br>⑥ 共同富裕是先富带后富、帮后富，不是“劫富济贫”“打土豪分田地”<br>⑦ 是普遍基础上的差别富裕，不是“绝对公平”“吃大锅饭”⑧是“富口袋、 富脑袋”的统一，不是单单物质上的“土豪”“富豪”。</li>
<li>第三次分配<br>要坚持以人民为中心的发展思想，在高质量发展中促进共同富裕，构建初次分配、再分配、三次分配协调配套的基础性制度安排，加大税收、社保、转移支付等调节力度并提高精准性，扩大中等收入群体比重，增加低收入群体收入，合理调节高收入，取缔非法收入，形成中间大、两头小的橄榄型结构。初次分配注重效率，初次分配靠市场；再次分配 注重公平 靠政府；三次分配靠自愿【募集、捐助慈善公益事业】</li>
<li>《关于支持浙江高质量发展建设共同富裕示范区的意见》<br>高质量发展高品质生活先行区；城乡区域协调发展引领区；收入分配制度改革试验区；文明和谐美丽家园展示区。到 2025 年，浙江省推动高质量发展建设共同富裕示范区取得明显实质性进展。到 2035 年，浙江省高质量发展取得更大成就，基本实现共同富裕。重大意义：<br>共同富裕是社会主义的本质要求，是人民群众的共同期盼。党的十八大以来，以习近平同志为核心的党中央不忘初心、牢记使命，团结带领全党全国各族人民，始终朝着实现共同富裕的目标不懈努力，全面建成小康社会取得伟大历史性成就，特别是决战脱贫攻坚取得全面胜利，困扰中华民族几千年的绝对贫困问题得到历史性解决，为新发展阶段推动共同富裕奠定了坚实基础。<br>实现共同富裕不仅是经济问题，而且是关系党的执政基础的重大政治问题。共同富裕具有鲜明的时代特征和中国特色，实现人的全面发展和社会全面进步，共享改革发展成果和幸福美好生活。随着我国开启全面建设社会主义现代化国家新征程，必须把促进全体人民共同富裕摆在更加重要的位置，向着这个目标更加积极有为地进行努力，让人民群众真真切切感受到共同富裕看得见、摸得着、真实可感。<br>促进全体人民共同富裕是一项长期艰巨的任务，需要选取部分地区先行先试、作出示范。支持浙江高质量发展建设共同富裕示范区，有利于通过实践进一步丰富共同富裕的思想内涵，有利于探索破解新时代社会主要矛盾的有效途径，有利于为全国推动共同富裕提供省域范例，有利于打造新时代全面展示中国特色社会主义制度优越性的重要窗口。（4&#x2F;4 个有利于）<br>指导思想：<br>坚持以满足人民日益长的美好生活需要为根本目的，以改革创新为根本动力，以解决地区差距、城乡差距、收入差距问题为主攻方向，更加注重向农村、基层、相对欠发达地区倾斜，向困难群众倾斜，在高质量发展中扎实推动共同富裕，着力在完善收入分配制度、统筹城乡区域发展、发展社会主义进文化、促进人与自然和谐共生、创新社会治理等方面先行示范。<br>工作原则：<br>坚持党的全面领导；坚持以人民为中心；坚持共建共享；坚持改革创新；坚持系统观念。（5个坚持）</li>
</ol>
<h2 id="专题五：新发展理念-新发展格局-新发展阶段"><a href="#专题五：新发展理念-新发展格局-新发展阶段" class="headerlink" title="专题五：新发展理念 新发展格局 新发展阶段"></a>专题五：新发展理念 新发展格局 新发展阶段</h2><h3 id="一、深入贯彻新发展理念"><a href="#一、深入贯彻新发展理念" class="headerlink" title="一、深入贯彻新发展理念"></a>一、深入贯彻新发展理念</h3><ol>
<li>党的十八大以来我们对经济社会发展提出了许多重大理论和理念，其中新发展理念是最重要、最主要的。</li>
<li>从根本宗旨把握新发展理念。人民是我们党执政的最深厚基础和最大底气。为人民谋幸福、为民族谋复兴，这就是我们党领导现代化建设的出发点和落脚点，也是新发展理念的“根”和“魂”。</li>
</ol>
<h3 id="二、新发展格局"><a href="#二、新发展格局" class="headerlink" title="二、新发展格局"></a>二、新发展格局</h3><ol>
<li>加快构建新发展格局的必要性：建立以国内大循环为主体、国内国际双循环相互促进的新发展格局，这是把握未来发展主动权的战略性布局和先手棋，是新发展阶段要着力推动完成的重大历史任务，也是贯彻新发展理念的重大举措。</li>
<li>构建新发展格局的关键和最本质的特征：构建新发展格局的关键在于经济循环的畅通无阻。构建新发展格局最本质的特征是实现高水平的自立自强。</li>
</ol>
<h3 id="三、新发展阶段"><a href="#三、新发展阶段" class="headerlink" title="三、新发展阶段"></a>三、新发展阶段</h3><ol>
<li>明确我国进入了一个新发展阶段。党的十九届五中全会提出，全面建成小康社会、实现第一个百年奋斗目标之后，我们要乘势而上开启全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军，这标志着我国进入了一个新发展阶段。</li>
<li>新发展阶段战略判断的深刻依据：<br>第一，就理论依据而言，马克思主义是远大理想和现实目标相结合、历史必然性和发展阶段性相统一的统一论者，坚信人类社会必然走向共产主义，但实现这一崇高目标必然经历若干历史阶段。我们党在运用马克思主义基本原理解决中国实际问题的实践中逐步认识到发展社会主义不仅是一个长期历史过程，而且是需要划分为不同历史阶段的过程。今天我们所处的新发展阶段，就是社会主义初级阶段中的一个阶段，同时是其中经过几十年积累、站到了新的起点上的一个阶段。<br>第二，从历史依据来看，新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。我们党成立后，团结带领人民经过 28 年浴血奋战和顽强奋斗，建立了中华人民共和国，实现了从新民主主义革命到社会主义革命的历史性跨越。中国人民不仅站起来了，而且站住了、站稳了，实现了从社会主义革命到社会主义建设的历史性跨越。进入历史新时期，我们党带领人民进行改革开放新的伟大革命，极大激发广大人民群众的积极性、主动性、创造性，成功开辟了中国特色社会主义道路，使中国大踏步赶上时代，实现了社会主义现代化进程中新的历史性跨越，迎来了中华民族伟大复兴的光明前景。今天，我们正在此前发展的基础上续写全面建设社会主义现代化国家新的历史。<br>第三，就现实依据来讲，我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。经过新中国成立以来特别是改革开放 40 多年的不懈奋斗，到“十三五”规划收官之时，我国经济实力、科技实力、综合国力和人民生活水平跃上了新的大台阶。特别是全面建成小康社会取得伟大历史成果，解决困扰中华民族几千年的绝对贫困问题取得历史性成就。这在我国社会主义现代化建设进程中具有里程碑意义，为我国进入新发展阶段、朝着第二个百年奋斗目标进军奠定了坚实基础。</li>
<li>中国式现代化的 5 个特征：<br>我们的任务是全面建设社会主义现代化国家，当然我们建设的现代化必须是具有中国特色、符合中国实际的。<br>① 我国现代化是人口规模巨大的现代化；<br>② 我国现代化是全体人民共同富裕的现代化；<br>③ 我国现代化是物质文明和精神文明相协调的现代化；<br>④ 我国现代化是人与自然和谐共生的现代化；<br>⑤ 我国现代化是走和平发展道路的现代化。<br>中国特色社会主义，最本质的特征是中国共产党领导，最鲜明的特色是理论创新和实践创新、制度自信和文化自信紧密结合，在推动发展上拥有强大的政治优势、理论优势、制度优势、文化优势。</li>
</ol>
<h2 id="专题六：“一国两制”"><a href="#专题六：“一国两制”" class="headerlink" title="专题六：“一国两制”"></a>专题六：“一国两制”</h2><ol>
<li>习近平听取林郑月娥述职报告，强调必须始终坚持“爱国者治港”<br>习近平强调，香港由乱及治的重大转折，再次昭示了一个深刻道理，那就是要确保“一国两制”实践行稳致远，必须始终坚持“爱国者治港”。这是事关国家主权、安全、发展利益，事关香港长期繁荣稳定的根本原则。只有做到“爱国者治港”，中央对特别行政区的全面管治权才能得到有效落实，宪法和基本法确立的宪制秩序才能得到有效维护，各种深层次问题才能得到有效解决，香港才能实现长治久安，并为实现中华民族伟大复兴作出应有的贡献。</li>
<li>关于完善香港特别行政区选举制度<br>2012 年 3 月 11 日下午，十三届全国人大四次会议通过了《全国人民代表大会关于完善香港特别行政区选举制度的决定》；3 月 30 日，十三届全国人大常委会第二十七次会议通过新修订的《中华人民共和国香港特别行政区基本法附件一香港特别行政区行政长官的产生办法》《中华人民共和国香港特别行政区基本法附件二香港特别行政区立法会的产生办法和表决程序》。这是继香港国安法出台之后中央治港又一重大举措，是“爱国者治港”方针作为“一国两制”核心要义的集中体现，在“一国两制”实践进程中具有里程碑意义。</li>
<li>完善香港特别行政区选举制度的必要性<br>完善香港选举制度，是全面准确贯彻“一国两制”方针、坚持和完善“一国两制”制度体系的必然要求。“爱国者治港”的要求是，香港特别行政区的政权必须掌握在爱国者手中。“爱国者治港”不是今天提出来的，早在“一国两制”构想形成之初，它就已经作为一项重要原则确立起来。1984 年，邓小平同志就提出了“爱国者治港”。他指出，“港人治港”有个界线和标准，就是必须由以爱国者为主体的港人来治理香港。可见，“爱国者治港”是“一国两制”方针的<br>应有之义和核心要义，是香港回归祖国、成为中华人民共和国的一个特别行政区、纳入国家治理体系后的一个基本政治伦理和政治规则。“港人治港”就是由爱国的香港人治理香港，就是“爱国者治港”。</li>
<li>本次修改完善香港选举制度的主要内容<br>① 重新构建香港特别行政区选举委员会并增加赋权。<br>② 行政长官候选人提名采用“双提名”机制。<br>③ 立法会议员总数由 70 人增至 90 人，通过选委会选举、功能团体选举、分区直接选举等三种方式选举产生，其中选委会选举的议员占据较大比例。<br>④ 设立候选人资格审查委员会，负责审查并确认选举委员会委员候选人、立法会议员候选人和行政长官候选人的资格，完善有关审查机制，对有关人士从参选、竞选到当选后的表现进行全流程监督审查。附件直接取消了区议会在选委会和立法会中的席位。<br>5 月 27 日香港特别行政区立法会审议通过《2021 年完善选举制度（综合修订）条例草案》，标志着完善香港特别行政区选举制度涉及的本地立法工作全面完成。这是依法治港、拨乱反正的又一重大制度成果，将开启香港良政善治新篇章。</li>
</ol>
<h2 id="专题七：五位一体【经济——科技成就；政治——民族工作、西藏和平解放-70周年、全面依法治国】"><a href="#专题七：五位一体【经济——科技成就；政治——民族工作、西藏和平解放-70周年、全面依法治国】" class="headerlink" title="专题七：五位一体【经济——科技成就；政治——民族工作、西藏和平解放 70周年、全面依法治国】"></a>专题七：五位一体【经济——科技成就；政治——民族工作、西藏和平解放 70周年、全面依法治国】</h2><h3 id="一、经济——科技成就"><a href="#一、经济——科技成就" class="headerlink" title="一、经济——科技成就"></a>一、经济——科技成就</h3><ol>
<li>2021 年 5 月 15 日，我国天问一号探测器成功实现火星表面软着陆，稳稳落在火星乌托邦平原南部预选着陆区，我国首次火星探测任务着陆火星取得成功。【天问一号探测器自2020 年 7 月 23 日在文昌航天发射场启程，经历了长达近 7 个月的“奔火”之旅和 3 个月的“环火”探测，如今“登火”成功，并且开展巡视探测。】<br>天问一号任务实现我国航天发展史上 6 个首次：<br>① 突破了第二宇宙速度发射，首次实现地火转移轨道探测器发射；<br>② 首次实现行星际飞行；<br>③ 首次实现地外行星软着陆；<br>④ 首次实现地外行星表面巡视探测；<br>⑤ 首次实现 4 亿公里距离的测控通信；<br>⑥ 首次获取第一手的火星科学数据。在世界航天史上，天问一号不仅在火星上首次留下中国人的印迹，而且首次成功实现了通过一次任务完成火星环绕、着陆和巡视三大目标，充分展现了中国航天人的智慧，标志着我国在行星探测领域跨入世界先进行列。<br>5 月 15 日当天，习近平代表党中央、国务院和中央军委致电祝贺。习近平在贺电中指出，天问一号探测器着陆火星，迈出了我国星际探测征程的重要一步，实现了从地月系到行星际的跨越，在火星上首次留下中国人的印迹，这是我国航天事业发展的又一具有里程碑意义的进展，使我国在行星探测领域进入世界先进行列。</li>
<li>神舟十二号载人飞行任务取得圆满成功<br>6 月 17 日 9 时 22 分，神舟十二号载人飞船在酒泉卫星发射中心发射升空，随后与天和核心舱对接形成组合体，3 名航天员进驻核心舱，进行了为期 3 个月的驻留，在轨飞行期间进行了 2 次航天员出舱活动，开展了一系列空间科学实验和技术试验，在轨验证了航天员长期驻留、再生生保、空间物资补给、出舱活动、舱外操作、在轨维修等空间站建造和运营关键技术。9 月 17 日 13 时 34 分，神舟十二号载人飞船返回舱成功着陆，3 名航天员安全顺利出舱，空间站阶段首次载人飞行任务取得圆满成功。神舟十二号载人飞行任务的圆满成功，为后续空间站建造运营奠定了更加坚实的基础。<br>神舟十二号载人飞行任务是空间站关键技术验证阶段的第四次飞行任务，也是我国空间站阶段首次载人飞行任务。中国人首次进入自己的空间站，并在太空驻留 3 个月时间，表明中国载人航天事业已全面进入空间站阶段，正向着既定的探索目标稳步前行。这一成就，充分展示了伟大的中国道路、中国精神、中国力量，更加坚定了我们夺取全面建设社会主义现代化国家新胜利的决心和信心。</li>
<li>2021 年 10 月 16 日 0 时 23 分，搭载神舟十三号载人飞船的长征二号 F 遥十三运载火箭，在酒泉卫星发射中心按照预定时间精准点火发射，顺利将翟志刚、王亚平、叶光富 3 名航天员送入太空。飞行乘组状态良好，发射取得圆满成功。</li>
<li>习近平强调，嫦娥五号任务的圆满成功，标志着探月工程“绕、落、回”三步走规划圆满收官，是发挥新型举国体制优势攻坚克难取得的又一重大成就，是航天强国建设征程中的重要里程碑，对我国航天事业发展具有十分重要的意义。<br>实施探月工程是党中央把握我国经济科技发展大势作出的重大战略决策，工程自立项以来圆满完成六次探测任务。嫦娥五号任务作为我国复杂度最高、技术跨度最大的航天系统工程，于 2020 年 12 月 17 日首次实现我国地外天体采样返回，为未来我国开展月球和行星探测奠定了坚实基础。</li>
</ol>
<h3 id="二、政治——民族工作、西藏和平解放-70-周年"><a href="#二、政治——民族工作、西藏和平解放-70-周年" class="headerlink" title="二、政治——民族工作、西藏和平解放 70 周年"></a>二、政治——民族工作、西藏和平解放 70 周年</h3><ol>
<li>8 月 27 日至 28 日，中央民族工作会议在北京召开。习近平出席会议并发表重要讲话，强调要准确把握和全面贯彻我们党关于加强和改进民族工作的重要思想，以铸牢中华民族共同体意识为主线，坚定不移走中国特色解决民族问题的正确道路，推动新时代党的民族工作高质量发展，动员全党全国各族人民为实现全面建成社会主义现代化强国的第二个百年奋斗目标而团结奋斗。<br>讲话的主要内容有：</li>
<li>讲话回顾党的百年历程，指出党的民族工作取得的最大成就，就是走出了一条中国特色解决民族问题的正确道路。</li>
<li>概括党关于加强和改进民族工作的重要思想（12 条）。一是必须从中华民族伟大复兴战略高度把握新时代党的民族工作的历史方位，以实现中华民族伟大复兴为出发点和落脚点，统筹谋划和推进新时代党的民族工作。二是必须把推动各民族为全面建设社会主义现代化国家共同奋斗作为新时代党的民族工作的重要任务，促进各民族紧跟时代步伐，共同团结奋斗、共同繁荣发展。三是必须以铸牢中华民族共同体意识为新时代党的民族工作的主线，推动各民族坚定对伟大祖国、中华民族、中华文化、中国共产党、中国特色社会主义的高度认同，不断推进中华民族共同体建设。四是必须坚持正确的中华民族历史观，增强对中华民族的认同感和自豪感。五是必须坚持各民族一律平等，保证各民族共同当家作主、参与国家事务管理，保障各族群众合法权益。六是必须高举中华民族大团结旗帜，促进各民族在中华民族大家庭中像石榴籽一样紧紧抱在一起。七是必须坚持和完善民族区域自治制度，确保党中央政令畅通，确保国家法律法规实施，支持各民族发展经济、改善民生，实现共同发展、共同富裕。八是必须构筑中华民族共有精神家园，使各民族人心归聚、精神相依，形成人心凝聚、团结奋进的强大精神纽带。九是必须促进各民族广泛交往交流交融，促进各民族在理想、信念、情感、文化上的团结统一，守望相助、手足情深。十是必须坚持依法治理民族事务，推进民族事务治理体系和治理能力现代化。十一是必须坚决维护国家主权、安全、发展利益，教育引导各民族继承和发扬爱国主义传统，自觉维护祖国统一、国家安全、社会稳定。十二是必须坚持党对民族工作的领导，提升解决民族问题、做好民族工作的能力和水平。我们党关于加强和改进民族工作的重要思想，是党的民族工作理论和实践的智慧结晶，是新时代党的民族工作的根本遵循，全党必须完整、准确、全面把握和贯彻。</li>
<li>明确铸牢中华民族共同体意识，就是要引导各族人民牢固树立休戚与共、荣辱与共、生死与共、命运与共的共同体理念。</li>
<li>习近平作为中共中央总书记、国家主席、中央军委主席到西藏庆祝西藏和平解放，在党和国家历史上是第一次，充分表达了党中央对西藏工作的支持、对西藏各族干部群众的关怀。</li>
<li>彻底驱逐了帝国主义势力，沉重打击了各种分裂势力，有力推进了中国人民解放事业，坚决捍卫了国家主权和领导完整，维护了国家同归和民族团结，开辟了百万农奴翻身解放的道路，开启了西藏繁荣进步的光明前景。</li>
<li>①始终聚焦西藏工作的着眼点和着力点。由于达赖集团和境外反华势力的干扰破坏，西藏长期面临着反对分裂、维护稳定的严峻局面。西藏工作必须以维护祖国统一、加强民族团结为着眼点和着力点，将确保稳定作为一切工作的前提。<br>②始终立足西藏工作的出发点和落脚点。要把改善民生、凝聚人心作为经济社会发展的出发点和落脚点。<br>③始终坚持西藏工作的重要原则。依法治藏、富民兴藏、长期建藏、凝聚人心、夯实基础，是党的十八大以后党中央提出的西藏工作重要原则。<br>④始终围绕西藏工作的主要任务。西藏工作在党和国家全局中具有特殊重要性，面临更加艰巨繁重的任务。要把抓好稳定、发展、生态、强边四件大事，确保国家安全和长治久安、确保人民生活水平不断提高、确保生态环境良好、确保边防巩固和边境安全，作为西藏工作的主要任务，做到重心不移、常抓不懈。<br>⑤始终着眼西藏工作的主题主线。不断推进长治久安和高质量发展，是西藏工作的长期奋斗目标，也是西藏工作鲜明的主题主线，是在新的发展阶段西藏工作的核心价值追求。</li>
<li>70 年来，西藏推翻了旧制度、建立了新政权，实行民族区域自治制度，党的民族政策和宗教政策全面贯彻，社会主义建设和改革开放深入推进，社会制度实现历史性跨越，经济社会实现全面发展，人民生活极大改善，城乡面貌今非昔比，实现了从黑暗走向光明、从落后走向进步、从贫穷走向富裕、从专制走向民主、从封闭走向开放的历史性转变。西藏发展进步取得巨大成就，书写了中国共产党百年光辉历程和伟大成就的生动篇章！</li>
<li>70 年来，西藏翻天覆地的巨大变化充分证明：没有中国共产党就没有新中国，也就没有新西藏，党中央关于西藏工作的方针政策是完全正确的。只有坚持中国共产党领导，坚持中国特色社会主义制度，坚持民族区域自治制度，坚持新时代党的治藏方略，才能实现西藏繁荣进步，才能开创西藏更加美好的未来！</li>
</ol>
<h3 id="三、全面依法治国"><a href="#三、全面依法治国" class="headerlink" title="三、全面依法治国"></a>三、全面依法治国</h3><ol>
<li>《法治政府建设实施纲要（2021—2025 年）》——法治政府建设是全面依法治国的重点任务和主体工程，是推进国家治理体系和治理能力现代化的重要支撑。<br>《纲要》是继《法治政府建设实施纲要（2015―2020 年）》后，中共中央、国务院出台的新的法治政府建设纲领性文件，是全面贯彻习近平法治思想的重大举措，是深入总结“十三五”时期法治政府建设成就经验的重要成果，是“十四五”时期全面推进法治政府建设的路线图和施工图，对在新发展阶段不断推进法治政府建设，更好发挥法治政府建设在保障高质量发展、推动全面深化改革、维护社会大局稳定等方面的重要作用，更好发挥法治政府建设在法治国家、法治社会建设中的示范带动作用，具有重大意义。</li>
<li>依法治国、依法执政、依法行政是一个有机整体，关键在于党要坚持依法执政、各级政府要坚持依法行政。法治国家、法治政府、法治社会相辅相成，法治国家是法治建设的目标，法治政府是建设法治国家的重点，法治社会是构筑法治国家的基础。推进全面依法治国，法治政府建设是重点任务和主体工程，对法治国家、法治社会建设具有示范带动作用，要率先突破。</li>
<li>①坚持党的全面领导，确保法治政府建设正确方向<br>② 为了人民 是法治政府建设的目标导向 依靠人民是法治政府建设的可靠力量。保障人民是法治政府建设的行动属性。<br>③ 权利—能力 ，是法治政府建设的脉络主线。其潜含逻辑是：为了维护人民权利，法治政府建设的着力点在于提升政府治理能力。<br>④ 数字法治政府 是法治政府建设的时代特色。<br>⑤ 人民满意 是法治政府建设的外在标准。</li>
<li>法治思想十一个坚持的内容：<br>一、坚持党对全面依法治国的领导；<br>二、坚持以人民为中心；<br>三、坚持中国特色社会主义法治道路；<br>四、坚持依宪治国、依宪执政；<br>五、坚持在法治轨道上推进国家治理体系和治理能力现代化；<br>六、坚持建设中国特色社会主义法治体系；<br>七、坚持依法治国、依法执政、依法行政，共同推进法治国家、法治政府、法治社会一体建设；<br>八、坚持全面推进科学立法、严格执法、公正司法、全民守法；<br>九、坚持统筹推进国内法治和涉外法治；<br>十、坚持建设德才兼备的高素质法制工作队伍；<br>十一、坚持抓住领导干部这个“关键少数”。</li>
<li>前进方向，方向决定道路，道路决定命运。深刻回答了全面依法治国由谁领导、依靠谁、走什么道路。三个坚持，回答了这三个大是大非的问题。</li>
<li>习近平同志指出：“党的领导是中国特色社会主义法治之魂，是我们的法治同西方资本主义国家的法治最大的区别。”“坚持中国特色社会主义法治道路，最根本的是坚持中国共产党的领导”党领导立法、保证执法、支持司法、带头守法。</li>
</ol>
<h2 id="专题八：全面建成小康社会"><a href="#专题八：全面建成小康社会" class="headerlink" title="专题八：全面建成小康社会"></a>专题八：全面建成小康社会</h2><p>习近平在全国脱贫攻坚总结表彰大会上发表重要讲话（2 月 25 日）<br>① 庄严宣告脱贫攻坚战取得了全面胜利。经过全党全国各族人民共同努力，在迎来中国共产党成立 100 周年的重要时刻，我国脱贫攻坚战取得了全面胜利，区域性整体贫困得到解决，完成了消除绝对贫困的艰巨任务，创造了又一个彪炳史册的人间奇迹！<br>② 提出脱贫攻坚精神。伟大事业孕育伟大精神，伟大精神引领伟大事业。脱贫攻坚伟大斗争，锻造形成了“上下同心、尽锐出战、精准务实、开拓创新、攻坚克难、不负人民”的脱贫攻坚精神。脱贫攻坚精神，是中国共产党性质宗旨、中国人民意志品质、中华民族精神的生动写照，是爱国主义、集体主义、社会主义思想的集中体现，是中国精神、中国价值、中国力量的充分彰显，赓续传承了伟大民族精神和时代精神。<br>③ 总结了脱贫攻坚取得举世瞩目的成就及其原因和经验。<br>④ 强调脱贫摘帽不是终点，而是新生活、新奋斗的起点。脱贫攻坚战的全面胜利，标志着我们党在团结带领人民创造美好生活、实现共同富裕的道路上迈出了坚实的一大步。同时，脱贫摘帽不是终点，而是新生活、新奋斗的起点。解决发展不平衡不充分问题、缩小城乡区域发展差距、实现人的全面发展和全体人民共同富裕仍然任重道远。我们没有任何理由骄傲自满、松劲歇脚，必须乘势而上、再接再厉、接续奋斗。</p>
]]></content>
      <categories>
        <category>时事政治</category>
      </categories>
      <tags>
        <tag>时事政治</tag>
      </tags>
  </entry>
  <entry>
    <title>直播回顾讲林晓斌：我的MySQL心路历程</title>
    <url>/posts/848144e0.html</url>
    <content><![CDATA[<p>在专栏上线后的11月21日，我来到极客时间做了一场直播，主题就是“我的MySQL心路历程”。今天，我特意将这个直播的回顾文章，放在了专栏下面，希望你可以从我这些年和MySQL打交道的经历中，找到对你有所帮助的点。</p>
<span id="more"></span>

<p>这里，我先和你说一下，在这个直播中，我主要分享的内容：</p>
<p>我和MySQL打交道的经历；</p>
<p>你为什么要了解数据库原理；</p>
<p>我建议的MySQL学习路径；</p>
<p>DBA的修炼之道。</p>
<p>我的经历<br>以丰富的经历进入百度<br>我是福州大学毕业的，据我了解，那时候我们学校的应届生很难直接进入百度，都要考到浙江大学读个研究生才行。没想到的是，我投递了简历后居然进了面试。</p>
<p>入职以后，我跑去问当时的面试官，为什么我的简历可以通过筛选？他们说：“因为你的简历厚啊”。我在读书的时候，确实做了很多项目，也实习过不少公司，所以简历里面的经历就显得很丰富了。</p>
<p>在面试的时候，有个让我印象很深刻的事儿。面试官问我说，你有这么多实习经历，有没有什么比较好玩儿的事？我想了想答道，跟你说个数据量很大的事儿 ，在跟移动做日志分析的时候我碰到了几千万行的数据。他听完以后就笑了。</p>
<p>后来，我进了百度才知道，几千万行那都是小数据。</p>
<p>开始尝试看源码解决问题<br>加入百度后，我是在贴吧做后端程序，比如权限系统等等。其实很简单，就是写一个C语言程序，响应客户端请求，然后返回结果。</p>
<p>那个时候，我还仅仅是个MySQL的普通用户，使用了一段时间后就出现问题了：一个跑得很快的请求，偶尔会又跑得非常慢。老板问这是什么原因，而我又不好意思说不知道，于是就自己上网查资料。</p>
<p>但是，2008年那会儿，网上资料很少，花了挺长时间也没查出个所以然。最终，我只好去看源码。翻到源码，我当时就觉得它还蛮有意思的。而且，源码真的可以帮我解决一些问题。</p>
<p>于是一发不可收拾，我从那时候就入了源码的“坑”。</p>
<p>混社区分享经验<br>2010年的时候，阿里正好在招数据库的开发人员。虽然那时我还只是看得懂源码，没有什么开发经验，但还是抱着试试看的态度投了简历。然后顺利通过了面试，成功进入了阿里。之后，我就跟着褚霸（霸爷）干了7年多才离开了阿里。</p>
<p>在百度的时候，我基本上没有参加过社区活动。因为那时候百度可能更提倡内部分享，解决问题的经验基本上都是在内网分享。所以，去了阿里以后，我才建了博客、开了微博。我在阿里的花名叫丁奇，博客、微博、社区也因此都是用的这个名字。</p>
<p>为什么要了解数据库原理？<br>这里，我讲几个亲身经历的事情，和你聊聊为什么要了解数据库原理。</p>
<p>了解原理能帮你更好地定位问题<br>一次同学聚会，大家谈起了技术问题。一个在政府里的同学说，他们的系统很奇怪，每天早上都得重启一下应用程序，否则就提示连接数据库失败，他们都不知道该怎么办。</p>
<p>我分析说，按照这个错误提示，应该就是连接时间过长了，断开了连接。数据库默认的超时时间是8小时，而你们平时六点下班，下班之后系统就没有人用了，等到第二天早上九点甚至十点才上班，这中间的时间已经超过10个小时了，数据库的连接肯定就会断开了。</p>
<p>我当时说，估计这个系统程序写得比较差，连接失败也不会重连，仍然用原来断掉的连接，所以就报错了。然后，我让他回去把超时时间改得长一点。后来他跟我说，按照这个方法，问题已经解决了。</p>
<p>由此，我也更深刻地体会到，作为开发人员，即使我们只知道每个参数的意思，可能就可以给出一些问题的正确应对方法。</p>
<p>了解原理能让你更巧妙地解决问题<br>我在做贴吧系统的时候，每次访问页面都要请求一次权限。所以，这个请求权限的请求，访问概率会非常高，不可能每次都去数据库里查，怎么办呢？</p>
<p>我想了个简单的方案：在应用程序里面开了个很大的内存，启动的时候就把整张表全部load到内存里去。这样再有权限请求的时候，直接从内存里取就行了。</p>
<p>数据库重启时，我的进程也会跟着重启，接下来就会到数据表里面做全表扫描，把整个用户相关信息全部塞到内存里面去。</p>
<p>但是，后来我遇到了一个很郁闷的情况。有时候MySQL 崩溃了，我的程序重新加载权限到内存里，结果这个select语句要执行30分钟左右。本来MySQL正常重启一下是很快的，进程重启也很快，正常加载权限的过程只需要两分钟就跑完了。但是，为什么异常重启的时候就要30分钟呢？</p>
<p>我没辙了，只好去看源码。然后，我发现MySQL有个机制，当它觉得系统空闲时会尽量去刷脏页。</p>
<p>具体到我们的例子里，MySQL重启以后，会执行我的进程做全表扫描，但是因为这个时候权限数据还没有初始化完成，我的Server层不可能提供服务，于是MySQL里面就只有我那一个select全表扫描的请求，MySQL就认为现在很闲，开始拼命地刷脏页，结果就吃掉了大量的磁盘资源，导致我的全表扫描也跑得很慢。</p>
<p>知道了这个机制以后，我就写了个脚本，每隔0.5秒发一个请求，执行一个简单的SQL查询，告诉数据库其实我现在很忙，脏页刷得慢一点。</p>
<p>脚本一发布使用，脏页果然刷得慢了，加载权限的扫描也跑得很快了。据说我离职两年多以后，这个脚本还在用。</p>
<p>你看，如果我们懂得一些参数，并可以理解这些参数，就可以做正确的设置了。而如果我们进一步地懂得一些原理，就可以更巧妙地解决问题了。</p>
<p>看得懂源码让你有更多的方法<br>2012年的时候，阿里双十一业务的压力比较大。当时还没有这么多的SSD，是机械硬盘的时代。</p>
<p>为了应对压力我们开始引入SSD，但是不敢把SSD直接当存储用，而是作为二级缓存。当时，我们用了一个叫作Flashcache的开源系统（现在已经是老古董级别了，不知道你有没有听过这个系统）。</p>
<p>Flashcache实现，把SSD当作物理盘的二级缓存，可以提升性能。但是，我们自己部署后发现性能提升的效果没有预想的那么好，甚至还不如纯机械盘。</p>
<p>于是，我跟霸爷就开始研究。霸爷负责分析Flashcache的源码，我负责分析MySQL源码。后来我们发现Flashcache是有脏页比例的，当脏页比例到了80%就会停下来强行刷盘。</p>
<p>一开始我们以为这个脏页比例是全部的20%，看了源码才知道，原来它分了很多个桶，比如说一个桶20M，这个桶如果用完80%，它就认为脏页满了，就开始刷脏页。这也就意味着，如果你是顺序写的话，很容易就会把一个桶写满。</p>
<p>知道了这个原理以后，我就把日志之类顺序写的数据全都放到了机械硬盘，把随机写的数据放到了Flashcache上。这样修改以后，效果就好了。</p>
<p>你看，如果能看得懂源码，你的操作行为就会不一样。</p>
<p>MySQL学习路径<br>说到MySQL的学习路径，其实我上面分享的这些内容，都可以归结为学习路径。</p>
<p>首先你要会用，要去了解每个参数的意义，这样你的运维行为（使用行为）就会不一样。千万不要从网上拿了一些使用建议，别人怎么用，你就怎么用，而不去想为什么。再往后，就要去了解每个参数的实现原理。一旦你了解了这些原理，你的操作行为就会不一样。 再进一步，如果看得懂源码，那么你对数据库的理解也会不一样。</p>
<p>再来讲讲我是怎么带应届生的。实践是很好的学习方式，所以我会让新人来了以后先搭主备，然后你就会发现每个人的自学能力都不一样。比如遇到有延迟，或者我们故意构造一个主备数据不一致的场景，让新人了解怎么分析问题，解决问题。</p>
<p>如果一定要总结出一条学习路径的话，那首先要会用，然后可以发现问题。</p>
<p>在专栏里面，我在每篇文章末尾，都会提出一个常见问题，作为思考题。这些问题都不会很难，是跟专栏文章挂钩、又是会经常遇到的，但又无法直接从文章里拿到答案。</p>
<p>我的建议是，你可以尝试先不看答案自己去思考，或者去数据库里面翻一翻，这将会是一个不错的过程。</p>
<p>再下一步就是实践。之后当你觉得开始有一些“线”的概念了，再去看MySQL的官方手册。在我的专栏里，有人曾问我要不要直接去看手册？</p>
<p>我的建议是，一开始千万不要着急看手册，这里面有100多万个英文单词，你就算再厉害，也是看了后面忘了前面。所以，你一定要自己先有脉络，然后有一个知识网络，再看手册去查漏补缺。</p>
<p>我自己就是这么一路走过来的。</p>
<p>另外，在专栏的留言区，很多用户都希望我能推荐一本书搭配专栏学习。如果只推荐一本的话，我建议你读一下《高性能MySQL》这本书，它是MySQL这个领域的经典图书，已经出到第三版了，你可以想象一下它的流行度。</p>
<p>这本书的其中两位译者（彭立勋、翟卫祥）是我原团队的小伙伴，有着非常丰富的MySQL源码开发经验，他们对MySQL的深刻理解，让这本书保持了跟原作英文版同样高的质量。</p>
<p>极客时间的编辑说，他们已经和出版社沟通，为我们专栏的用户争取到了全网最低价，仅限3天，你可以直接点击链接购买。</p>
<p>DBA的修炼<br>DBA和开发工程师有什么相同点？<br>我带过开发团队，也带过DBA团队，所以可以分享一下这两个岗位的交集。</p>
<p>其实，DBA本身要有些开发底子，比如说做运维系统的开发。另外，自动化程度越高，DBA的日常运维工作量就越少，DBA得去了解开发业务逻辑，往业务架构师这个方向去做。</p>
<p>开发工程师也是一样，不能所有的问题都指望DBA来解决。因为，DBA在每个公司都是很少的几个人。所以，开发也需要对数据库原理有一定的了解，这样向DBA请教问题时才能更专业，更高效地解决问题。</p>
<p>所以说，这两个岗位应该有一定程度的融合，即：开发要了解数据库原理，DBA要了解业务和开发。</p>
<p>DBA有前途吗？<br>这里我要强调的是，每个岗位都有前途，只需要根据时代变迁稍微调整一下方向。</p>
<p>像原来开玩笑说DBA要体力好，因为得搬服务器。后来DBA的核心技能成了会搭库、会主备切换，但是现在这些也不够用了，因为已经有了自动化系统。</p>
<p>所以，DBA接下来一方面是要了解业务，做业务的架构师；另一方面，是要有前瞻性，做主动诊断系统，把每个业务的问题挑出来做成月报，让业务开发去优化，有不清楚的地方，开发同学会来找你咨询。你帮助他们做好了优化之后，可以把优化的指标呈现出来。这将很好地体现出你对于公司的价值。</p>
<p>有哪些比较好的习惯和提高SQL效率的方法？<br>这个方法，总结起来就是：要多写SQL，培养自己对SQL语句执行效率的感觉。以后再写或者建索引的时候，知道这个语句执行下去大概的时间复杂度，是全表扫描还是索引扫描、是不是需要回表，在心里都有一个大概的概念。</p>
<p>这样每次写出来的SQL都会快一点，而且不容易犯低级错误。这也正式我开设这个专栏的目标。</p>
<p>看源码需要什么技术？<br>看源码的话，一是要掌握C和C++；另外还要熟悉一些调试工具。因为代码是静态的，运行起来是动态的，看代码是单线程的，运行起来是多线程的，所以要会调试。</p>
<p>另外，我不建议你用可视化的工具。虽然可视化工具很方便，但你不知道这个操作点下去以后，实际上做了什么，所以我建议你自己手写代码和SQL语句，这样对一些底层原理你会更明白。</p>
<p>怎么学习C、C++？<br>我在读研究生的时候，在C和C++语言的学习上进步最大。</p>
<p>那时，我去给专科上C和C++的课。我觉得自己已经会了，完全可以教得了。但去了之后，我才知道，自己会跟能够教别人完全是两码事儿。备课的时候，你不能只讲会用的部分，还得把原理讲清楚。这样，就会倒逼自己进行更深入更全面的学习。</p>
<p>有的人看完技术博客和专栏，会把这篇文章的提纲列一下，写写自己的问题和对这篇文章的理解。这个过程，是非常利于学习的。因为你听进来是一回事儿，讲出去则是另一回事儿。</p>
<p>学数据库要保持什么心态？<br>不只是数据库，所有多线程的服务，调试和追查问题的过程都是很枯燥的，遇到问题都会很麻烦。但是，你找出问题时的那一下会很爽。</p>
<p>我觉得你得找到这种感觉，它可以支持你度过接下来要枯燥很久的那段时光，这样你才能继续坚持下去。</p>
<p>当然，如果有更快乐的学习过程还是更好的，希望这个专栏能让你学习得轻松些。</p>
<hr>
<p>《MySQL实战45讲》原文：<a href="https://funnylog.gitee.io/mysql45/">传送门</a></p>
<p>注：本人博客的《MySQL实战45讲》系列是搬运的，纯属收藏学习，不做任何商业盈利。如果有版权问题，请联系我删除。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
        <category>MySQL实战45讲</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>MySQL实战45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>约MM的23种设计模式</title>
    <url>/posts/111e5622.html</url>
    <content><![CDATA[<h2 id="1、FACTORY-工厂方法"><a href="#1、FACTORY-工厂方法" class="headerlink" title="1、FACTORY 工厂方法"></a>1、FACTORY 工厂方法</h2><p>追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory 工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<span id="more"></span>
<p>​</p>
<h2 id="2、BUILDER-建造者模式"><a href="#2、BUILDER-建造者模式" class="headerlink" title="2、BUILDER 建造者模式"></a>2、BUILDER 建造者模式</h2><p>MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖） 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。<br>​</p>
<h2 id="3、FACTORY-METHOD-抽象工厂"><a href="#3、FACTORY-METHOD-抽象工厂" class="headerlink" title="3、FACTORY METHOD 抽象工厂"></a>3、FACTORY METHOD 抽象工厂</h2><p>请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。<br>​</p>
<h2 id="4、PROTOTYPE-原型模式"><a href="#4、PROTOTYPE-原型模式" class="headerlink" title="4、PROTOTYPE 原型模式"></a>4、PROTOTYPE 原型模式</h2><p>跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要） 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。<br>​</p>
<h2 id="5、SINGLETON-单态模式"><a href="#5、SINGLETON-单态模式" class="headerlink" title="5、SINGLETON 单态模式"></a>5、SINGLETON 单态模式</h2><p>俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事) 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。<br>​</p>
<h2 id="6、ADAPTER-适配器模式"><a href="#6、ADAPTER-适配器模式" class="headerlink" title="6、ADAPTER 适配器模式"></a>6、ADAPTER 适配器模式</h2><p>在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我) 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。<br>​</p>
<h2 id="7、BRIDGE-桥梁模式"><a href="#7、BRIDGE-桥梁模式" class="headerlink" title="7、BRIDGE 桥梁模式"></a>7、BRIDGE 桥梁模式</h2><p>早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合&#x2F;聚合关系而不是继承关系，从而使两者可以独立的变化。<br>​</p>
<h2 id="8、COMPOSITE-合成模式"><a href="#8、COMPOSITE-合成模式" class="headerlink" title="8、COMPOSITE 合成模式"></a>8、COMPOSITE 合成模式</h2><p>Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？ 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。<br>​</p>
<h2 id="9、DECORATOR-装饰模式"><a href="#9、DECORATOR-装饰模式" class="headerlink" title="9、DECORATOR 装饰模式"></a>9、DECORATOR 装饰模式</h2><p>Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。1增加由一些基本功能的排列组合而产生的非常大量的功能。<br>​</p>
<h2 id="10、FACADE-门面模式"><a href="#10、FACADE-门面模式" class="headerlink" title="10、FACADE 门面模式"></a>10、FACADE 门面模式</h2><p>我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。<br>​</p>
<h2 id="11、FLYWEIGHT-享元模式"><a href="#11、FLYWEIGHT-享元模式" class="headerlink" title="11、FLYWEIGHT 享元模式"></a>11、FLYWEIGHT 享元模式</h2><p>每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。 享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。<br>​</p>
<h2 id="12、PROXY-代理模式"><a href="#12、PROXY-代理模式" class="headerlink" title="12、PROXY 代理模式"></a>12、PROXY 代理模式</h2><p>跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。<br>​</p>
<h2 id="13、CHAIN-OF-RESPONSIBLEITY-责任链模式"><a href="#13、CHAIN-OF-RESPONSIBLEITY-责任链模式" class="headerlink" title="13、CHAIN OF RESPONSIBLEITY 责任链模式"></a>13、CHAIN OF RESPONSIBLEITY 责任链模式</h2><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑! 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。<br>​</p>
<h2 id="14、COMMAND-命令模式"><a href="#14、COMMAND-命令模式" class="headerlink" title="14、COMMAND 命令模式"></a>14、COMMAND 命令模式</h2><p>俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。<br>​</p>
<h2 id="15、INTERPRETER-解释器模式"><a href="#15、INTERPRETER-解释器模式" class="headerlink" title="15、INTERPRETER 解释器模式"></a>15、INTERPRETER 解释器模式</h2><p>俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。<br>​</p>
<h2 id="16、ITERATOR-迭代子模式"><a href="#16、ITERATOR-迭代子模式" class="headerlink" title="16、ITERATOR 迭代子模式"></a>16、ITERATOR 迭代子模式</h2><p>我爱上了Mary，不顾一切的向她求婚。 Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” …… 迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。<br>​</p>
<h2 id="17、MEDIATOR-调停者模式"><a href="#17、MEDIATOR-调停者模式" class="headerlink" title="17、MEDIATOR 调停者模式"></a>17、MEDIATOR 调停者模式</h2><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。 调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。<br>​</p>
<h2 id="18、MEMENTO-备忘录模式"><a href="#18、MEMENTO-备忘录模式" class="headerlink" title="18、MEMENTO 备忘录模式"></a>18、MEMENTO 备忘录模式</h2><p>同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。<br>​</p>
<h2 id="19、OBSERVER-观察者模式"><a href="#19、OBSERVER-观察者模式" class="headerlink" title="19、OBSERVER 观察者模式"></a>19、OBSERVER 观察者模式</h2><p>想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。<br>​</p>
<h2 id="20、STATE-状态模式"><a href="#20、STATE-状态模式" class="headerlink" title="20、STATE 状态模式"></a>20、STATE 状态模式</h2><p>跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。<br>​</p>
<h2 id="21、STRATEGY-策略模式"><a href="#21、STRATEGY-策略模式" class="headerlink" title="21、STRATEGY 策略模式"></a>21、STRATEGY 策略模式</h2><p>跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。 策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。<br>​</p>
<h2 id="22、TEMPLATE-METHOD-模板方法模式"><a href="#22、TEMPLATE-METHOD-模板方法模式" class="headerlink" title="22、TEMPLATE METHOD 模板方法模式"></a>22、TEMPLATE METHOD 模板方法模式</h2><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)； 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。<br>​</p>
<h2 id="23、VISITOR-访问者模式"><a href="#23、VISITOR-访问者模式" class="headerlink" title="23、VISITOR 访问者模式"></a>23、VISITOR 访问者模式</h2><p>情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。<br>​</p>
<p><a href="https://zhuanlan.zhihu.com/p/100746724">原文传送门</a></p>
<p><img src="https://img2020.cnblogs.com/blog/955921/202106/955921-20210614232028522-1214966270.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化思维</title>
    <url>/posts/ec1ab3bc.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>结构化思维</code> 是指在思考分析解决问题时，以一定的范式流程顺序进行，首先以假设为先导，对问题进行正确的界定，假设并罗列问题构成的要素，其次对要素进行合理分类，排除非关键分类，对重点分类进行分析，寻找对策，制订行动计划。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>结构化思维方法，就是<code>以事物的结构为思维对象，以对事物结构的积极建构为思维过程，力求得出事物客观规律的一种思维方法</code>。布鲁纳指出“掌握事物的结构，就是以允许许多别的东西与它有意义地联系起来的方式去理解它，简单的说，学习结构就是学习事物是怎样相互关联的。”</p>
<h2 id="培养方法"><a href="#培养方法" class="headerlink" title="培养方法"></a>培养方法</h2><p>结构化思维，首先是一种<code>思维方式</code>，其次才是一种<code>管理方法</code>。因此，对于更多的刚刚走上管理岗位的朋友来说，需要经过有意识地持续训练，才能够培养起这样的思维方式和思维习惯。“好脑子”不如“烂笔头”，纸和笔是训练结构化思维的最有利的工具。</p>
<p>首先，强烈建议希望学习结构化思维的朋友，要<code>勤于写作</code>。<br>任何一篇文章，包括文学作品，都是结构化思维的产物。很多朋友觉得写东西太难，其实症结不在于对文字的把握，而恰恰是对缺乏对思维结构的把握。<br>所有文章，必然要有“中心思想”，这就是结构化思维中的“确立目标”；<br>为了表述这个“中心思想”，必然要分段陈述，各个段落有各自的“段落大意”，来支持“中心思想”，这个就是结构化思维中的“资源分析”；<br>提纲出来以后，分段展开陈述形成文字，就是结构化思维中的“制订计划”。<br>很多朋友写文章写着写着，或者写不下去了，或者跑题了，如是几次就失去了写作的信心。<br>其实在此刻遇到的障碍，正是你在“结构化思维”训练中的不足，抱着哪怕推翻重写的决心坚持写下去，也就突破了“结构化思维”培养过程中的自身障碍，持之以恒，结构化思维就会形成自己固有的思维习惯。</p>
<p>其次，在日常工作中遇到复杂问题（哪些是复杂问题，因人而异）需要决策时，养成如下习惯：</p>
<blockquote>
<ol>
<li>准备好笔和几张纸；</li>
<li>在一张纸上写下几个可能的目标，想到就写，不要在此时要求自己思考周密，反正是草稿；</li>
<li>在另一张纸上对第一张纸上的目标实现所需要的资源分别列出，列的时候可暂时不考虑资源冲突，有助于你对每一个目标都考虑周全，而不瞻前顾后。这时你已经具备了几个备选方案，给他们编上号；</li>
<li>在第三张纸上再结合资源冲突，对第二纸上的各个编号方案分别列出“好处”与“风险”；</li>
<li>以“两害相权取其轻”为原则，在备选方案中选择一个方案；</li>
<li>对选择出来的方案进行精加工，形成一个可执行方案。可执行方案的标准是：<br>（1） 该方案中的资源是你具有而且可支配的；<br>（2） 方案中有明确的时间限制；<br>（3）方案中各环节都具有可检查的指标；<br>（4）方案最终有交付物。</li>
</ol>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wiki.mbalib.com/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4">https://wiki.mbalib.com/wiki/结构化思维</a><br><a href="https://baike.baidu.com/item/%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4/1482961">https://baike.baidu.com/item/结构化思维/1482961</a><br><a href="https://www.sohu.com/a/458005396_114819">https://www.sohu.com/a/458005396_114819</a></p>
]]></content>
      <categories>
        <category>思维逻辑</category>
      </categories>
      <tags>
        <tag>思维逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>考研政治必备（1）</title>
    <url>/posts/2fe6597a.html</url>
    <content><![CDATA[<h2 id="1-为什么十八大以来我们党能取得如此优异的成就"><a href="#1-为什么十八大以来我们党能取得如此优异的成就" class="headerlink" title="(1)为什么十八大以来我们党能取得如此优异的成就?"></a>(1)为什么十八大以来我们党能取得如此优异的成就?</h2><p>中国共产党已走过百年奋斗历程，全党全国各族人民正迈向全面建设社会主义现代化国家的新征程。面对百年未有之大变局和复杂的国际形势，我们要在党的带领下，高举中国特色社会主义伟大旗帜，全面贯彻习近平新时代中国特色社会主义思想，弘扬伟大建党精神，踔厉奋发，以中国式现代化全面推进中华民族伟大复兴。</p>
<span id="more"></span>


<p>① ++主题++，我们有坚强领导核心，全党确立了习近平同志党中央的核心地位、全党的核心地位，确立习近平新时代中国特色社会主义思想的指导地位。<br>②  ++主题++ 党找到了自我革命这一跳出治乱兴衰历史周期率的第二个答案，确保党永远不变质，这是共产党区别于其他政党的显著标志。<br>③ 党与人民血肉联系，坚持人民至上，必胜信念更加坚定，带领人民迎来了中华民族从站起来，富起来到强起来的伟大飞跃。<br>④ 坚持用科学的理论思想武装自己，科学社会主义在二十一世纪的中国焕发出新的 蓬勃生机。<br>⑤ 我们贯彻新发展理念，构建新发展格局，在新的历史阶段下，全面贯党的基本路线、基本方略，采取了一系列的战略举措。</p>
<h2 id="2-如何理解新时代十年伟大变革具有里程碑的意义"><a href="#2-如何理解新时代十年伟大变革具有里程碑的意义" class="headerlink" title="(2)如何理解新时代十年伟大变革具有里程碑的意义?"></a>(2)如何理解新时代十年伟大变革具有里程碑的意义?</h2><p>① 主题 明确宣示了我们党在新时代新征程上举什么旗，走什么路，以什么样的精神状态，朝着什么样的目标继续前进等重大问题，中国人民的美好生活不断跃上新台阶，中国人民的前进动力更加强大<br>② ++主题++ 我们创立了习近平新时代中国特色社会主义思想，强调“两个确立”是党在新时代取得的重大政治成果，产生了一个凝聚全党共识、值得全党全军全国各族人民充分信赖的中央领导集体。<br>③ ++主题++ 开辟马克思主义中国化时代化新境界。明确提出“中国共产党为什么能，中国特色社会主义为什么好，归根到底是马克思主义行，是中国化时代化的马克思主义行”，深刻阐述了习近平新时代中国特色社会主义思想的世界观和方法论，实现了马克思主义中国化时代化新的飞跃。<br>④ ++主题++ 我们深入推进全面从严治党，提出实现中华民族伟大复兴的中国梦，明确我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，并紧紧围绕这个社会主要矛盾推进各项工作，我们实现了小康这个中华民族的千年梦想，打赢了人类历史上规模最大的脱贫攻坚战，历史性地解决了绝对贫困问题。<br>党和国家事业取得历史性成就、发生历史性变革，最根本的原因在于有习近平总书记作为党中央的核心、全党的核心掌舵领航，在于有习近平新时代中国特色社会主义思想科学指引。我们要以更加强烈的历史主动精神继续推进和拓展中国式现代化，为全面推进中华民族伟大复兴而团结奋斗。</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>邓小平理论</title>
    <url>/posts/f820ce5e.html</url>
    <content><![CDATA[<p>邓小平理论是马克思主义中国化的一大理论成果，是中国共产党获得的与苏联模式不同的社会主义建设经验的理论总结。并且是在毛泽东思想基础上发展而成。</p>
<span id="more"></span>

<h1 id="党在社会主义初级阶段的基本路线"><a href="#党在社会主义初级阶段的基本路线" class="headerlink" title="党在社会主义初级阶段的基本路线"></a>党在社会主义初级阶段的基本路线</h1><p>我国还处在社会主义初级阶段的科学论述是邓小平建设有中国特色社会主义理论的重要基础，是我们制定路线、方针、政策的根本出发点。</p>
<p>党在社会主义初级阶段的基本路线是：“领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。”</p>
<h1 id="发展生产力是社会主义的根本任务"><a href="#发展生产力是社会主义的根本任务" class="headerlink" title="发展生产力是社会主义的根本任务"></a>发展生产力是社会主义的根本任务</h1><p>首先，发展生产力是社会主义本质的要求。</p>
<p>其次，就我国来说，发展生产力是解决社会主要矛盾的根本途径。</p>
<p>最后，发展生产力，建立强大的社会主义物质技术基础，是建设社会主义民主法制和精神文明不可缺少的条件。</p>
<h1 id="三个有利于的判断标准"><a href="#三个有利于的判断标准" class="headerlink" title="三个有利于的判断标准"></a>三个有利于的判断标准</h1><p>判断标准：是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民的生活水平。</p>
<h1 id="社会主义市场经济理论的提出"><a href="#社会主义市场经济理论的提出" class="headerlink" title="社会主义市场经济理论的提出"></a>社会主义市场经济理论的提出</h1><p>1984年10月，党的十二届三中全会通过了《中共中央关于经济体制改革的决定》，明确指出：社会主义经济，是在公有制基础上的有计划的商品经济，商品经济的充分发展，是社会经济不可逾越的阶段，是实现我国经济现代化的必要条件。</p>
<h1 id="社会主义市场经济的基本特征"><a href="#社会主义市场经济的基本特征" class="headerlink" title="社会主义市场经济的基本特征"></a>社会主义市场经济的基本特征</h1><p>与资本主义经济的共同特征：企业的自主经营，资源配置的市场性，经济活动的开放性，完善的市场体系，市场管理的法制性，宏观调控的间接性，市场竞争的平等性。</p>
<p>社会主义市场经济自身特征：</p>
<ol>
<li><p>在所有制结构上，以公有制为主体，多种所有制经济共同发展。</p>
</li>
<li><p>在分配制度上，坚持按劳分配为主体，多种分配方式并存的制度。</p>
</li>
<li><p>在宏观调控上，能把人民的当前利益与长远利益、局部利益与整体利益结合起来，更好地发挥计划和市场两手段的长处。</p>
</li>
<li><p>在政治制度上，共产党领导下的人民民主政权是社会主义的基本政治制度。</p>
</li>
</ol>
<h1 id="邓小平理论形成的时代背景和历史条件"><a href="#邓小平理论形成的时代背景和历史条件" class="headerlink" title="邓小平理论形成的时代背景和历史条件"></a>邓小平理论形成的时代背景和历史条件</h1><ol>
<li>是在和平和发展成为时代的主题和新技术革命浪潮兴起的历史条件下形成的，</li>
<li>是在总结中国和其他国家社会主义建设经验教训的基础上形成的，</li>
<li>是在中国改革开放和现代化建设的实践过程中形成和发展起来的。</li>
</ol>
<p>（多选题）邓小平理论形成的时代背景和历史条件是：（）<br> A. 时代主题由战争和革命转变为和平和发展<br> B. 新技术革命引起当代世界的深刻变化<br> C. 我国社会主义的胜利和挫折<br> D. 其他社会主义国家的兴衰成败</p>
<details>
  <summary>查看答案</summary>
  
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABCD</span><br></pre></td></tr></table></figure>
</details>

<h1 id="“解放思想”是指？"><a href="#“解放思想”是指？" class="headerlink" title="“解放思想”是指？"></a>“解放思想”是指？</h1><p>邓小平同志深刻指出：“解放思想，是指在马克思主义指导下打破习惯势力和主观偏见的束缚，研究新情况，解决新问题。”<br>（单选题）“解放思想，实事求是”中的“解放思想”是指（  ）。<br> A. 在马克思主义指导下打破习惯势力和主观偏见的束缚，研究新情况，解决新问题<br> B. “大胆地试、大胆地闯”<br> C. 一切从实际出发，走自己的路<br> D. 排除姓“资”姓“社”抽象理论的干扰</p>
<details>
  <summary>查看答案</summary>
  
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
</details>

<h1 id="邓小平理论成熟的标志"><a href="#邓小平理论成熟的标志" class="headerlink" title="邓小平理论成熟的标志"></a>邓小平理论成熟的标志</h1><p>“南方谈话”及时深刻地回答了我国改革开放中“什么是社会主义，怎样建设社会主义” 的重大问题，极大地解放了人们的思想和坚定了人们的社会主义信念，极大地推动了我国改革开放的进程，是 建设有中国特色的社会主义道路上的又一座里程碑。邓小平南方谈话的发表，标志着邓小平理论的成熟，明确 提出“建设有中国特色的社会主义”的命题，标志着邓小平理论进人初步形成时期。</p>
<h1 id="其他考点"><a href="#其他考点" class="headerlink" title="其他考点"></a>其他考点</h1><ol>
<li>十一届三中全会，邓小平成为党的第二代中央领导集体的核心，也标志着邓小平理论作为马克思主义中国化的一个新的理论成果开始形成。</li>
<li>解放思想，实事求是，是我们党的思想路线，是马列主义的精髓，是毛泽东思想的精髓，也是邓小平理论的精髓。这八个字，集中体现了邓小平同志运用马克思主义立场、观点、方法研究新情况、解决新问题的科学态度，贯穿于他的整个理论的各个层次各个方面和全部内容的始终，是这一理论具有盎然生机的源泉。邓小平理论的全部内容，都是解放思想、实事求是的产物。</li>
<li>“什么是社会主义，怎样建设社会主义”是建设中国特色社会主义的首要的基本理论问题，也是邓小平理论的主题。</li>
<li>1997年9月召开的党的十五大正式提出“邓小平理论”这一科学概念，科学阐述了邓小平 理论的历史地位和指导意义，强调指出邓小平理论是当代中国的马克思主义，是马克思主义在中国发展的新阶段。</li>
<li>党的十三大到十四大，是邓小平理论体系的正式形成阶段，这一时期提出了社会主义市场经济理论、社会主义本质理论、“三个有利于”标准的理论、“发展才是硬道理”的理论等。另外，社会主义初级阶段的基本纲领是江泽民同志在党的第十五次全国代表大会上提出的。</li>
<li>马克思列宁主义、毛泽东思想是邓小平理论形成的理论基础。 社会主义建设正反两方面历史经验的总结，是邓小平理论形成的历史根据。我国改革开放和现代化建设的实践，是邓小平理论形成的现实依据。当代国际局势的新发展，是邓小平理论形成的时代背景。</li>
</ol>
]]></content>
      <categories>
        <category>时事政治</category>
      </categories>
      <tags>
        <tag>时事政治</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构知识点大汇总</title>
    <url>/posts/c5c682e7.html</url>
    <content><![CDATA[<h1 id="一、数据结构绪论"><a href="#一、数据结构绪论" class="headerlink" title="一、数据结构绪论"></a>一、数据结构绪论</h1><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><ul>
<li>数据结构是一门研究非数值计算的程序设计问题中，计算机的操作对象以及它们之间的关系和操作的学科。</li>
<li>数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。</li>
<li>数据结构包含三个方面的含义：</li>
</ul>
<span id="more"></span>

<p><img src="https://pic2.zhimg.com/80/v2-07bfa931348a5e0f453f2897111cde65_720w.jpg"></p>
<ul>
<li>逻辑结构：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-67422d086f8325df4da74c70f4092e98_720w.jpg"></p>
<ul>
<li>物理结构：数据的逻辑结构在计算机中的表示，称此为物理结构，或称存储结构。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-313aca63d8026554b8aa54bb779b8ed7_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d6aa238b9019852e39685d50e46ccd7e_720w.jpg"></p>
<ul>
<li>数据类型：一个值的集合以及定义在这个值集上的一组操作的总称。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-dafe9fa237716a0282ab6b0d8a41aeaa_720w.jpg"></p>
<ul>
<li>抽象数据类型：通常由用户定义，用以表示应用问题的数据模型以及定义在该模型上的一组操作。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-0aea97a0064d87736684facb51d1a7bb_720w.jpg"></p>
<ul>
<li>算法是描述计算机解决给定问题的操作过程，即为决解某一特定问题而由若干条指令组成的有穷序列。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-8acf1b8ccd6ff04473d0bc9e904cf4ef_720w.jpg"></p>
<h2 id="算法的效率分析"><a href="#算法的效率分析" class="headerlink" title="算法的效率分析"></a>算法的效率分析</h2><ul>
<li>事后统计法：收集该算法实际的执行时间和实际占用空间的统计资料。</li>
<li>事前分析估算法：在算法运行之前分析该算法的时间复杂度和空间复杂度，来判断算法的效率。</li>
<li>时间复杂度分析：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-908d4962568fef15335d30bec58e47b4_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ae8a1f489ec672b23d4e8a20c79b9247_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7041bb4dffb31fb337b759074273a251_720w.jpg"></p>
<ul>
<li>常见函数的时间复杂度按数量递增排列及增长率：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-2aed58857ffe85c71cbd16955318155e_720w.jpg"></p>
<h1 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h1><h2 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h2><ul>
<li>线性表是n(n&gt;0)个相同类型数据元素构成的有限序列，其中n为线性表的长度。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-3d298000b4f6e33c8aa11dfcf1940f33_720w.jpg"></p>
<ul>
<li>线性表的基本操作：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5cc2bcd52d2644cdf8dc9fcdc722c2ce_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-4632549a9b499795f6c8ff0230bbf728_720w.jpg"></p>
<h2 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h2><ul>
<li>线性表的顺序存储结构：用一组地址连续的存储单元依次存储线性表的元素。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-388edc6deae96ba68aad04bb03dda7e4_720w.jpg"></p>
<ul>
<li>线性表的顺序存储，也成为向量存储，又可以说是一维数组存储。线性表中结点存放的物理顺序与逻辑顺序完全一致，它叫向量存储。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-196c9909863cdfb930f7f231208ff196_720w.jpg"></p>
<ul>
<li><p>线性表顺序存储结构在插入或删除数据元素时比较繁琐，但是它比较适合存取数据元素。</p>
</li>
<li><p>线性表的插入操作：在第i个元素之前插入一个元素时，需将第n至第i（共n-i+1）个元素向后移动一个位置。</p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-92476273c6e989e2c7ee5c7888e8a585_720w.jpg"></p>
<ul>
<li>线性表的删除操作：删除第i个元素时需将从第i+1至第n（共n-i）个元素一次向前移动一个位置</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-6fe7742fa810cd5e76335ca97763c783_720w.jpg"></p>
<h2 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h2><ul>
<li>用一组任意的存储单元（可能不连续）存储线性表的数据元素。</li>
<li>在链式存储结构中，每个存储结点不仅包含数据元素本身的信息，还必须包含每个元素之间逻辑关系的信息，即包含直接后继结点的地址信息（指针域）。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-189a8060f9b811eff5666564339fd620_720w.jpg"></p>
<ul>
<li>逻辑顺序与物理顺序有可能不一致；属顺序存取的存储结构，即存取每个元素必须从第一个元素开始遍历，直到找到需要访问的元素，所以所花时间不一定相等。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-46dba8149a5e89d3534ca8f7b1e45e67_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ea205a362c153ea51793c05ef9037e06_720w.jpg"></p>
<ul>
<li>链表的创建方式</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-46fea85644349f1ac44e153d100316a7_720w.jpg"></p>
<ul>
<li>结点类的定义：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-e2ea9c980699ce5478cf1aa5b12f189e_720w.jpg"></p>
<h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><ul>
<li>插入方式——头插法：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-aef6fb70ba86d5f0d1c334bd3e35ead2_720w.jpg"></p>
<ul>
<li>插入方式——尾插法：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-7b2eb6ec4c4afc5a38e143fe2858ad56_720w.jpg"></p>
<ul>
<li>查找运算——按序号查找：在链表中，即使知道被访问结点的序号i，也不能像顺序表中那么直接按序号i访问结点，而只能从链表的头指针除法，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止。链表不是随机存取结构，只能顺序存取。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-8a6dc704741de67f5af3ed3b2498bfd8_720w.jpg"></p>
<ul>
<li>查找运算——按数值查找：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-5556b06d6943e623028a635ec83e4dfd_720w.jpg"></p>
<ul>
<li>删除结点：将被删除结点的前驱指针连接被删除结点的后继指针</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-271421379bfbc66a11edded2efec4f3f_720w.jpg"></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><ul>
<li>表中尾结点的指针域指向头结点，形成一个环。从表中任意一个点出发都可以找到表中其他的结点。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-711bcd436a8d8a3d936115f5e9d94a93_720w.jpg"></p>
<ul>
<li>循环链表的操作和线性链表的操作基本一致，但循环链表中没有NULL指针，故遍历操作时，终止条件不再是判断p或p.next是否为空，而是判断他们是否等于某一指定指针，如头指针或尾指针。</li>
</ul>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><ul>
<li>双向链表是在单链表的每个结点里再增加一个指向其直接前驱的指针域prior。这样就形成了链表中有两个方向不同的链，故称为双向链表。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-621913a57aee74643bc1f802e8277900_720w.jpg"></p>
<ul>
<li>双线链表——头插法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-041979b4cc9207654471910437d99b68_720w.jpg"></p>
<ul>
<li>双向链表——尾插法：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-a1d1250730ebc633905d2d2f98a539fd_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-dd768ec6c7cf2fd3d4dc067bb28af257_720w.jpg"></p>
<ul>
<li>插入操作</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-867cc4cebca6dfe73c6c4660d11281da_720w.jpg"></p>
<h1 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h1><h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><ul>
<li>栈是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶，另一端为栈底。当表中没有元素时成为空栈。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-d5091c84f3bb17c3a3f80b9299e5a712_720w.jpg"></p>
<ul>
<li>栈的进出顺序判断：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-08c65046288af6eec904c99bac9b3521_720w.jpg"></p>
<ul>
<li>栈的基本操作：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-2f3ead4f984573e74a42ec2ca150ed8d_720w.jpg"></p>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><ul>
<li>顺序栈利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时由于栈的操作的特殊性，还必须附设一个位置指针top来动态地指示栈顶元素的顺序栈中的位置。通常以top&#x3D;0表示空栈。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-5573d1c0ae9d45f6e842b65b213ea768_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3d1329ee06a8af52e0e13fed06752e61_720w.jpg"></p>
<ul>
<li>顺序栈的基本运算：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-46c3c361da816a3731d362a90ba31c5b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-df835b40632839a2fe21412dc758ff61_720w.jpg"></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>采用链表作为存储结构实现的栈。为便于操作，采用带头结点的单链表实现栈。因为栈的插入和删除操作仅限制在表头位置进行，所以链表的表头指针就作为栈顶指针。</p>
<p><img src="https://pic2.zhimg.com/80/v2-741400706272320f63a07ff56f7a2e39_720w.jpg"></p>
<h2 id="顺序栈和链式栈的比较"><a href="#顺序栈和链式栈的比较" class="headerlink" title="顺序栈和链式栈的比较"></a>顺序栈和链式栈的比较</h2><p>实现链式栈和顺序栈的操作都是需要常数时间，即时间复杂度为O（1），主要从空间和时间两个方面考虑。初始时，顺序堆栈必须说明一个固定的长度，当堆栈不够满时，造成一些空间的浪费，而链式堆栈的长度可变则使长度不需要预先设定，相对比较节省空间，但是在每个节点中设置了一个指针域，从而产生了结构开销。</p>
<h2 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h2><ul>
<li>队列是一种先进先出的线性表，它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入数据一端成为队尾（rear），允许删除的那一端称为队头（front）。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-d46aea143363ba5c029c698aa3b780ce_720w.jpg"></p>
<ul>
<li>队列的基本操作：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-d70af15008ff1a2670561fa899bffff4_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e15fd358174b0a3ce0cceadc0e0071bf_720w.jpg"></p>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><ul>
<li>顺序队列利用一组地址连续的存储单元依次存放自队首到队尾的数据元素，同时由于队的操作的特殊性，还必须附两个位置指针front和rear来动态地指示队首元素和队尾元素在顺序队列中的位置。通常front&#x3D;rear表示空队列。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-59480682f50923d591333d0f0de66a14_720w.jpg"></p>
<ul>
<li>队列同堆栈一样也有上溢和下溢现象。以外，队列中还存在“假溢出”现象。所谓“假溢出”是指在入队和出队操作中，头尾指针不断增加而不减小或只减小而不增加，致使被删除元素的空间无法重新利用，最后造成队列中有空闲空间，但是不能够插入元素，也不能够删除元素的现象。</li>
</ul>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>采用链表作为存储结构实现的队列。为便于操作，采用带头结点的单链表实现队列。因为队列的插入和删除操作位置不同，所以链表需要设置表头指针和表尾指针分别指队首和队尾。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><ul>
<li>假设向量的空间是m,只要在入出队列时，将队首和队尾的指针对m做求模运算即可实现队首和队尾指针的循环，即队首和队尾指针的取值范围是0到m-1之间。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-afcc91bf4a024b52a5d5cd1c05b11948_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-7ddabab9f742b2c3123c8b554c2bdf54_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ef1b6a08a9ea8339529c8d5b3d0b70db_720w.jpg"></p>
<ul>
<li>判断队空和队满的方法</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-f95d173ae01a4e6c2ce19aa1dc8f4bb1_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-030e5698e1f15ff3c169b1d25ee581b6_720w.jpg"></p>
<h1 id="四、数组和广义表"><a href="#四、数组和广义表" class="headerlink" title="四、数组和广义表"></a>四、数组和广义表</h1><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><ul>
<li>数组是我们熟悉的数据类型，数组中各元素具有统一的类型，并且数组元素的下标一般具有固定的上界和下界，因此，数组的处理比其它复杂的结构更为简单。</li>
<li>任何数组A都可以看作一个线性表。数组维数确定后，数据元素个数和元素之间的关系不再发生改变，适合顺序存储。</li>
<li>数组的基本操作</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-09ad2d1b7726cceec9edf10cef951fcb_720w.jpg"></p>
<h2 id="数组的顺序表示和实现"><a href="#数组的顺序表示和实现" class="headerlink" title="数组的顺序表示和实现"></a>数组的顺序表示和实现</h2><ul>
<li>行优先顺序</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-c5f509ba99249451c5bdc079beb843ee_720w.jpg"></p>
<ul>
<li>列优先顺序</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ff97b41170c164359bedb08d56df9232_720w.jpg"></p>
<h2 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h2><ul>
<li>有些特殊矩阵，非零元素呈某种规律分布或者矩阵中出现大量的零元素的情况下，会占用许多单元去存储重复的非零元素或零元素，这对高阶矩阵会造成极大的浪费，为了节省存储空间，对这类矩阵进行压缩存储——即为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。</li>
<li>特殊矩阵：所谓特殊矩阵是指非零元素或零元素的分布有一定规律的矩阵，如对称矩阵、三角矩阵、对角矩阵等等。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-097b7d4f32bf6362978180317a67f760_720w.jpg"></p>
<h2 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h2><p><img src="https://pic3.zhimg.com/80/v2-3524e6e2fabc998fca223b2e8103be92_720w.jpg"></p>
<ul>
<li><p>对称矩阵中元素关于主对角线对称，故只要存储矩阵中上三角或下三角中的元素，让每两个对称的元素共享一个存储空间，这样能节约近一半的存储空间。</p>
</li>
<li><p>n2 个元素可以压缩到 n（n+1）&#x2F;2个空间中。</p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-71bd76abde0630e076018b4cc9813295_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4f64babba980661101c860292051b41b_720w.jpg"></p>
<h2 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h2><ul>
<li>以主对角线划分，三角矩阵有上三角和下三角两种。上三角矩阵它的下三角中的元素均为常数。下三角矩阵正好相反，它的主对角线上方均为常数。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-e59c370bf8167372c1a63b15dc376f7c_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-f149aa0d8def82ff2bc7a70b06ffa902_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-b51cd6229e3b75260bdf8058d1b03761_720w.jpg"></p>
<h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p><img src="https://pic4.zhimg.com/80/v2-fe2cb246b9153b00ece2b3d37e669a17_720w.jpg"></p>
<p>除了记录非零元素的值之外，还必须同时几下它所在的行和列的位置。稀疏矩阵的存储方法一般有三种：三元组法、行逻辑连接顺序表和十字链表法。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c264b3477ac072cd03fac04592f78032_720w.jpg"></p>
<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><ul>
<li>是由零个或多个原子或子表组成的优先序列，是线性表的推广。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-c15b59df68a00259090e50db09501cba_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3c0d469afa97b78429961f4b228c6339_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5f962101334171d06ecbbcea4f4c0bbb_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-348dcd05ae84ca4cb9981553605da917_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-a4f40a1d04e1b423a7560b627f8f1038_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-1fad89f6d6336f99549529e20be1d90b_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c4f0b14a987da1643a163604e31d1a63_720w.jpg"></p>
<h2 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h2><ul>
<li>广义表中的数据元素可以具有不同的结构，因此，难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个节点表示。由于广义表中有两种数据元素，因此需要有两种结构的节点——一种是表结点，一种是原子结点。</li>
<li>表结点由三个域组成：标志域、指示表头的指针的指针域和指示表尾的指针域；而原子域只需两个域：标志域和值域。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-f9dcdb97748c12b8406aa02d4dd1c221_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b05604ca687147e7596f17610ed8ade7_720w.jpg"></p>
<ul>
<li>表结点由三个域组成：标志域、指示表头的指针域和指向下一个元素的指针；原子结点的三个域为：标志域、值域和指向下一个元素的指针。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-9b820d3da70078490e68019778fd9ecf_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-46328ccca1e8cdbd19180ea3c9d13001_720w.jpg"></p>
<h1 id="五、树"><a href="#五、树" class="headerlink" title="五、树"></a>五、树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p><img src="https://pic2.zhimg.com/80/v2-89bec5d9f147e731b57c467f7c4a04ed_720w.jpg"></p>
<ul>
<li>树的逻辑表示：树形表示法、文氏图表示法、凹入表示法、括号表示法。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-569b75211a6f368156d5a4802ed9d995_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d96a77305c0f9d4f1aef885e388c5e4c_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-6b292b56c8f8ee9c02360b4a46c127cc_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-d1d20d6bdbcfd07aecce409dff520863_720w.jpg"></p>
<ul>
<li><p>结点：表示树中的元素，包括数据项及若干指向其子树的分支。</p>
</li>
<li><p>结点的度：结点拥有的子树树；树的度：一棵树中最大的结点度数</p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-bb466b5d26ee92abfb9ba9462ee82dcd_720w.jpg"></p>
<ul>
<li><p>叶子结点：度为0的结点；分支结点：度不为0的结点；孩子：结点子树的根称为该结点的孩子；双亲：孩子结点的上层结点叫该结点的双亲；兄弟：同一双亲的孩子。</p>
</li>
<li><p>深度：树中结点的最大层次数。</p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-9638df1cce39e8e667e525f67d522b39_720w.jpg"></p>
<ul>
<li>有序树：树中各结点的子树从左至右是有次序的，不能互换。否则称为无序树。</li>
</ul>
<h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ul>
<li>树中的结点数等于所有结点的度数加1。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-410f23c6c5a0d63c33341718a6b9ec87_720w.jpg"></p>
<ul>
<li>度为m的树中第i层上至多有mi-1 个结点（i&gt;&#x3D;1）。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-07fc76e90f6eba5c81e202f82720da09_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e0513e95e8551c2336e2d1b6aa203d8e_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-d722c9262e4568f8459bb1b36a4d0ccb_720w.jpg"></p>
<h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><p><img src="https://pic4.zhimg.com/80/v2-9e6b96511bba7e0bfc61c741d6df49bf_720w.jpg"></p>
<ul>
<li><p>满二叉树：定义——一棵深度为k且具有2k-1个结点的二叉树。特点——每一层上的结点数都是最大结点数。</p>
</li>
<li><p>完全二叉树：定义——深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。</p>
</li>
</ul>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><img src="https://pic3.zhimg.com/80/v2-ab880b7cd2a935d7c2bcb52fc9384462_720w.jpg"></p>
<ul>
<li>二叉树的第i层上至多有2i-1(i&gt;&#x3D;1)个结点。</li>
<li>深度为K的二叉树至多有2k-1个结点。</li>
<li>对任何一棵二叉树T，如果其叶子数为n0，度为2的结点数为n2，则n0&#x3D;n2+1。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-4fa18c09ccd8980f4fd61bc953e8a7c6_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-a12de4b3a2f7def6d5236ca36806ac2e_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e71d3acbf1eae570bd56f79a05dd4f67_720w.jpg"></p>
<ul>
<li>一个有n个结点的完全二叉树，编号最大的分支结点的编号是</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-e315fe13a160309d99f05332d5f1eae3_720w.jpg"></p>
<ul>
<li>一个有n个结点的完全二叉树，n0的个数是不小于n&#x2F;2的最小整数。</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ul>
<li>用一组连续的存储单元存储二叉树的数据元素。在存储之前对二叉树的所有结点安排一个适当的序列，使得结点在这个序列中的相互位置能反应出结点之间的逻辑关系。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-bfa6c12941657481f9a824c8ba6792d4_720w.jpg"></p>
<ul>
<li>特点：结点间关系蕴含在其存储位置中；浪费空间，适于存满二叉树和完全二叉树。</li>
</ul>
<h2 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h2><ul>
<li>用一个链表来存储一棵二叉树，二叉树中每一个结点用链表中的一个链结点来存储。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-cfd1a60b381ed63552fd1494e2801cc9_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-32826d965d82aef69b2d6b2de093e286_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-3fb7b01a361016edc19cdb4db44df68c_720w.jpg"></p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><ul>
<li>遍历方法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-45166f01b1713990693d917e164e57a7_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-158f362ebf57930bb7424b65243c6220_720w.jpg"></p>
<ul>
<li>利用遍历结果确定二叉树：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-4a30ec8edf854f6f536213fa8b856f54_720w.jpg"></p>
<ul>
<li>先序遍历算法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历递归算法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(Tree t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(t);</span><br><span class="line">    preorder(t.left());</span><br><span class="line">    preorder(t.right());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">PreOrderUnrec</span><span class="params">(Bitree t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建栈来存放树的结点</span></span><br><span class="line">    SqStack s;</span><br><span class="line">    StackInit(s);</span><br><span class="line">    p=t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">null</span> || !StackEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">null</span>)             <span class="comment">//遍历左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            visite(p-&gt;data);</span><br><span class="line">            push(s,p);</span><br><span class="line">            p=p-&gt;lchild;       </span><br><span class="line">        &#125;<span class="comment">//endwhile</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!StackEmpty(s))         <span class="comment">//通过下一次循环中的内嵌while实现右子树遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=pop(s);</span><br><span class="line">            p=p-&gt;rchild;        </span><br><span class="line">        &#125;<span class="comment">//endif</span></span><br><span class="line">                </span><br><span class="line">    &#125;<span class="comment">//endwhile </span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//PreOrderUnrec</span></span><br><span class="line">中序遍历算法：</span><br><span class="line"> </span><br><span class="line"><span class="comment">//中序遍历递归算法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Tree t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(t.left());</span><br><span class="line">    visit(t);</span><br><span class="line">    inorder(t.right());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">InOrderUnrec</span><span class="params">(Bitree t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建栈来存放树的结点</span></span><br><span class="line">    SqStack s;</span><br><span class="line">    StackInit(s);</span><br><span class="line">    p=t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">null</span> || !StackEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">null</span>)             <span class="comment">//遍历左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            push(s,p);</span><br><span class="line">            p=p-&gt;lchild;       </span><br><span class="line">        &#125;<span class="comment">//endwhile</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!StackEmpty(s))         <span class="comment">//通过下一次循环中的内嵌while实现右子树遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=pop(s);</span><br><span class="line">            visite(p-&gt;data);        <span class="comment">//访问根节点</span></span><br><span class="line">            p=p-&gt;rchild;        </span><br><span class="line">        &#125;<span class="comment">//endif</span></span><br><span class="line">                </span><br><span class="line">    &#125;<span class="comment">//endwhile </span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//InOrderUnrec</span></span><br><span class="line">后序遍历算法：</span><br><span class="line"> </span><br><span class="line">后序遍历递归算法</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Tree t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder(t.left());</span><br><span class="line">    inorder(t.right());</span><br><span class="line">    visit(t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//后序遍历非递归算法</span></span><br><span class="line">对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postOrder2</span><span class="params">(BinTree *root)</span>    <span class="comment">//非递归后序遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;BTNode*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    BTNode *temp;</span><br><span class="line">    <span class="keyword">while</span>(p!=NULL||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=NULL)              <span class="comment">//沿左子树一直往下搜索，直至出现没有左子树的结点 </span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode *btn=(BTNode *)malloc(sizeof(BTNode));</span><br><span class="line">            btn-&gt;btnode=p;</span><br><span class="line">            btn-&gt;isFirst=<span class="literal">true</span>;</span><br><span class="line">            s.push(btn);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            temp=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;isFirst==<span class="literal">true</span>)     <span class="comment">//表示是第一次出现在栈顶 </span></span><br><span class="line">             &#123;</span><br><span class="line">                temp-&gt;isFirst=<span class="literal">false</span>;</span><br><span class="line">                s.push(temp);</span><br><span class="line">                p=temp-&gt;btnode-&gt;rchild;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//第二次出现在栈顶 </span></span><br><span class="line">             &#123;</span><br><span class="line">                cout&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                p=NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ul>
<li>利用二叉链表的空指针域，建立指向该结点的前驱&#x2F;后继结点的指针，方便二叉树的线性化使用。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-fcafd439a830245230ba507e8fdb6f84_720w.jpg"></p>
<ul>
<li>对二叉链表以某种次序遍历使其变为线索二叉树的过程叫做线索化。有先序线索二叉树、中序线索二叉树（更实用）和后序线索二叉树三种。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-f7ca6a3bec6440be4810a3ca910b8866_720w.jpg"></p>
<ul>
<li>建立中序线索二叉树</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-364b6bca5c21b940bbe181fd3e884665_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c201b5978b9e75da1a63f316df0f1bf9_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-cffbafc4b8aca7338f8bb4c287ffef12_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-5c722411aa1dc1546c8d38f845cf70f9_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-dd2c3b5a25db448f7e14c7c838117caa_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d093d7e95f9363e3a0b5d8ee4ed66218_720w.jpg"></p>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><ul>
<li>双亲表示法：用一组连续空间存储树的结点，每个节点包含两个域——数据域用来存放结点本身信息，双亲域用来指示本结点的双亲结点在数组中位置。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-acebcee1f04847bf2cddcfca3ca8472c_720w.jpg"></p>
<p>孩子表示法：采用孩子链表，每个结点的孩子结点用单链表存储，再用含n个元素的结构数组指向每个孩子链表。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7e054cf57b7ad311a6a62ae651c361d7_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-73b3b4886c0b3c16bea791a35933da7f_720w.jpg"></p>
<ul>
<li>孩子兄弟表示法：用二叉链表作为树的存储结构。链表中结点的两个链域分为指向该结点的第一个孩子结点和下一个兄弟结点。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-cbfd61a20d4388e0aa0d0c85ae492303_720w.jpg"></p>
<h2 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h2><ul>
<li>将树转换为二叉树</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-89896a608bc97dd7b02959a95479239a_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4a40b13ded1ab09561aa3194cdf62d56_720w.jpg"></p>
<ul>
<li>将二叉树转换为树：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-75335b40b49c565d443fd0f254dcd997_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7340f665e2a76030dac5f069441768f9_720w.jpg"></p>
<ul>
<li>森林转换成二叉树：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-2d902b482c9bfc3c4023f93975f55c35_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-7b7e6f9284420f7179c0499210a168f4_720w.jpg"></p>
<ul>
<li>二叉树转换成森林</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-89b579149293c7614d1efb2a23b875d2_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b5c8c9056fd9e649c35ccc8ffffa9293_720w.jpg"></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><ul>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根节点到该结点之间的路径长度与该结点的权的乘积。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-39a2fe8f528da3d30d8bfe1b3416fcb1_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-cdb70ddaa4bd9adabe55b66918a6576e_720w.jpg"></p>
<ul>
<li>在一棵二叉树中，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称哈夫曼树。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-1384c855eb90ba3b2a075a088484a777_720w.jpg"></p>
<h1 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h1><h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><ul>
<li>图是一种较线性表和树更为复杂的数据结构，在图形结构中，结点之间关系可以是任意的，图中任意两个数据元素之间都可能相关。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-565af1c82a37bbcaa40662de517e02a6_720w.jpg"></p>
<ul>
<li>有向图和无向图</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-b0fc1e3af056ad05d821c849fcf0c933_720w.jpg"></p>
<ul>
<li>若无向图中的每两个顶点之间都存在着一条边，则称该无向图称作完全无向图；显然完全无向图中包含着e&#x3D;n(n-1)&#x2F;2条边。若有无向图中的每两个顶点之间都存在方向相反的两条边，则称该有向图称作完全有向图；显然完全有向图中包含有e&#x3D;n(n-1)条边。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ebc008a72d0346aa30c53d17521261fe_720w.jpg"></p>
<ul>
<li>与图的边或弧相关的数叫做权，带权的图称为网。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-da05e5b91fcbdee274a80f260a1bffd9_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-932a6ee9d7e226a147fbd162fbb3171b_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-ff9820661a85440a7090d1d963ba4a64_720w.jpg"></p>
<ul>
<li>对于有向图而言，度又分为出度和入度。顶点的出度——以顶点v为弧尾的弧的数目；顶点的入度——以顶点v为弧头的弧的数目；顶点的度为该顶点的出度和入度的和。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-f1f37e5823ded1ab82797683fc57929f_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e0721ff4266b55f007c4dcf45c9ad5c2_720w.jpg">* 在无向图G中，如果从顶点v到顶点w存在路径，则称v到w是连通的。若图G中任意两个顶点之间都有路径相通，则称为连通图。</p>
<ul>
<li>若无向图为非连通图，则图中各个极大连通子图称作此图的连通分量。任何连通图的连通分量只有一个，即本身，而非连通图则有多个连通分量。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b6004ac08f1ea0edb36e74eeddc9a004_720w.jpg"></p>
<ul>
<li><p>在有向图中，若任意两个顶点之间都存在一条有向路径，则称此有向图为强连通图。</p>
</li>
<li><p>若有向图为非强连通图，其各个强连通子图称为它的强连通分量。</p>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-898b62b1e07d4cbf7d62d35b407f726a_720w.jpg"></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ul>
<li>邻接矩阵是表示顶点之间相邻关系的矩阵。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-c2b9e203ed113106d9a72d58f13ff0d6_720w.jpg"></p>
<ul>
<li>无向图的邻接矩阵：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-5d251e1f73050127ca348344c439d340_720w.jpg"></p>
<ul>
<li>有向图的邻接矩阵：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-9802eb430abc1345021b4f56a7c6a639_720w.jpg"></p>
<ul>
<li>网的邻接矩阵：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-26beb2744798de6279592111d840ff20_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-1eded28a6c9d6129be6f5a84a89bb5b6_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3d9723493cb92b1dceea6fd8d4c6f47f_720w.jpg"></p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul>
<li>邻接表存储方法是一种顺序分配与链式分配相结合的存储方法。它包括两部分：一部分是单链表，用来存放边的信息；另一部分是数组，主要用来存放顶点本身的数据信息。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-5e2c2aebe0deb21f83dcd9f0a62498af_720w.jpg"></p>
<ul>
<li>无向图邻接表：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b754f200e69ca0e72db6c1a0b676d5b2_720w.jpg"></p>
<ul>
<li>有向图的邻接表：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-e7353bb409a39f36f35412576ed8579d_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-318825cc62d124831c26685ed3ca8933_720w.jpg"></p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><ul>
<li>十字链表是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，每条弧和每个顶点分别对应着一个结点。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-19dac4222b10899605f87c57917c2357_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-20eb2071edd11a3a5fb6c7a331c8f0db_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-182212d4ddd5eba45b9abf1553f8eeff_720w.jpg"></p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><ul>
<li>邻接多重表是无向图的另一种链式存储结构。邻接多重表和十字链表一样，每条边和每个顶点分别对应着一个结点。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-73eed0b789590d6c650f0f9be3beb0fb_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-248cfa705e298ded89418718a9846add_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-e6e4bfead2aeb45a7b232c977beed62d_720w.jpg"></p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul>
<li>从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程</li>
<li>根据搜索方法的不同，图的遍历有两种：深度优先搜索（DFS）和广度优先搜索（WFS）。</li>
</ul>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p><img src="https://pic2.zhimg.com/80/v2-7a3d824439a5b9164db941d2c94d4aa5_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b4eaa724705ddb6c39c163dea5771c73_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-b96933846f2342a41c05d76dcd964a74_720w.jpg"></p>
<ul>
<li>连通图深度优先搜索的算法：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-0424337ad0155df6d7cb3b16fa5f9811_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-7cec0693ed949aa5db677cb18a897d54_720w.jpg"></p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p><img src="https://pic1.zhimg.com/80/v2-88436415aa05c7666ca7e24b68b7e884_720w.jpg"></p>
<ul>
<li>广度优先搜索是一种分层的搜索过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况。因此，广度优先搜索不是一个递归的过程，其算法也不是递归的。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5c38f41c4b6525a3f7725fb7aab52e6e_720w.jpg"></p>
<ul>
<li>连通图的广度优先搜索算法：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-6b34a36b55c380c6307b9c7ccc674632_720w.jpg"></p>
<ul>
<li>非连通图广度优先搜索：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-38042047c903f7718522e1320a7f0924_720w.jpg"></p>
<h2 id="无向图的连通分量和生成树"><a href="#无向图的连通分量和生成树" class="headerlink" title="无向图的连通分量和生成树"></a>无向图的连通分量和生成树</h2><ul>
<li>连通图生成树：一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有构成一棵树的n-1条边。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-18a2e968aaa112328e30444c5a5df14c_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4d0a225ec9d1287d9268b51da2a3e6da_720w.jpg"></p>
<ul>
<li>当无向图为非连通图时，从图中某一顶点除法，利用深度优先搜索算法或广度优先搜索算法不可能遍历到图中的所有顶点，只能访问到该顶点所在的极大连通子图的所有顶点，该极大连通子图称为无向图的一个连通分量。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-9a1669c14a23cfa1a3b323db06d2e684_720w.jpg"></p>
<ul>
<li>使用不同的遍历图的方法，可以得到不同的生成树；从不同的顶点出发，也可能得到不同的生成树。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-0c91562b56802740bc0eec16e90036eb_720w.jpg"></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul>
<li>在连通网的众多生成树中，各边权值之和最小的生成树称为最小代价生成树，简称最小生成树。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-4b061381e87d81efcbd6730409ad78ab_720w.jpg"></p>
<ul>
<li>生成最小生成树算法——普里姆算法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-2bf34f44fdcaa606edb4cddc6a9efc3b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-cdbd914cf05baf30d749cd3399acf652_720w.jpg"></p>
<ul>
<li>生成最小生成树算法——克鲁斯卡尔算法：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-6eec2a13a886e486f09cd8be59fc5b7e_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-50f69c3dd2e4af536d50dc7f51f19b00_720w.jpg"></p>
<h2 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h2><ul>
<li>一个无环的有向图称为有向无环图，简称DAG图。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-8a71f949bfc3b5ef659d25e4bc16be24_720w.jpg"></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li>在一个有向图中，若用顶点表示活动，有向边表示活动间的先后关系，称该有向图叫做顶点表示活动的网络，简称AOV网。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-cd6130fb4f03a2e589c39aaa9f9dc0aa_720w.jpg"></p>
<ul>
<li><p>按照有向图给出的次序关系，将图中顶点排成一个线性序列，对于有向图中没有限定次序关系的顶点，则可以人为加上任意的次序关系。由此所得顶点的线性序列成为拓扑有序序列。</p>
</li>
<li><p>拓扑排序：由某个集合上的一个偏序（集合中仅有部分成员之间可以比较）得到该集合上的一个全序（集合中全体成员之间均可以比较）的操作称为拓扑排序。</p>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-525d63865679b0c5597796af8db00daa_720w.jpg"></p>
<ul>
<li>拓扑排序的算法：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-66b1ee571f72e29926f7ac81f1d7a455_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-31a03c499e8a4c6ff5918e12a8427c3f_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-850375302f240f94b51b1f37e34df9f0_720w.jpg"></p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><ul>
<li>在一个有向图中，若用顶点表示事件，弧表示活动，权表示活动持续时间，称该有向图叫做边表示活动的网络，简称为AOE网。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-01a5370b8a97ad3f8481faa20e8ab563_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-6ea23892923da7aa515a7baf97d53f7c_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-a0647ebd6e070673cab51c21dc44326f_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-6266d16a2656e49c1c72ed5fa6e058b0_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-127eb9aee4af3ca40a3c5be03fb212f6_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-243c37778e45c7f36be9035920f9df7e_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-47b174e43604a738cdda6258014f3fe3_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4620b8bb7033cf4c7ebe0b4628b8a6aa_720w.jpg"></p>
<h1 id="七、查找"><a href="#七、查找" class="headerlink" title="七、查找"></a>七、查找</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>查找表：由同一类型的数据元素（或记录）构成的集合。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-5013242dc8e11050f2be919f7874736b_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3ebc90e3e5e1bc31f3a8e68accf1ea1b_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2f68f42770246a61568b989816e537ac_720w.jpg"></p>
<h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><ul>
<li>静态查找是指在静态查找表上进行的查找操作，在查找表中满足条件的数据元素的存储位置或各种属性。静态查找表的查找算法主要有：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-aa0bcf0127a3f2e2eea1fe6377beb2ff_720w.jpg"></p>
<ul>
<li>顺序查找：从表的一端开始，顺序扫描线性表，依次将扫描到的关键字和给定值k进行比较，若当前扫描到的关键字与k相等，则查找成功；若扫描结束后，仍未找到关键字等于k的记录，则查找失败。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-f3562b387ec14edacad070169cbd19f6_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-605946f8172abf5f0316c61a8d08cc29_720w.jpg"></p>
<ul>
<li>折半查找：对给定值k，逐步确定待查记录所在区间，每次将搜索空间减少一半，直到查找成功或失败为止。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-0ff6d379e1a9feff5fd5bc098a92efb4_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-017252d075231658722611b56bdb637e_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-59f31f72bd266c751597d049ee8e3d2c_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-f8b2120971d4a03c3eb77999bfa9b28e_720w.jpg"></p>
<ul>
<li>分块查找：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-273be6dd3c7a73cd7df161e6c6f2b841_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-b92284c31c7351bec4f37c6564c749ed_720w.jpg"></p>
<h2 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h2><p>表结构在查找过程中动态生成的这样一种查找表。实现动态查找方法：二叉排序树、平衡二叉树、B-树和B+树。</p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><ul>
<li>定义：左子树的所有结点均小于根的值；右子树的所有节点均大于根的值；它的左右子树也分别为二叉排序树。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-a6d5b7a19af79289526863e43fd866ba_720w.jpg"></p>
<ul>
<li>二叉排序树插入新结点的过程</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-a5abd9717b616c92429099a8d5097415_720w.jpg"></p>
<ul>
<li>二叉排序树插入新节点递归算法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-736f8cb98694a799a74267bd20a89d8b_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-b9d04df7464bb91f79ab7a5c947925ec_720w.jpg"></p>
<ul>
<li>二叉排序树删除结点的算法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-4a109e794500190e850213e0cf027d3c_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b57fd4d106a395adb1ba029b45246ef7_720w.jpg"></p>
<ul>
<li>二叉排序树查找算法分析：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-b0b6d3905367135fb1584c224ed3e6df_720w.jpg"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li>平衡二叉树又称为AVL树，设二叉树中结点的左子树和右子树的深度分别为HL和HR。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-d830a17f2e7ac11ae59c5c0c2aeb1475_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-54c172d59fce29ce724eefcfa89d6640_720w.jpg"></p>
<ul>
<li>若在构造二叉排序树的同时，使其始终保持为AVL树，则此时的二叉排序树为平衡的二叉排序树。将一棵非平衡二叉排序树调整成平衡二叉排序树的“旋转”，分为：LL平衡旋转、RR平衡旋转、LR平衡旋转、RL平衡旋转。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-354bd6d15c2c0f7a2aa4c8192b529473_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-33fbb89147607aaef6a5d9046f72ad3f_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-bd4baba2f92ed0906f66ce8a20c8dd23_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-f5af39fc4823ef6e9caab7b2f060b801_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-49f71ff12f2fee38ff7e658e0bf262de_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-93ffc448eaa12f18d548cecc4ad1d160_720w.jpg"></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><ul>
<li>B-树又称基本B树或多路平衡查找树。它是构造大型文件系统索引结构的一种数据结构类型，适合在磁盘等直接存取设备上组织动态的查找表。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5cebe8c793a33d433af155d0be6cb0fe_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4ac66d90825dce34f91a7abdee6de351_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-23ffe0d1734ca0757cbd7b699a1a4c9b_720w.jpg"></p>
<ul>
<li><p>该公式包括没有任何关键字的叶子结点。</p>
</li>
<li><p>B-树的查找算法思路：</p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-79e651a533ce3cdc9afcdfa248bda53d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-05a6c89908dd5b56218967579db8ca4e_720w.jpg"></p>
<ul>
<li>B-树的查找效率取决于以下两个因素：包含k的结点在B-树种所在的层数h；结点中ki的个数n。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-93bd74dd2039ae10e0adb770e01122f9_720w.jpg"></p>
<ul>
<li>B-树的生成：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-77f79022377831b77c2e739202a70c4b_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-d17db867beea2b1c52595e23bd9d7f9b_720w.jpg"></p>
<ul>
<li>B-树的删除：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-96dfbc2e25e6572337bd198b147fd64a_720w.jpg"></p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><ul>
<li>B+树是B-树的变形，目的在于有效地组织文件的索引结构。</li>
<li>m阶B+树与B-树的差异：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-9f3ec5ae8c5567e61e2a38ff87ddfbc4_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4b49658a480bc793e48734c455322ca3_720w.jpg"></p>
<ul>
<li>B+树种可以有两种查找方式：顺序查找——类似单链表的查找，直接在数据层进行查找。随机查找——类似B-树的查找，不同的是搜索到索引层的key与k相等时，还得继续搜索下去，直到数据层为止。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-b8de974aa1a5ab2c9f70eabbb2e88a9f_720w.jpg"></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><img src="https://pic2.zhimg.com/80/v2-b557271cd97f55ade3b94f6af1ac52e1_720w.jpg"></p>
<ul>
<li>哈希表，根据设定的哈希函数H（key）和处理冲突的方法将一组关键字key映射到一个有限的连续的地址集上，并以关键字key在地址集中的“像”作为记录在表中的存储位置，这种表便称为哈希表，这一映射过程称为哈希造表或散列，所得存储位置称哈希地址或散列地址。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-8369d17082aacc39eaab5abe873b3284_720w.jpg"></p>
<ul>
<li>将不同的关键码映射到同一个哈希地址上，该现象称为冲突。</li>
</ul>
<h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><ul>
<li>常用的哈希函数构造方法有：直接定址法、除留余数法、乘余取整法、数字分析法、平方取中法、折叠法、随机数法。</li>
<li>直接定址法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-e4849575ddc414257c6e2ed5de9999c0_720w.jpg"></p>
<ul>
<li>除留余数法：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b9bfda64c1cba23987db18f0d4dd0ab6_720w.jpg"></p>
<ul>
<li>乘余取整法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-3b370c6ed7f560a2163865105f7440ab_720w.jpg"></p>
<ul>
<li>数字分析法：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b28f2a643fe27cd5f6c77421d9a724a2_720w.jpg"></p>
<ul>
<li>平方取中法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-e0faddffc63c09bf33ed6a712fb1be40_720w.jpg"></p>
<ul>
<li>叠加法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-e032b99429b09ac21f35451a079cc743_720w.jpg"></p>
<ul>
<li>随机数法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-31e65a286021ef6205abe5e23bfc7def_720w.jpg"></p>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul>
<li>开放定址法、链地址法、再哈希法、建立一个公共溢出区</li>
<li>开放定址法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-9ade5187387faf0316ecc24e51c855e8_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a9d11d804119df752210ab361d2879b9_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-3c12e90f6a5c0d92ab1bad6ed3a8d8ea_720w.jpg"></p>
<ul>
<li>链地址法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-e34a587ca376a080cc2e06b0aa586934_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-bfa2b7bc5b9b1fc5381bf9d076881f83_720w.jpg"></p>
<ul>
<li>再哈希法：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b7fb1a7f720688cd40d4c1e0ad4dbc58_720w.jpg"></p>
<ul>
<li>建立一个公共溢出区：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-77ff4f5f8a96ef92f45f330ef108911c_720w.jpg"></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul>
<li>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-9e8eadb29de8691c0ced2da8c32181b0_720w.jpg"></p>
<ul>
<li><p>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。</p>
</li>
<li><p>红黑树的五个性质保证了红黑树的高度始终保持在logn:</p>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-59790a5fcd0fa63fceb65d9e41a10709_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-9892e93ca4883953a567dfc486b08837_720w.jpg"></p>
<ul>
<li>红黑树的旋转操作：红黑树的旋转操作和AVL树一样，分为LL、RR、LR、RL四种旋转类型，差别在于旋转完成后改变的是结点的颜色，而不是平衡因子。</li>
</ul>
<h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><h2 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h2><ul>
<li>排序的分类：内部排序和外部排序（若待排序记录都在内存中，称为内部排序；若待排序记录一部分在内存，一部分在外存，则称为外部排序）。稳定排序和不稳定排序。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b4c3c797a5620f6bf4252bddbfde2f7a_720w.jpg"></p>
<ul>
<li>内部排序的算法：插入排序（希尔排序）、交换排序（快速排序）、选择排序（堆排序）、归并排序、基数排序。</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>思想：每次将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。</li>
<li>具体实现算法：直接插入排序、折半插入排序、希尔排序</li>
<li>直接插入排序：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b14adba88ca336e7d4be471397ef0ac0_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-1426061199f769f10abc4af3bed1f491_720w.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">//按照有小到大的顺序排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        <span class="comment">//找到无序表的第一个位置</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i-<span class="number">1</span>])&#123;</span><br><span class="line">            a[<span class="number">0</span>]=a[i];</span><br><span class="line">            <span class="comment">//将无序表依次向后移动</span></span><br><span class="line">            <span class="keyword">for</span>(j=i-<span class="number">1</span>;a[<span class="number">0</span>]&lt;a[j];j--)&#123;</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将数据插入相应位置</span></span><br><span class="line">            a[j+<span class="number">1</span>]=a[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">该算法的时间复杂度是：O（n2）</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-d78f8d022380eecc943016d4e4850427_720w.jpg"></p>
<ul>
<li>折半插入排序：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-a2e0ff965b4adfbfed32ff9e62759701_720w.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">BInsertSort</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,high,low;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        a[<span class="number">0</span>]=a[i];      </span><br><span class="line">        low=<span class="number">1</span>;</span><br><span class="line">        high=i-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;       <span class="comment">//使用折半查找到插入的位置</span></span><br><span class="line">            min=(high+low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]&lt;a[min])</span><br><span class="line">                high=min-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low=min+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>;j=&gt;high+<span class="number">1</span>;j++)    <span class="comment">//插入的位置是在high位置之后</span></span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        a[high+<span class="number">1</span>]=a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-361e5056a41c19a0da3d7afa800d7c75_720w.jpg"></p>
<ul>
<li>希尔排序：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-3b3ba87f91a665fffa2423ea5ca45303_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-c5ece32bbccab146d279eb22bba26054_720w.jpg"></p>
<p>从排序过程可以看出，希尔排序的一个特点是：子序列的构成不是简单地“逐段分割”，而是将相隔某个“增量”的记录组成一个子序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">SheelSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> dx)</span>&#123;</span><br><span class="line">    <span class="comment">//这是对直接插入排序的修改</span></span><br><span class="line">    <span class="comment">//dx表示增量</span></span><br><span class="line">    <span class="comment">//当j&lt;=0时，插入位置已经找到</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=dx+<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i-dx])&#123;</span><br><span class="line">            a[<span class="number">0</span>]=a[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-dx;j&gt;<span class="number">0</span>&amp;&amp;a[<span class="number">0</span>]&lt;a[j];j-=dx)</span><br><span class="line">                a[j+dx]=a[j];</span><br><span class="line">            a[j+dx]=a[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-7f770d2907e439b42042ed88c6eea845_720w.jpg"></p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><ul>
<li>两两比较待排序记录的关键码，如果发生逆序（即排列顺序与排序后次序正好相反），则交换之，直到所有记录都排好序为止。</li>
<li>冒泡排序：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;a.length-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                a[<span class="number">0</span>]=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-e645b040765473726c0029532f618f98_720w.jpg"></p>
<ul>
<li>快速排序：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-02186906d89113f54b161b168a54aac5_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-304e1efdafd4bf06b267ff2c008f781c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ede0338c77f80a24db92a5fee83e39e5_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ee9abac705d8a769c3daa6b4fbe87781_720w.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="comment">//这只是一趟快速排序的算法</span></span><br><span class="line">    a[<span class="number">0</span>]=a[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="comment">//从高位往低位扫描，找到数值小于关键字的位置，与low位置交换</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[<span class="number">0</span>]&lt;=a[high])</span><br><span class="line">            high--;</span><br><span class="line">        a[low]=a[high];</span><br><span class="line">        <span class="comment">//从低位往高位扫描，找到数值大于关键字的位置，与high位置交换</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&lt;=a[<span class="number">0</span>])</span><br><span class="line">            low++;</span><br><span class="line">        a[high]=a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后将关键字放入数组中</span></span><br><span class="line">    a[low]=a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">快速排序平均时间复杂度和最好时间复杂度为：O（log2n），最坏时间复杂度为O（n2）。</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-1578fa8ac4f337eac48c9883649093fd_720w.jpg"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>不断从待排记录序列中选出关键字最小的记录插入已排序记录序列的后面，直到n个记录全部插入已排序记录序列中。</li>
<li>简单选择排序：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-49cd7755e2f7992df69daa038b31f6aa_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d23e0d60b74208d22092e7f610a8e6e5_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ff9293caaf5eddd04bf3e2e88e462323_720w.jpg"></p>
<ul>
<li>堆排序：借助于完全二叉树结构进行的排序，是一种树形选择排序。其特点是——在排序过程中，将R[1…N]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树双亲结点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（或最小）的记录。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-ceb600ce9bd9be42de54038ae88f0369_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-03cc9fa82a7a609408aca212b895d437_720w.jpg"></p>
<p>堆的根节点是堆中元素值最小（或最大）的结点，称为堆顶顶点；从根节点到每个叶节点的路径上，元素的排序序列都是递减（或递增）有序的。</p>
<p><img src="https://pic2.zhimg.com/80/v2-8198936de84625935098c00fd83c1dfd_720w.jpg"></p>
<ul>
<li>建立一个堆排序的方法：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-9350310b1fe1cbed41527691382e2eeb_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6ab565bc998aee8724f9ea9a931328cd_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-55622d1fbdd1d216d97c5cddf7493ab6_720w.jpg"></p>
<ul>
<li>堆排序的过程：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-48e22c84194642bfc5cc73b19bd172f7_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-228934afb8c6e511693db0605de4d801_720w.jpg"></p>
<ul>
<li>堆排序算法实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">HeapAdjust</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> i,<span class="type">int</span> size)</span>  <span class="comment">//调整堆 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lchild=<span class="number">2</span>*i;       <span class="comment">//i的左孩子节点序号 </span></span><br><span class="line">    <span class="type">int</span> rchild=<span class="number">2</span>*i+<span class="number">1</span>;     <span class="comment">//i的右孩子节点序号 </span></span><br><span class="line">    <span class="type">int</span> max=i;            <span class="comment">//临时变量 </span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=size/<span class="number">2</span>)          <span class="comment">//如果i不是叶节点就不用进行调整 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lchild&lt;=size&amp;&amp;a[lchild]&gt;a[max])</span><br><span class="line">        &#123;</span><br><span class="line">            max=lchild;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(rchild&lt;=size&amp;&amp;a[rchild]&gt;a[max])</span><br><span class="line">        &#123;</span><br><span class="line">            max=rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(a[i],a[max]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BuildHeap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> size)</span>    <span class="comment">//建立堆 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=size/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)    <span class="comment">//非叶节点最大序号值为size/2 </span></span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(a,i,size);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line">​</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> size)</span>    <span class="comment">//堆排序 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BuildHeap(a,size);</span><br><span class="line">    <span class="keyword">for</span>(i=size;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;a[1]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        swap(a[<span class="number">1</span>],a[i]);           <span class="comment">//交换堆顶和最后一个元素，即每次将剩余元素中的最大者放到最后面 </span></span><br><span class="line">          <span class="comment">//BuildHeap(a,i-1);        //将余下元素重新建立为大顶堆 </span></span><br><span class="line">          HeapAdjust(a,<span class="number">1</span>,i-<span class="number">1</span>);      <span class="comment">//重新调整堆顶节点成为大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-85bc9fc4e1f02fbc674483db81c1d2c4_720w.jpg"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>“归并”的含义是将两个或两个以上的有序表合并成一个新的有序表。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-22f3d130bbaf0652c8636de5ecb7771b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-0be6a77668831c3fc077356c8288664d_720w.jpg"></p>
<ul>
<li>两个有序表的合并算法Merge()：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-a77545b2cdf5f7ceff3326c6840f4a9b_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-231b3b8253a854fc1f18a8c5cbb23f88_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-96b835f3e775a56923bf25d380fa18c7_720w.jpg"></p>
<ul>
<li>算法分析：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-2f231ae2ab9467a488c0268c5541f5bc_720w.jpg"></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul>
<li>基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法，即先将关键字分解成若干部分，然后通过对各部分关键字的分别排序，最终完成对全部记录的排序。</li>
<li>多关键字的排序：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-d206b6a46d55e5ef79a45d0cf2cb0abf_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-2232659ce12832f66b2f2b0a65fcda1e_720w.jpg"></p>
<ul>
<li>链式基数排序：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-e63548dcc8884b1a9e96563f8e01a06b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-1c55566b808ba87a7b4985cf85b932d9_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-1033d236087ef5c066b0c7aa8e68fa1f_720w.jpg"></p>
<h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><p><img src="https://pic2.zhimg.com/80/v2-e42a01c7457ce1c1d0811434b369a6c5_720w.jpg"></p>
<hr>
<p><a href="https://zhuanlan.zhihu.com/p/356047870">原文链接</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>随机图片 API 收集</title>
    <url>/posts/f76953bc.html</url>
    <content><![CDATA[<h2 id="随机壁纸"><a href="#随机壁纸" class="headerlink" title="随机壁纸"></a>随机壁纸</h2><p>网址：<a href="https://api.btstu.cn/doc/sjbz.php">https://api.btstu.cn/doc/sjbz.php</a></p>
<span id="more"></span>


<p><strong>请求方式：</strong> GET</p>
<p><strong>请求地址：</strong> <a href="https://api.btstu.cn/sjbz/api.php">https://api.btstu.cn/sjbz/api.php</a></p>
<p><strong>返回格式：</strong> json&#x2F;images</p>
<p><strong>请求示例：</strong> <a href="https://api.btstu.cn/sjbz/api.php?lx=dongman&format=images">https://api.btstu.cn/sjbz/api.php?lx=dongman&amp;format=images</a></p>
<p>请求参数：</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>必填</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>method</td>
<td>否</td>
<td>string</td>
<td>输出壁纸端[mobile</td>
</tr>
<tr>
<td></td>
<td>lx</td>
<td>否</td>
<td>string</td>
<td>选择输出分类[meizi</td>
</tr>
<tr>
<td></td>
<td>format</td>
<td>否</td>
<td>string</td>
<td>输出壁纸格式[json</td>
</tr>
</tbody></table>
<p>返回参数：</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>code</td>
<td>string</td>
<td>返回的状态码</td>
</tr>
<tr>
<td></td>
<td>imgurl</td>
<td>string</td>
<td>返回图片地址</td>
</tr>
<tr>
<td></td>
<td>width</td>
<td>string</td>
<td>返回图片宽度</td>
</tr>
<tr>
<td></td>
<td>height</td>
<td>string</td>
<td>返回图片高度</td>
</tr>
</tbody></table>
<p>返回示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;imgurl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https:\/\/tva4.sinaimg.cn\/large\/9bd9b167gy1g2qkr95hylj21hc0u01kx.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1920&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1080&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="随机二次元图片API-樱花"><a href="#随机二次元图片API-樱花" class="headerlink" title="随机二次元图片API-樱花"></a>随机二次元图片API-樱花</h2><p>网址：<a href="https://www.dmoe.cc/">https://www.dmoe.cc/</a></p>
<p>图片均为https，采用新浪图片，高速访问</p>
<p>API基本调用格式：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">https://www.dmoe.cc/random.php</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>=json</span><br></pre></td></tr></table></figure>

<p>JSON调用格式</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">https://www.dmoe.cc/random.php?<span class="keyword">return</span>=json</span><br></pre></td></tr></table></figure>

<p>JSON数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span> #图片状态码</span><br><span class="line">    <span class="attr">&quot;acgurl&quot;</span><span class="punctuation">:</span><span class="string">&quot;https:\/\/ws1.sinaimg.cn\/large\/0072Vf1pgy1foxkfy08umj31kw0w0nng.jpg&quot;</span> #图片地址</span><br><span class="line">    <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span><span class="string">&quot;2048&quot;</span> #图片宽</span><br><span class="line">    <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span><span class="string">&quot;1152&quot;</span> #图片高</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>（转载）某618大促项目的复盘总结</title>
    <url>/posts/ebb8d151.html</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>618期间上线一个活动项目。但上线不顺利，当天就出现了性能问题，接口超时，用户无法打开网页，最后不得的临时下线。花了三天两夜，重构了后台核心代码，才让活动进行下去。</p>
<span id="more"></span>


<p>回头看了一下自己的时间记录，从5月31号那天晚上8点25分开始准备上线，发现异常，分析原因，重构代码，离开公司时已经是6月2号的23点54，经历51小时29分，中间的睡眠时间不到5个小时，这已经是爆发小宇宙了。</p>
<p>这一波刚过去了，一波未平另一波又起，由于活动的奖励丰厚，大批羊毛党闻风而至，某宝上公开卖脚本的都有了，严重影响了正常用户薅羊毛。</p>
<p>某客户反馈说：<strong>我们别说薅羊毛了，现在是整头羊都被他们牵走了！</strong></p>
<p>接下来的几天，又得和薅羊毛的脚本们斗智斗勇，直到活动结束。</p>
<p>而本文就对此做一次深度的复盘，在以后的项目中让自己快活一点。</p>
<h1 id="二、一份看似完美的项目总结"><a href="#二、一份看似完美的项目总结" class="headerlink" title="二、一份看似完美的项目总结"></a>二、一份看似完美的项目总结</h1><p>当我们复盘项目过程时，能找到很多问题点，比如：</p>
<ol>
<li>人力不足，需求过于复杂，开发和测试工作量大。</li>
<li>前后端开发、测试都是从其他团队抽掉的，对当前项目的业务和技术不熟悉。</li>
<li>跨团队组建的临时团队，职责定义不清晰，项目管控不严格。</li>
<li>开发对项目的用到的技术不熟悉，没有经过原有项目成员的CodeReview。</li>
<li>测试通过太草率，压测方案设计不合理。</li>
</ol>
<p>….</p>
<p>列出问题后，很快就能一一写出改进点。</p>
<ol>
<li>从公司层面加强的整体项目安排，避免重复玩法的项目，资源投入到重点的几个活动中。</li>
<li>加强团队的能力培养，总结文档，供新人学习。</li>
<li>对于核心代码进行CodeReview，遇到问题时，项目经理协调资深开发协助解决。</li>
<li>将临时组建团队职责定义清晰，各负责人沟通清楚。</li>
<li>严格控制测试质量，测试有上线的否决权。</li>
</ol>
<p>…</p>
<p>这些总结看起来一点问题没有，列出了问题，也列出了改进点，甚至可以当成样板去使用了，是不是咱们就这么结束了呢。</p>
<p>当然不是， 它本身的说法没有错，错在<strong>把问题的前提当作问题的原因。</strong></p>
<p>我们来看两种表述。</p>
<ol>
<li>下次我们要组建一个经验丰富的项目团队，避免质量问题发生。</li>
<li>当下次我们面临一个临时组建，经验不足的项目团队时，如何避免质量问题发生。</li>
</ol>
<p>这两种表述的差异在哪？</p>
<p>前一种表述是因为我们“团队”的原因，导致了本次质量问题，所以我们要解决“团队”的问题。</p>
<p>而后一种是我们的团队就是临时组建的，我们的开发、测试就是对新项目的业务和技术不熟悉，在这个前提下，才会出现质量问题，那么在这个前提下，怎么避免质量问题呢？</p>
<p>临时组建，经验不足不是问题的<strong>原因</strong>，它们是出现问题的<strong>前提</strong>，这是客观存在的。</p>
<p>这就好比我们说解决一个问题时，最快的方式是，<strong>我们不解决问题，解决出问题的人就行了。</strong></p>
<p>在这里不就变成了，<strong>我们不解决问题，解决出问题的团队就行了。</strong></p>
<p>正是因为这个误区，我们很多时候一出现项目质量问题，就把锅甩给我们团队的协作有问题，或者我们的项目时间紧张，然后一句下次改进就结束了。</p>
<p>这样的万能回答，看似一点没错，但往往就没法落地了。</p>
<p>明明项目时间紧，新团队协作经验不足本来就客观的存在，没有它就没有问题，怎么可以当作问题本身给解决掉呢。</p>
<h2 id="1、质量问题的关键原因"><a href="#1、质量问题的关键原因" class="headerlink" title="1、质量问题的关键原因"></a>1、质量问题的关键原因</h2><p>带着这个前提，我们再回头看前面的总结，其实就能过滤出真正有价值的点了。</p>
<p>我们也可以这么问，问题是不能避免的，但为什么在项目过程中我们的性能问题没有暴露出来？</p>
<p>三个角度：</p>
<ol>
<li>从项目角度，没有严格按项目流程来，特别是最后测试任务紧张，bug较多时，赶工给出了测试报告。</li>
<li>从开发角度，没有找熟悉业务和技术的同学做CodeReview。</li>
<li>从测试角度，压测方案设计不合理，不符合真实场景。</li>
</ol>
<p>逐一分析下。</p>
<p>前面提到事故是后台的性能问题，从项目角度，就算流程严谨也没法暴露出性能问题，特别是在项目过程中，已暴露的风险是前端人力不足，中间加了人手，从功能的角度，后端进度完全正常。</p>
<p>再看开发角度，这里我没有提开发的经验不足，不是在推脱责任，这同我们作为一个临时团队对业务的经验不足一样，它是一个客观存在的前提。当你接触新项目，使用新技术时，经验不足是肯定存在的。</p>
<p><strong>问题是在自身经验不足时，如何去完成任务</strong>，那么和熟悉业务和技术的同学做CodeReview是主要的手段。</p>
<p>再从测试角度，功能测试是没有问题的，但跟性能相关的压测方案是有问题的，并且一开始就没有引起正视。最开始的压测方案是开发只出接口和参数文档，直接丢给测试去压，现在看来，这是错误的。</p>
<p>因此，这次质量问题的关键总结如下。</p>
<p>当下次我们面临一个临时组建，经验不足的项目团队时，面对大流量的业务需求，开发们需要注意：</p>
<ol>
<li>让熟悉业务和技术的同学帮忙做CodeReview。</li>
<li>设计出符合业务场景的压测方案。</li>
</ol>
<p>这两点就可以落地了，这也不是说项目管理上没有改进的，而是优先保证这两点，能更有效的降低风险。</p>
<p>CodeReview的技巧这里就不多少说，来谈谈我们做的几次压测方案的改进。</p>
<h2 id="2、三轮的压测改进"><a href="#2、三轮的压测改进" class="headerlink" title="2、三轮的压测改进"></a>2、三轮的压测改进</h2><ol>
<li>单用户，单接口，双机压测</li>
<li>随机用户，多接口，全量压测</li>
<li>随机用户，功能分组接口，全量压测</li>
</ol>
<p>最开始压测方案是用一个用户，两台服务器，一个缓存分片做压测，然后简单的用服务器QPS的均值乘以线上部署机器数量当作压测结果。</p>
<p>这个方案如果是下图左侧的场景，调用链路上的服务器可以同时弹性扩展自然是可以的。</p>
<p>但要是右侧的场景，调用链路上存在瓶颈，比如数据库是一个节点，并且无法扩展，那就问题了。</p>
<p>同样的，这次项目的问题就是Redis成为了一个单节点的瓶颈。另外由于用户id是固定的，所以缓存很可能被重复使用，这样就难以测试到频繁创建缓存的场景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yfwin/file@gh-pages/xxx.616cq7y6nck0.jpg" alt="xxx"></p>
<p>在系统重构后，改进了一种压测方案，<strong>通过随机用户Id，批量轮询接口，并且通过测试环境的弹性扩展，完全模拟线上的部署环境</strong>。</p>
<p>还通过加降级开关，<strong>把入参合法性、风控、时效性校验等临时关闭</strong>，以便能让压测的请求贯穿整个主流程。</p>
<p>接着在这一方案的基础上，通过对接口分组和伪造恰当的数据，<strong>编写贴近真实的调用行为的脚本</strong>，再次做了压测。</p>
<p>在执行人员上，也经历了从开发提供数据，测试全权负责；到测试主导，开发参与；再到开发主导，测试协助的过程。</p>
<p>由此，压测方案就越来越贴近真实场景，压测结论自然就更加可信 。</p>
<h2 id="3、高并发场景下的设计"><a href="#3、高并发场景下的设计" class="headerlink" title="3、高并发场景下的设计"></a>3、高并发场景下的设计</h2><p>前面谈到了系统设计的不合理导致了本次性能问题，来分析下这里面的根本原因。</p>
<p>首先要理解的是，Redis集群是由多个分片构成的，一条数据被写到哪个分片里，是由key的hash值来离散的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yfwin/file@gh-pages/xxx.4rxgor3uo900.jpg" alt="xxx"></p>
<p>比如说，我们要在Redis里面缓存一批用户信息，并且能通过ID来存取。</p>
<p>如果用Redis自带的Hash表结构写法如下：</p>
<p>存：<code>redis.hset(&quot;userMap&quot;,ID,userInfo)</code></p>
<p>读：<code>redis.hget(&quot;userMap&quot;,ID)</code></p>
<p>那么，因为key是固定的userMap，这意味着所有的用户信息都会被写到一个分片里。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yfwin/file@gh-pages/xxx.69a3oq1apw80.jpg" alt="xxx"></p>
<p>而对于通常的分布式系统的设计，<strong>一个基本原则是：让流量尽可能的被集群的机器平摊。</strong></p>
<p>固定的key就无法利用分布式的优势了，并且如果并发量高，这就会让一个分片去抗所有的流量，再加上如果用户量数十万，还有一次性读取所有数据的操作，这样就变成一场灾难了。</p>
<p>实际设计时，直接把整个Redis集群当作一个Hash表的方式更加高效。</p>
<p>存：<code>redis.set(&quot;userMap&quot;+ID,userInfo)</code></p>
<p>读：<code>redis.get(&quot;userMap&quot;+ID)</code></p>
<p>这里的key&#x3D;”userMap”+ID，ID不同key就被离散了，请求会集群平摊，从而充分发挥分布式系统的性能。</p>
<h1 id="三、黑产和羊毛党的问题"><a href="#三、黑产和羊毛党的问题" class="headerlink" title="三、黑产和羊毛党的问题"></a>三、黑产和羊毛党的问题</h1><p>在项目上线后另一个没重视的问题出现了，那就是大量的黑产和羊毛党出现，活动奖励全被这些用脚本的人占据了。</p>
<p>对黑产的事前考虑太少了，仅做了简单的风控校验，根本检测不足异常用户，导致黑产可以通过脚本大量刷接口。</p>
<p>这里的经验有两点：</p>
<ol>
<li>对包含现金、现金等价物或高价值奖励的活动，要有面对黑产的心理预期。</li>
<li>在大公司，专业的事情找专业的人做，基于业务场景，提前跟风控团队沟通好。</li>
</ol>
<p>对于第一点，基本上只要值点钱的活动，黑产肯定跑不了，空手套白狼，抢到就是赚到，不妨想想如果你是黑产，结合下业务场景，你会怎么来刷自己的系统。</p>
<p>基于第一点，公司没有风控团队那就只能自己做了，而一般上点规模的公司都有自己的风控团队，利用好现成资源。</p>
<p>风控主要考虑两方面：</p>
<ol>
<li>有风控团队的，接入他们的通用风控模型。</li>
<li>针对项目的业务场景，定制化一些风控模型。</li>
</ol>
<p>通用风控模型基本是通过新老账号、异地登录、人机识别等等用户行为建立的用户画像，通过离线计算和实时校验来处理。</p>
<p>定制化模型视情况而定，比如拉一个单独的小黑户，放进去的用户不能参与这个活动等等。</p>
<p>被拦截的用户一般是走验证码或直接拉黑，对于后者，别忘了和客服的妹子们打好招呼，准备下话术应对客诉。</p>
<h1 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h1><p>最后总结下项目的经验。</p>
<p>首先是前提：</p>
<ol>
<li>当你的面前的是一个临时组建，对现在项目经验不足的项目团队时。</li>
<li>当你面临一个大流量，包含现金或等价物的活动时。</li>
</ol>
<p>请务必做好这三点：</p>
<ol>
<li>找熟悉本项目的业务和技术的开发参与方案的设计和CodeReview。</li>
<li>请开发主动参与压测任务，设计压测方案，注意尽可能模拟真实场景。</li>
<li>做好应对黑产的心理准备，直到大促活动结束。</li>
</ol>
<p>来自于，一个连续加班51小时29分，被用户吐槽整只羊都被人家牵走了的开发。</p>
<p><a href="https://www.cnblogs.com/wchukai/p/11174189.html">原文链接</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>（转载）图解：原来这就是网络</title>
    <url>/posts/6e02c268.html</url>
    <content><![CDATA[<p><strong>你是****一台电脑，你的名字叫 A</strong></p>
<p>很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210112113108347-489796525.png"></p>
<span id="more"></span>

<p>直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根<strong>网线</strong>连接了起来。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210112113119601-1581686975.png"></p>
<p>用一根网线连接起来怎么就能”通信”了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。</p>
<p>如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在<strong>开枪</strong>吧~</p>
<p><img src="https://cdn.jsdelivr.net/gh/yfwin/file@gh-pages/yfwin1231.5gw57a2nyfs0.gif"></p>
<p>反正，你们就是连起来了，并且可以通信。</p>
<h1 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h1><p>有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开<strong>两个网口</strong>，用一共<strong>三根网线</strong>，彼此相连。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210112113222683-1929492571.png"></p>
<p>随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210112113229408-608147059.png"></p>
<p>于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210112113237519-90632179.png"></p>
<p>你给它取名叫<strong>集线器</strong>，它仅仅是无脑将电信号<strong>转发到所有出口（广播）</strong>，不做任何处理，你觉得它是没有智商的，因此把人家定性在了<strong>物理层</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yfwin/file@gh-pages/yfwin1232.2scd58stv7c0.gif"></p>
<p>由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？</p>
<p>首先，你要给所有的连接到交换机的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，<strong>全局唯一</strong>的名字作为标识，你把这个更高端的名字称为 <strong>MAC 地址</strong>。</p>
<p>你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。</p>
<p>这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210112180112546-2060866082.png"></p>
<p>B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便<strong>收下</strong>。</p>
<p>其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便<strong>丢弃</strong>。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160719106-720454177.gif"></p>
<p>虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。</p>
<h1 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h1><p>如果把这个集线器弄得更智能一些，<strong>只发给目标 MAC 地址指向的那台电脑</strong>，就好了。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160752131-1012438977.gif"></p>
<p>虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做<strong>交换机</strong>。也正因为这一点点智能，你把它放在了另一个层级，<strong>数据链路层</strong>。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160801901-445676775.png"></p>
<p>如上图所示，你是这样设计的。</p>
<p>交换机内部维护一张 <strong>MAC 地址表</strong>，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。</p>
<table>
<thead>
<tr>
<th>MAC 地址</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>bb-bb-bb-bb-bb-bb</td>
<td>1</td>
</tr>
<tr>
<td>cc-cc-cc-cc-cc-cc</td>
<td>3</td>
</tr>
<tr>
<td>aa-aa-aa-aa-aa-aa</td>
<td>4</td>
</tr>
<tr>
<td>dd-dd-dd-dd-dd-dd</td>
<td>5</td>
</tr>
</tbody></table>
<p>假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160858615-1822730185.png"></p>
<p>到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现<strong>目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上</strong>，于是把数据从 1 号端口发给了 B，完事~</p>
<p>你给这个通过这样传输方式而组成的小范围的网络，叫做<strong>以太网</strong>。</p>
<p>当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？</p>
<p>假如在 MAC 地址表为空是，你给 B 发送了如下数据</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160907033-656727777.png"></p>
<p>由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：</p>
<p><strong>MAC：aa-aa-aa-aa-aa-aa-aa<br>端口：4</strong></p>
<p>交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了<strong>所有端口</strong>，也即发给了所有机器。</p>
<p>之后，只有机器 B 收到了确实是发给自己的包，于是做出了<strong>响应</strong>，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：</p>
<p><strong>MAC：bb-bb-bb-bb-bb-bb<br>端口：1</strong></p>
<p>过程如下</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160940898-874572467.gif"></p>
<p>经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~</p>
<p>随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113160959373-1649379495.png"></p>
<p>你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。</p>
<p>但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。</p>
<p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p>
<p><strong>左边的交换机</strong></p>
<table>
<thead>
<tr>
<th>MAC 地址</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>bb-bb-bb-bb-bb-bb</td>
<td>1</td>
</tr>
<tr>
<td>cc-cc-cc-cc-cc-cc</td>
<td>3</td>
</tr>
<tr>
<td>aa-aa-aa-aa-aa-aa</td>
<td>4</td>
</tr>
<tr>
<td>dd-dd-dd-dd-dd-dd</td>
<td>5</td>
</tr>
<tr>
<td>ee-ee-ee-ee-ee-ee</td>
<td>6</td>
</tr>
<tr>
<td>ff-ff-ff-ff-ff-ff</td>
<td>6</td>
</tr>
<tr>
<td>gg-gg-gg-gg-gg-gg</td>
<td>6</td>
</tr>
<tr>
<td>hh-hh-hh-hh-hh-hh</td>
<td>6</td>
</tr>
</tbody></table>
<p><strong>右边的交换机</strong></p>
<table>
<thead>
<tr>
<th>MAC 地址</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>bb-bb-bb-bb-bb-bb</td>
<td>1</td>
</tr>
<tr>
<td>cc-cc-cc-cc-cc-cc</td>
<td>1</td>
</tr>
<tr>
<td>aa-aa-aa-aa-aa-aa</td>
<td>1</td>
</tr>
<tr>
<td>dd-dd-dd-dd-dd-dd</td>
<td>1</td>
</tr>
<tr>
<td>ee-ee-ee-ee-ee-ee</td>
<td>2</td>
</tr>
<tr>
<td>ff-ff-ff-ff-ff-ff</td>
<td>3</td>
</tr>
<tr>
<td>gg-gg-gg-gg-gg-gg</td>
<td>4</td>
</tr>
<tr>
<td>hh-hh-hh-hh-hh-hh</td>
<td>6</td>
</tr>
</tbody></table>
<p>这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。</p>
<p>但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。</p>
<h1 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h1><p>交换机已经无法记录如此庞大的映射关系了。</p>
<p>此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。</p>
<p>那我可不可以让那根红色的网线，接入一个<strong>新的设备</strong>，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次<strong>转发</strong>呢？</p>
<p>这个设备就是<strong>路由器，</strong>它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发<strong>，</strong>你把它定在了<strong>网络层。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161118181-1249284127.png"></p>
<p>注意，路由器的每一个端口，都有独立的 MAC 地址</p>
<p>好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。**<br>**</p>
<p>那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH…. 的数据包，统统先发送给路由器呢？</p>
<p>不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是</p>
<p>**C 的 MAC 地址：FFFF-FFFF-CCCC<br>**<strong>D 的 MAC 地址：FFFF-FFFF-DDDD</strong></p>
<p>那我们就可以说，将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统统先发送给路由器。</p>
<p>这样是否可行呢？答案是否定的。</p>
<p>我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示</p>
<p><strong>00-16-EA-AE-3C-40</strong></p>
<p>它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中<strong>前 24 位（00-16-EA）代表网络硬件制造商的编号****，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。</strong>只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。</p>
<p>那如果你希望向上面那样表示将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。</p>
<p>这显然是不现实的。</p>
<p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p>
<p><strong>11000000101010000000000000000001</strong></p>
<p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p>
<p><strong>11000000.10101000.00000000.00000001</strong></p>
<p>你还觉得不清晰，于是把它转换成 10 进制。</p>
<p><strong>192.168.0.1</strong></p>
<p>最后你给了这个地址一个响亮的名字，<strong>IP 地址</strong>。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是<strong>软件层面</strong>上的，可以随时修改，MAC 地址一般是无法修改的。</p>
<p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161205246-2003100799.png"></p>
<p>如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，**”将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！”**，巧妙吧。</p>
<p>那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？</p>
<p>别急我们慢慢来。</p>
<p>我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161220286-787982509.png"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p>
<p>现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。</p>
<p>假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161403507-1635022832.png"></p>
<p>但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。</p>
<p>A ~ 路由器这段的包如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161418577-1258702647.png"></p>
<p>路由器到 C 这段的包如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161428566-2097087686.png"></p>
<p>好了，上面说的两种情况（A-&gt;B，A-&gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。</p>
<p><strong>A 给 C 发数据包，怎么知道是否要通过路由器转发呢？</strong></p>
<p><strong>答案：子网</strong></p>
<p>如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。</p>
<p>如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。</p>
<p>好，那现在只需要解决，什么叫处于一个子网就好了。</p>
<ul>
<li>192.168.0.1 和 192.168.0.2 处于同一个子网</li>
<li>192.168.0.1 和 192.168.1.1 处于不同子网</li>
</ul>
<p>这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：</p>
<p><strong>192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。</strong></p>
<p>那对于计算机来说，怎么表达这个意思呢？于是人们发明了<strong>子网掩码</strong>的概念</p>
<p>假如某台机器的子网掩码定为 255.255.255.0</p>
<p>这表示，将源 IP 与目的 IP 分别同这个子网掩码进行<strong>与运算****，相等则是在一个子网，不相等就是在不同子网</strong>，就这么简单。</p>
<p>比如</p>
<ul>
<li><strong>A电脑</strong>：192.168.0.1 &amp; 255.255.255.0 &#x3D; 192.168.0.0</li>
<li><strong>B电脑</strong>：192.168.0.2 &amp; 255.255.255.0 &#x3D; 192.168.0.0</li>
<li><strong>C电脑</strong>：192.168.1.1 &amp; 255.255.255.0 &#x3D; 192.168.1.0</li>
<li><strong>D电脑</strong>：192.168.1.2 &amp; 255.255.255.0 &#x3D; 192.168.1.0</li>
</ul>
<p>那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161508940-44439559.png"></p>
<p>所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 &amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，<strong>之后怎么转发，A 不关心</strong>。</p>
<p><strong>A 如何知道，哪个设备是路由器？</strong></p>
<p><strong>答案：在 A 上要设置默认网关</strong></p>
<p>上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？</p>
<p>其实说发给路由器不准确，应该说 A 会把包发给<strong>默认网关</strong>。</p>
<p>对 A 来说，A 只能<strong>直接</strong>把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p>
<p>所以<strong>默认网关，就是 A 在自己电脑里配置的一个 IP 地址</strong>，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161533026-2086301749.png"></p>
<p>仅此而已！</p>
<p><strong>路由器如何知道C在哪里？</strong></p>
<p><strong>答案：路由表</strong></p>
<p>现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，<strong>路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去</strong>，才能直接（或间接）地最终到达目的地 C 呢。</p>
<p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p>
<p>这个表就叫<strong>路由表</strong>。</p>
<p>至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~</p>
<p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。</p>
<table>
<thead>
<tr>
<th>目的地址</th>
<th>子网掩码</th>
<th>下一跳</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.0</td>
<td>255.255.255.0</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>192.168.0.254</td>
<td>255.255.255.255</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>192.168.1.0</td>
<td>255.255.255.0</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>192.168.1.254</td>
<td>255.255.255.255</td>
<td></td>
<td>1</td>
</tr>
</tbody></table>
<p>我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0&#x2F;24</p>
<table>
<thead>
<tr>
<th>目的地址</th>
<th>下一跳</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.0&#x2F;24</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>192.168.0.254&#x2F;32</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>192.168.1.0&#x2F;24</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>192.168.1.254&#x2F;32</td>
<td></td>
<td>1</td>
</tr>
</tbody></table>
<p>这就很好理解了，路由表就表示，<strong>192.168.0.xxx 这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口</strong>。下一跳列还没有值，我们先不管</p>
<p>配合着结构图来看（这里把子网掩码和默认网关都补齐了）</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161643720-1899800112.gif"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="></p>
<p><strong>刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？</strong></p>
<p><strong>答案：arp</strong></p>
<p>假如你（A）此时<strong>不知道</strong>你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？</p>
<p>答案很简单，在网络层，<strong>我需要把 IP 地址对应的 MAC 地址找到</strong>，也就是通过某种方式，找到 <strong>192.168.0.2</strong> 对应的 MAC 地址 <strong>BBBB</strong>。</p>
<p>这种方式就是 <strong>arp 协议</strong>，同时电脑 A 和 B 里面也会有一张 <strong>arp 缓存表</strong>，表中记录着 <strong>IP 与 MAC 地址</strong>的对应关系。</p>
<table>
<thead>
<tr>
<th>IP 地址</th>
<th>MAC 地址</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.2</td>
<td>BBBB</td>
</tr>
</tbody></table>
<p>一开始的时候这个表是<strong>空的</strong>，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会<strong>广播</strong>一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个<strong>响应</strong>。此时 A 便更新了自己的 arp 表。</p>
<p>这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。</p>
<p><strong>总结一下</strong></p>
<p>好了，总结一下，到目前为止就几条规则</p>
<p><strong>从各个节点的视角来看</strong></p>
<p><strong>电脑视角****：</strong></p>
<ul>
<li>首先我要知道我的 IP 以及对方的 IP</li>
<li>通过子网掩码判断我们是否在同一个子网</li>
<li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li>
<li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li>
</ul>
<p><strong>交换机视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 MAC 地址</li>
<li>通过 MAC 地址表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去</li>
<li>查不到就所有端口都发出去</li>
</ul>
<p><strong>路由器视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 IP 地址</li>
<li>通过路由表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li>
<li>查不到则返回一个路由不可达的数据包</li>
</ul>
<p>如果你嗅觉足够敏锐，你应该可以感受到下面这句话：</p>
<p>网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。</p>
<p><strong>涉及到的三张表分别是</strong></p>
<ul>
<li>交换机中有 <strong>MAC 地址</strong>表用于映射 MAC 地址和它的端口</li>
<li>路由器中有<strong>路由表</strong>用于映射 IP 地址(段)和它的端口</li>
<li>电脑和路由器中都有** arp 缓存表**用于缓存 IP 和 MAC 地址的映射关系</li>
</ul>
<p><strong>这三张表是怎么来的</strong></p>
<ul>
<li>MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。</li>
<li>路由表是各种路由算法 + 人工配置逐步完善起来的。</li>
<li>arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。</li>
</ul>
<p>知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161739153-1929826020.png"></p>
<p>那接下来我们就放上本章 <strong>最后一个</strong>** **网络拓扑图吧，请做好 <strong>战斗</strong> 准备！</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161800183-136989726.png"></p>
<p>这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。</p>
<p>也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。</p>
<table>
<thead>
<tr>
<th>目的地址</th>
<th>下一跳</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.0&#x2F;24</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>192.168.0.254&#x2F;32</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>192.168.1.0&#x2F;24</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>192.168.1.254&#x2F;32</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>192.168.2.0&#x2F;24</td>
<td>192.168.100.5</td>
<td></td>
</tr>
<tr>
<td>192.168.100.0&#x2F;24</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>192.168.100.4&#x2F;32</td>
<td></td>
<td>2</td>
</tr>
</tbody></table>
<h3 id="这时如果-A-给-F-发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？"><a href="#这时如果-A-给-F-发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？" class="headerlink" title="这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？"></a><strong>这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？</strong></h3><p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161811762-1413374819.png"></p>
<p>思考一分钟…</p>
<p><strong>详细过程动画描述：</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161833188-1240436827.gif"></p>
<p><strong>详细过程文字描述：</strong></p>
<p><strong>1.</strong> 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）</p>
<p><strong>2.</strong> A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。</p>
<p><strong>3.</strong> A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113161840079-760802967.png"></p>
<p><strong>4.</strong> 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1</p>
<p><em><strong>5.</strong> 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5</em></p>
<p><strong>6.</strong> 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。</p>
<p><strong>7.</strong> 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。</p>
<p><strong>8.</strong> 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。</p>
<p><strong>9.</strong> 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其 6 号端口出去，于是从 6 号端口把数据包发出去。</p>
<p><strong>10.</strong>** **<strong>F 最终收到了数据包！</strong>并且发现目的 MAC 地址就是自己，于是收下了这个包</p>
<p><strong>更详细且精准的过程：</strong></p>
<p>读到这相信大家已经很累了，理解上述过程基本上网络层以下的部分主流程就基本疏通了，如果你想要本过程更为专业的过程描述，可以在公众号 低并发编程 后台回复 网络，获得我模拟这个过程的 Cisco Packet Tracer 源文件。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113162022736-771095118.png"></p>
<p>每一步包的传输都会有各层的原始数据，以及专业的过程描述</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113162032699-1964569785.png"></p>
<p>同时在此基础之上你也可以设计自己的网络拓扑结构，进行各种实验，来加深网络传输过程的理解。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。</p>
<p><img src="https://img2020.cnblogs.com/blog/1096103/202101/1096103-20210113162048507-66873944.png"></p>
<p>本文经过了很多次的修改，删减了不少影响主流程的内容，就是为了让读者能抓住网络传输前三层的真正核心思想。同时网络相关的知识也是多且杂，我也还有很多搞不清楚的地方，非常欢迎大家与我交流，共同进步。</p>
<p><a href="https://www.cnblogs.com/flashsun/p/14266148.html">原文：图解 | 原来这就是网络</a></p>
]]></content>
      <categories>
        <category>网络</category>
        <category>IP</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>IP</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>毛泽东思想指导地位的确立及启示</title>
    <url>/posts/82fe7e52.html</url>
    <content><![CDATA[<p>2021年7月1日，习近平总书记在庆祝中国共产党成立100周年大会上强调指出：“以史为鉴、开创未来，必须继续推进马克思主义中国化。”毛泽东思想作为马克思主义中国化重要理论成果，是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结。1945年党的七大把毛泽东思想确立为党的指导思想并写入党章，从此中国革命事业便不断走向胜利。回顾毛泽东思想指导地位确立的历史过程，对于我们深刻认识习近平新时代中国特色社会主义思想的历史地位，增强“四个意识”、坚定“四个自信”、做到“两个维护”，牢记“国之大者”，有着十分重要的启示作用。</p>
<span id="more"></span>

<h1 id="毛泽东思想指导地位的确立"><a href="#毛泽东思想指导地位的确立" class="headerlink" title="毛泽东思想指导地位的确立"></a>毛泽东思想指导地位的确立</h1><p>毛泽东思想是在中国革命艰难困苦时期创立的。1927年大革命失败，中国共产党经受了自创立以来从未有过的巨大挫折：共产党员和革命群众遭到反动派的疯狂屠杀，党员数量由大革命高潮时期的近6万人急剧减少到1万多人，党的活动被迫转入地下。毛泽东后来曾形象地比喻说：“被人家一巴掌打在地上，像一篮鸡蛋一样摔在地上，摔烂很多”。但是，以毛泽东同志为主要代表的中国共产党人，认真总结经验教训，深刻分析我国的实际情况，在实践中创造性地开辟了一条农村包围城市、武装夺取政权的中国革命道路，进而在理论上逐渐创立起了把马克思列宁主义的基本原理同中国革命的具体实际相结合的毛泽东思想。</p>
<blockquote>
<p>——20世纪20年代后期和30年代前期，毛泽东思想是在同把马克思主义教条化、把共产国际决议和苏联经验神圣化的错误倾向作斗争，并深刻总结这方面历史经验教训的过程中逐渐形成和发展起来的。</p>
</blockquote>
<p>大革命失败后，党内一些人不顾中国革命实际，把共产国际决议和苏联经验奉若神明，机械照搬资本主义国家无产阶级政党特别是俄国经验，企图以夺取中心城市的武装暴动实现一省或数省的首先胜利，因而接连发生了1927年11月至1928年4月的“左”倾盲动错误、1930年6月至9月的“左”倾冒险错误和1931年1月由党的扩大的六届四中全会开始的长达四年的、以王明为代表的“左”倾教条主义错误，使中国革命几乎陷于绝境。</p>
<p>毛泽东同这些错误倾向作了坚持不懈的斗争。为了保存和发展革命力量，他率领秋收起义部队上井冈山，把工作重点由城市转入农村。从1928年10月到1930年1月，在领导红军作战和根据地建设实践中，毛泽东先后写成《中国的红色政权为什么能够存在？》、《井冈山的斗争》、《星星之火，可以燎原》等著作，阐明中国革命为什么必须实行“工农武装割据”，并在此基础上提出了以农村包围城市为特征的中国式的武装夺取政权的革命道路思想，从而“在理论上更具体地和更完满地给了中国革命的方向以马克思列宁主义的科学根据”。与此同时，与之相关的土地革命的思想、根据地建设的思想、党的建设和人民军队建设的思想等，在毛泽东的论述中也逐步深入展开。</p>
<p>1930年5月，毛泽东写下《调查工作》（20世纪60年代公开发表时题目改为《反对本本主义》）一文，尖锐批评脱离中国革命实际、照抄决议本本、照搬苏联经验的教条主义，在党的历史上第一次明确提出了“没有调查，没有发言权”等重要思想。这篇文章初步形成了毛泽东思想活的灵魂的三个基本方面，即实事求是、群众路线、独立自主，初步解决了怎样把马克思主义基本原理同中国具体实际相结合的根本原则问题。</p>
<p>农村包围城市、武装夺取政权思想的提出，标志着毛泽东思想的初步形成。</p>
<p><img src="https://pics4.baidu.com/feed/63d9f2d3572c11df617648991e1e43d9f603c2ac.jpeg?token=82f5a22dbfe219da6c92dd9c132736dd"></p>
<p>1938年10月，毛泽东在党的扩大的六届六中全会上作题为《论新阶段》的政治报告，明确提出“马克思主义的中国化”的命题。图为同年12月重庆新华日报社出版的《论新阶段》单行本（资料图片）。</p>
<blockquote>
<p>——毛泽东思想在土地革命战争后期和全民族抗日战争时期得到系统总结和多方面展开而达到成熟。</p>
</blockquote>
<p>经历了大革命和土地革命的起伏曲折，中国共产党人在比较中更为清楚地认识到中国社会的历史和现状、中国革命的特点和规律。毛泽东后来认为自己在这一时期撰写的文章和起草的文件，“都是革命经验的总结。那些论文和文件，只有在那个时候才能产生，在以前不可能，因为没有经过大风大浪，没有两次胜利和两次失败的比较，还没有充分的经验，还不能充分认识中国革命的规律”。</p>
<p>中央红军到达陕北后，毛泽东先后写下《论反对日本帝国主义的策略》、《中国革命战争的战略问题》、《实践论》、《矛盾论》等著作，从政治路线、军事路线、思想路线上对土地革命战争时期的历史经验教训进行理论总结和哲学概括，创造性地发展了马克思主义哲学，为系统提出实事求是的思想路线奠定了基础。在全民族抗战爆发后新的历史条件下，毛泽东先后发表《抗日游击战争的战略问题》、《论持久战》两篇军事理论著作，系统论述了抗日游击战争的战略地位、抗日战争的持久战总方针和人民战争思想等。</p>
<p>全面抗战爆发以后，中国共产党从原来遭受严密封锁的狭小天地里走出来，变成全国性的大党，公开走上全国政治生活的大舞台，受到人们越来越密切的关注。1939年到1940年初，毛泽东接连发表《〈共产党人〉发刊词》、《中国革命和中国共产党》、《新民主主义论》等著作，从总结论述统一战线、武装斗争、党的建设“三大法宝”，到第一次明确提出“在无产阶级领导之下的人民大众的反帝反封建的革命”，再到系统阐述新民主主义的政治、经济和文化，不仅回答了当前时局中提出的种种问题，而且回答了中国现阶段民主革命和未来建设新中国的一系列根本问题。随着抗日民族统一战线实践的深入展开，毛泽东在1940、1941年撰写《目前抗日统一战线中的策略问题》、《论政策》、《关于打退第二次反共高潮的总结》等著作，科学论述了“争取中间势力”和“有理、有利、有节”的斗争策略，丰富和完善了抗日民族统一战线思想，并提出了许多重要的政策和策略思想。</p>
<p>新民主主义理论的提出和抗日民族统一战线的一系列方针政策的确定，标志着毛泽东思想已经日渐成熟。</p>
<blockquote>
<p>——毛泽东思想在党的七大上被确立为党的指导思想并写入党章。</p>
</blockquote>
<p>随着毛泽东思想的不断发展成熟和正确指导实践，人们越来越深切地感受到，需要对这一主要由毛泽东提出的关于中国革命的理论给予适当的命名和加以正确的评价。1941年3月，党的理论工作者张如心用了“毛泽东同志的思想”这一概念。同年6月，中共中央北方局、八路军野战政治部指示：要宣传“我党领袖毛泽东同志发展了马列主义的关于中国革命的各项学说和主张”。1943年7月5日，王稼祥首次使用“毛泽东思想”这个概念，指出“毛泽东思想就是中国的马克思列宁主义”。与此同时，刘少奇号召全党“用毛泽东的思想来武装自己”，把毛泽东同志的指导贯彻到一切工作环节和部门中去，用毛泽东同志的思想体系去清算党内机会主义思想。</p>
<p>在使用和阐述“毛泽东思想”这一概念过程中，人们对其在党内指导地位的认识也越来越清晰。1943年，邓小平明确提出要“在以毛泽东思想为指导的党中央的领导之下”，“把全党从思想上、行动上统一在布尔什维克——毛泽东思想上”。党的扩大的六届七中全会通过《关于若干历史问题的决议》明确指出：“以毛泽东同志为代表的马克思列宁主义的思想更普遍地更深入地掌握干部、党员和人民群众的结果，必将给党和中国革命带来伟大的进步和不可战胜的力量。”</p>
<p>1945年5月14日，刘少奇在党的七大上作关于修改党章的报告，对毛泽东思想进行了完整概括和系统阐述。他指出：毛泽东思想“就是中国的共产主义，中国的马克思主义”，包括“新民主主义”、“解放农民”、“革命统一战线”、“革命战争”、“革命根据地”、“建设新民主主义共和国”、“建设党”、“文化”等方面的理论与政策，“是我们党的唯一正确的指导思想，唯一正确的总路线”。6月11日，党的七大通过的《中国共产党党章》明确规定：“中国共产党，以马克思列宁主义的理论与中国革命的实践之统一的思想——毛泽东思想，作为自己一切工作的指针，反对任何教条主义的或经验主义的偏向。”</p>
<p>毛泽东思想指导地位的确立，标志着全党在思想上的成熟和统一。胡乔木后来回忆说：“为什么要提毛泽东思想？有这个需要。如果中国共产党不提毛泽东思想，很难在全党形成思想上的统一。”“党内各方面的关系，党同群众之间的关系，都在毛泽东思想基础上确定下来。为什么四十年代中国党能够在那么困难的条件下取得那么大的胜利？根本原因是党正确解决了这个问题。”</p>
<p><img src="https://pics6.baidu.com/feed/faf2b2119313b07eb71a265a89eeb02a96dd8cfb.jpeg?token=bf1468120c8489e87e16702ff8542097"></p>
<h1 id="毛泽东核心地位确立与毛泽东思想指导地位确立"><a href="#毛泽东核心地位确立与毛泽东思想指导地位确立" class="headerlink" title="毛泽东核心地位确立与毛泽东思想指导地位确立"></a>毛泽东核心地位确立与毛泽东思想指导地位确立</h1><p>毛泽东核心地位和毛泽东思想指导地位，都是在波澜壮阔的中国革命斗争实践中逐步形成和确立的。从1935年遵义会议到1945年党的七大，毛泽东核心地位的确立经历了一个长期艰辛的过程。在这个过程中，毛泽东思想也不断得以发展成熟，直至成为全党的指导思想。确立毛泽东核心地位和确立毛泽东思想指导地位，二者相辅相成、相互促进。正是因为以毛泽东同志为核心的党的第一代中央领导集体的逐步形成，党才能够更好地从全局和战略的高度总结历史经验和进行理论思考，从而大大丰富和发展了毛泽东思想。与此同时，毛泽东思想引导中国革命航船不断乘风破浪前进，从而使得以毛泽东同志为核心的中央领导集体在全党和全国人民中逐渐赢得崇高威望。</p>
<blockquote>
<p>——遵义会议事实上确立了毛泽东在党中央和红军的领导地位，开始确立了以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位，为毛泽东思想发展成熟和发挥作用奠定了根本的政治基础。</p>
</blockquote>
<p>遵义会议以前，中国共产党无论在革命理论上还是在斗争实践中，都尚未成熟。毛泽东提出的一些正确理论、路线和策略，遭到在中央占据统治地位的“左”、右倾错误，特别是王明“左”倾教条主义的反对、排斥和打击。但是，这些错误倾向在实际工作中却不断碰壁，甚至直接导致了各主要根据地的丢失和党在国民党统治区组织的严重破坏。这些错误“开始在更多的领导干部和党员群众面前暴露”，“引起了他们的怀疑和不满”。党内一些曾经犯过错误的同志也不断“开始觉悟”。这样，毛泽东所代表的正确方向和毛泽东思想就为越来越多的人所认识和接受。</p>
<p>遵义会议集中解决当时具有决定意义的军事和组织问题，增选毛泽东为中央政治局常委，取消长征前成立的“三人团”，仍由最高军事首长朱德、周恩来为军事指挥者，而周恩来是党内委托的对于指挥军事下最后决心的负责者。会后不久，决定毛泽东为周恩来在军事指挥上的帮助者，后成立由毛泽东、周恩来、王稼祥组成的三人小组，负责全军的军事行动。这就在事实上确立了毛泽东在党中央和红军的领导地位，开始形成以毛泽东同志为核心的党的第一代中央领导集体。同时，遵义会议结束了“左”倾教条主义错误在中央的统治，充分肯定了毛泽东从中国革命战争特点出发提出的战略战术原则的正确性，从而开始确立了以毛泽东同志为主要代表的马克思主义正确路线在党中央的领导地位。</p>
<blockquote>
<p>——党的扩大的六届六中全会为实现党对抗日战争的领导进行了全面的战略规划，进一步巩固了毛泽东在全党的领导地位，在毛泽东思想发展史上第一次明确提出“马克思主义的中国化”的指导原则。</p>
</blockquote>
<p>1938年9月至11月召开的党的扩大的六届六中全会，被毛泽东认为是“决定中国之命运”的一次重要会议。此前，王稼祥带来了共产国际的重要指示，肯定了毛泽东等领导的“政治路线是正确的”，指出中共中央领导机关中“要以毛泽东为核心解决统一领导问题”。这剥夺了王明以共产国际“钦差大臣”自居、不断对中央政治路线说三道四的资本，为六届六中全会的顺利召开做了重要准备。六届六中全会正确地分析了抗日战争的形势，规定了党在抗战新阶段的任务，基本纠正了王明的右倾错误，进一步巩固了毛泽东在全党的领导地位。</p>
<p>毛泽东在六届六中全会上作了《论新阶段》的政治报告，不仅指出了“抗日民族战争与抗日民族统一战线发展”进入“新阶段”，而且也表明中国共产党在实现马克思主义中国化方面，事实上也达到了一个“新阶段”。一方面，毛泽东代表中共中央第一次向全党提出了“马克思主义的中国化”的任务——“把马克思主义应用到中国具体环境的具体斗争中去”，“使之在其每一表现中带着中国的特性，即是说，按照中国的特点去应用它”。另一方面，毛泽东在这次全会中，对之后被概括为中国革命“三大法宝”的统一战线、武装斗争和党的建设等问题也都作出了十分精辟的论述。</p>
<blockquote>
<p>——延安整风运动实现了在以毛泽东同志为核心的党中央领导下全党新的团结和统一，促进了全党进一步团结在毛泽东思想的旗帜下。</p>
</blockquote>
<p>20世纪40年代前期，中国共产党以延安为中心，在全党范围内开展了一次深刻的马克思主义思想教育运动。在学习讨论党的历史路线，明辨思考党的若干历史问题的基本是非过程中，全党高度评价了毛泽东的革命功绩和对马克思主义的创造性发展，从而更深刻地认识到确立毛泽东核心地位和确立毛泽东思想指导地位的必然性和必要性。</p>
<p>在整风运动过程中，为加强党的集中统一领导，1943年3月20日，中央政治局会议通过《中共中央关于中央机构调整及精简的决定》，推定毛泽东为政治局主席，并决定他为书记处主席。毛泽东、刘少奇、任弼时组成中央书记处，书记处所讨论的问题，“主席有最后决定之权”。这是一次重要的中央机构和人事的调整，从组织手续上完成了毛泽东在全党的领导核心地位的确立。整风运动的开展，对推动毛泽东思想进一步成熟、建立起独特的思想体系并取得全党共识也起了重要的催化作用。全党加深了对毛泽东思想的认识，掀起了学习和研究毛泽东思想的热潮。在整风基础上通过的《关于若干历史问题的决议》，高度评价了毛泽东运用马克思列宁主义基本原理解决中国革命问题的杰出贡献，肯定了确立毛泽东在全党领导地位的重大意义，增强了全党在毛泽东思想基础上的团结。</p>
<blockquote>
<p>——党的七大正式形成以毛泽东同志为核心的党的第一代中央领导集体，确立毛泽东思想为党的指导思想。</p>
</blockquote>
<p>在毛泽东思想作为指导思想写入七大党章的8天后，1945年6月19日，七届一中全会选举毛泽东、朱德、刘少奇、周恩来、任弼时为中央书记处书记，毛泽东为中央委员会主席、中央政治局主席、中央书记处主席，全党在政治上思想上组织上达到空前的团结。</p>
<p><img src="https://pics5.baidu.com/feed/a686c9177f3e6709d62f700446febe34f9dc55db.jpeg?token=8c56db19bfc815afee39e754d4345ceb"></p>
<p>1945年4月至6月，党的七大在延安杨家岭中央大礼堂召开。主席台上方的横幅“在毛泽东的旗帜下胜利前进”，同会场后面的题词“同心同德”，烘托出会议的主题。党的七大使全党在马克思列宁主义、毛泽东思想的基础上达到空前的团结。图为七大会场（资料图片）。</p>
<p>正确认识并确立毛泽东核心地位、毛泽东思想指导地位，是党和人民在长期奋斗中的巨大收获。毛泽东在党内的核心地位和毛泽东思想作为党的指导思想，是全党的共同选择，是历史形成的。朱德曾指出：“在我们党方面，如果没有毛泽东同志的正确领导，如果没有毛泽东思想的指导而不断地纠正了各方面的缺点和错误，就不能使党和人民革命事业得到如此迅速而巨大的发展，则胜利的获得也同样地是很难想象的。”</p>
<h1 id="确立毛泽东思想指导地位的历史意义和现实启示"><a href="#确立毛泽东思想指导地位的历史意义和现实启示" class="headerlink" title="确立毛泽东思想指导地位的历史意义和现实启示"></a>确立毛泽东思想指导地位的历史意义和现实启示</h1><blockquote>
<p>——确立毛泽东思想为党的指导思想，无论在中国革命和建设的伟大实践中，还是在马克思主义发展史上，都具有重要而深远的历史意义。</p>
</blockquote>
<p>毛泽东思想是“中国人民完整的革命建国理论”。在毛泽东思想指引下，中国共产党团结带领中国人民，不仅创造了新民主主义革命的伟大成就，而且创造了社会主义革命和建设的伟大成就。刘少奇在党的七大上曾富有远见地指出：毛泽东思想“要极大地增强我们党和中国人民的信心和战斗力量，极大地加速中国革命胜利的进程”，“将造福于我国民族至遥远的后代”。20世纪80年代，胡乔木也说过：“如果没有毛泽东思想，很难设想中国革命能够胜利。中国革命曾经经历了那么多的艰难，那么多的曲折，那么多的牺牲，并不是因为中国共产党不相信马克思主义，而是因为把马克思主义同中国革命的实际结合起来很不容易，这不是一件很简单的事情。”</p>
<p>毛泽东思想以独创性理论丰富和发展了马克思列宁主义。毛泽东思想创造性地解决了马克思列宁主义基本原理同中国具体实际相结合的一系列重大问题，创造性地解决了在中国这种特殊的社会历史条件下建设马克思主义政党的一系列重大问题，创造性地解决了缔造一个在党的绝对领导下的人民武装力量的一系列重大问题，创造性地解决了团结全民族最大多数人共同奋斗的革命统一战线的一系列重大问题，创造性地提出和实施了一系列正确的战略策略……实现了马克思主义中国化的第一次历史性飞跃。</p>
<p>毛泽东思想是中国共产党和中国人民宝贵的精神财富。毛泽东思想教育了几代中国共产党人，培养的大批骨干，不仅在新民主主义革命、社会主义革命和建设时期发挥了重要作用，也为新的历史时期开创和建设中国特色社会主义发挥了重要作用。毛泽东思想蕴含的许多基本原理、原则和科学方法，具有普遍意义和重要的指导作用。正如邓小平曾指出的：“没有毛泽东思想，就没有今天的中国共产党，这也丝毫不是什么夸张。毛泽东思想永远是我们全党、全军、全国各族人民的最宝贵的精神财富。”</p>
<blockquote>
<p>——确立毛泽东思想为党的指导思想，为今天毫不动摇地坚持习近平新时代中国特色社会主义思想，坚决做到“两个维护”，提供了鲜明而深刻的现实启示。</p>
</blockquote>
<p>必须在实践中不断丰富和发展马克思主义，不断推进马克思主义中国化时代化。马克思主义是我们立党立国的根本指导思想，是我们党的灵魂和旗帜。但马克思主义不是一成不变的教条，只有把马克思主义基本原理同本国具体实际、历史文化传统、时代要求紧密结合起来，在实践中不断作出新的理论创造，才具有强大的生命力。毛泽东曾说过：“我们要把马、恩、列、斯的方法用到中国来，在中国创造出一些新的东西。只有一般的理论，不用于中国的实际，打不得敌人。”毛泽东思想大大推进了马克思主义中国化的历史进程。这之后，中国共产党不断开辟马克思主义新境界，创立了邓小平理论，形成了“三个代表”重要思想、科学发展观，指引中国人民夺取一个又一个伟大胜利。党的十八大以来，以习近平同志为主要代表的中国共产党人，从理论和实践结合上系统回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义这个重大时代课题，创立了习近平新时代中国特色社会主义思想。这一思想作为马克思主义中国化最新成果，是引领中国、影响世界的思想火炬。在当代中国，坚持和发展习近平新时代中国特色社会主义思想，就是真正坚持和发展马克思主义。</p>
<p>必须在实践中形成和确立坚强有力的领导核心，不断增强拥护核心、跟随核心、捍卫核心的思想自觉、政治自觉、行动自觉。党的指导思想的主要创立者和党的领导核心总是高度一致，党的指导思想的形成、确立与党的领导核心的形成、确立总是紧密联系。确立和维护领导核心，是无产阶级政党走向成熟的重要标志。党的七大不仅确立了毛泽东思想的指导地位，而且正式形成了以毛泽东同志为核心的党的第一代中央领导集体。实践证明，这是中国革命不断走向胜利的重要保证。党的十九大把习近平新时代中国特色社会主义思想确立为党必须长期坚持的指导思想并庄严地写入党章，同时把习近平总书记的核心地位写入党章。这是历史和人民的共同选择、郑重选择、必然选择。在新时代，必须在思想上政治上行动上更加清醒坚定，坚决维护习近平总书记党中央的核心、全党的核心地位。</p>
<p><img src="https://pics2.baidu.com/feed/faedab64034f78f0e9d1957204082b5cb2191c1e.jpeg?token=858c62ea23fabdc361668f01d4aa1be8"></p>
<p>2021年7月，中央宣传部、中央党史和文献研究院、中央和国家机关工委、教育部、中央军委政治工作部、中共北京市委在京联合举办学习贯彻习近平总书记“七一”重要讲话精神系列专题宣讲报告会。图为7月5日拍摄的报告会会场。 新华社记者 陈晔华&#x2F;摄</p>
<p>必须在实践中不断增强党的团结和集中统一，坚决维护党中央权威和集中统一领导。1945年，在党的七大会场主席台上方悬挂着“在毛泽东的旗帜下胜利前进”的红色横幅，在会场后方悬挂着“同心同德”四个大字。从遵义会议到这次“团结的大会，胜利的大会”，全党经历了十年时间才真正深刻认识到维护党的团结和集中统一，维护党中央权威的重大意义，并将其转化为自觉行动。全党达到的空前团结和统一，为夺取抗战胜利和获得全国解放奠定了强大思想政治基础。维护党中央权威和集中统一领导，是一个成熟的马克思主义政党必须始终坚持的重大原则，也是中国革命、建设、改革的重要经验。历史充分证明，我们这么大一个党，这么大一个国家，只有党中央有权威，才能把全党牢固凝聚起来，进而把全国各族人民紧密团结起来，形成万众一心、无坚不摧的磅礴力量。</p>
<p>思想就是力量。在全面建设社会主义现代化国家的新征程中，必须始终坚持以习近平新时代中国特色社会主义思想为指导，在以习近平同志为核心的党中央坚强领导下，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，用马克思主义观察时代、把握时代、引领时代，为实现第二个百年奋斗目标、实现中华民族伟大复兴而不懈奋斗！</p>
]]></content>
      <categories>
        <category>时事政治</category>
      </categories>
      <tags>
        <tag>时事政治</tag>
      </tags>
  </entry>
</search>
